[{"title":"Golang学习笔记（十四）","date":"2018-09-18T16:00:00.000Z","path":"2018/09/19/Golang学习笔记（十四）/","text":"Go语言特性 可直接编译成机器码，直接生成可执行二进制文件 静态类型语言，可以在编译的时候检查出来隐藏的大多数问题 动态类型语言：是指在运行期间才去做数据类型检查的语言，说的是数据类型 动态语言：说的是运行是改变结构，说的是代码结构 静态类型语言：静态语言的数据类型是在编译期间（或运行之前）确定的，编写代码的时候要明确确定变量的数据类型 静态语言：与动态语言相对应的，运行时结构不可变的语言就是静态语言 大量的第三方包可以使用 语言层面支持并发 go hello（） 支持垃圾回收 语言简洁，关键字只有25个，支持继承、重载、对象 跨平台，引用plan9的代码，不依赖系统信息 Plan9是一个分布式操作系统，它能把网络上一切的资源当作文件来进行使用。Plan9中最本质的思想是“一切皆是文件” Go语言的优劣 Go语言适合做服务端程序，例如各种web程序，服务器软件，命令行工具 Go语言不适合开发有图形界面的应用程序，官方没有提供相关的图形库 不支持多态 多态：多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说：允许将子类类型的指针赋值给父类类型的指针（一个接口，多种方法）。C++ 支持两种多态性：编译时多态性，运行时多态性。a、编译时多态性（静态多态）：通过重载函数实现b、运行时多态性（动态多态）：通过虚函数实现。","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"}]},{"title":"Golang学习笔记（四）","date":"2018-06-18T16:00:00.000Z","path":"2018/06/19/Golang学习笔记（四）/","text":"GO指南1fmt.Println(\"My favorite number is\", rand.Intn(10)) 例子上的代码运行出的结果是不会变化的并不能算真正的随机 需要添加随机种子 1rand.Seed(time.Now().UnixNano()) 首字母大写为共用方法，可以被外部调用首字母小写只能在包内调用 初始化变量时可以省略类型，从初始值中获得类型 ‘:=’结构不能用在函数外 byte 是 uint8 的别名rune 是 int32 的别名 类型转换数值转换 123var i int = 11var f float64 = float64(i)var u uint = uint(f) int 转 string 12var i int = 11var s string= strconv.Itoa(i) int64 转 string 12var i int64 = 11var s string= strconv.FormatInt(i,10) uint64 转 string 12var i uint64=11var s string=strconv.FormatUint(i,10) string 转 int 123var s string = \"11\"var i inti, err := strconv.Atoi(s) string 转 int64 123var s string = \"11\"var i int64i, err := strconv.ParseInt(s, 10, 64) float64 转 string 12var f float64 = 11.1var s string = strconv.FormatFloat(f, 'f', -1, 64) string 转 float64 123var s string = \"11.1\"var f float64f, err := strconv.ParseFloat(s, 64) switch中fallthrough会直接执行下一个case或default语句（无论条件是否满足）fallthrough必须是case中的最后一句 defer调用的函数会以栈的形式存储，调用时遵照后进先出的原则 123456func main() &#123; for i := 0; i &lt; 10; i++ &#123; defer fmt.Println(i) &#125; fmt.Println(\"done\")&#125; 输出 123456789101112API server listening at: 127.0.0.1:47919done9876543210 slice添加元素func append(s []T, vs …T) []T 第一个参数为要添加元素的slice第二个参数为要添加的元素 原理 append首先检查是否到达最大容量cap 没有的话就直接在后面添加元素 如果超过cap向内存申请一个长度是原来两倍的新数组 将原来的值都复制过去 slice指向新的数组并释放掉原来的数组 闭包闭包就是一个函数引用函数以外的变量 斐波那契闭包 123456789101112131415func fibonacci() func() int &#123; a, b := 0, 1 return func() int &#123; temp := a a, b = b, (a + b) return temp &#125;&#125;func main() &#123; f := fibonacci() for i := 0; i &lt; 10; i++ &#123; fmt.Println(f()) &#125;&#125; goroutine线程go f() 开启新的线程 channel管道创建 1234ch := make(chan int)ch &lt;- v //向管道传值v &lt;- ch //接收管道的值 一般情况下，只有传值或只有接收都会造成线程阻塞 ch := make(chan int,10)//缓冲管道 当管道有缓冲时，当缓冲区满的时候向管道传值才会阻塞当缓冲区为空的时候接收管道值才会阻塞 select可以使多个通信在同一个线程上等待 switch的case不需要break结尾switch的case不需要break结尾switch的case不需要break结尾","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"}]},{"title":"Golang学习笔记（三）","date":"2018-06-09T16:00:00.000Z","path":"2018/06/10/Golang学习笔记（三）/","text":"golang 并行goroutines、信道和死锁（一）goroutines1234567891011func loop() &#123; for i := 0; i &lt; 10; i++ &#123; fmt.Printf(\"%d \", i) &#125;&#125;func main() &#123; go loop() loop()&#125; goroutine还没来得及跑loop的时候，主函数已经退出 这时需要一个类似join的东西来阻塞住主线。那就是信道 （二）信道信道是goroutine之间互相通讯的东西。类似我们Unix上的管道（可以在进程间传递消息）， 用来goroutine之间发消息和接收消息。其实，就是在做goroutine之间的内存共享。 使用make来建立一个信道: 1234567func main() &#123; var messages chan string = make(chan string) go func(message string) &#123; messages &lt;- message // 存消息 &#125;(\"Ping!\") fmt.Println(&lt;-messages) // 取消息&#125; 默认的，信道的存消息和取消息都是阻塞的 (叫做无缓冲的信道) 无缓冲的信道在取消息和存消息的时候都会挂起当前的goroutine，除非另一端已经准备好 123456789var ch chan int = make(chan int)func foo() &#123; ch &lt;- 0 // 向ch中加数据，如果没有其他goroutine来取走这个数据，那么挂起foo, 直到main函数把0这个数据拿走&#125;func main() &#123; go foo() &lt;- ch // 从ch取数据，如果ch中还没放数据，那就挂起main线，直到foo函数中放数据为止&#125; 如果不用信道来阻塞主线的话，主线就会过早跑完，loop线都没有机会执行 其实，无缓冲的信道永远不会存储数据，只负责数据的流通 从无缓冲信道取数据，必须要有数据流进来才可以，否则当前线阻塞 数据流入无缓冲信道, 如果没有其他goroutine来拿走这个数据，那么当前线阻塞 如果信道正有数据在流动，我们还要加入数据，或者信道干涩，我们一直向无数据流入的空信道取数据就会引起死锁 （三）死锁1234func main() &#123; ch := make(chan int) &lt;- ch // ??main goroutine, ??c??&#125; 只有一个goroutine, 所以当你向里面加数据或者存数据的话，都会锁死信道， 并且阻塞当前 goroutine, 也就是所有的goroutine(其实就main线一个)都在等待信道的开放(没人拿走数据信道是不会开放的)， 也就是死锁 几个死锁的例子1. 12345func main() &#123; ch := make(chan int) ch &lt;- 1 // 1流入信道，堵塞当前线, 没人取走数据信道不会打开 fmt.Println(\"This line code wont run\") //在此行执行之前Go就会报死锁&#125; 2. 123456789101112var ch1 chan int = make(chan int)var ch2 chan int = make(chan int)func say(s string) &#123; fmt.Println(s) ch1 &lt;- &lt;- ch2 // ch1 等待 ch2流出的数据&#125;func main() &#123; go say(\"hello\") &lt;- ch1 // 堵塞主线&#125; 3. 12345678c, quit := make(chan int), make(chan int)go func() &#123; c &lt;- 1 // c通道的数据没有被其他goroutine读取走，堵塞当前goroutine quit &lt;- 0 // quit始终没有办法写入数据&#125;()&lt;- quit // quit 等待数据的写 避免死锁的方法: 避免数据有存无取 或者有取无存 使用缓冲信道 缓冲信道在声明一个信道的时候，我们给make以第二个参数来指明它的容量(默认为0，即无缓冲): var ch chan int = make(chan int, 2) // 写入2个元素都不会阻塞当前goroutine, 存储个数达到2的时候会阻塞 缓冲信道是先进先出的，我们可以把缓冲信道看作为一个线程安全的队列： 12345678910func main() &#123; ch := make(chan int, 3) ch &lt;- 1 ch &lt;- 2 ch &lt;- 3 fmt.Println(&lt;-ch) // 1 fmt.Println(&lt;-ch) // 2 fmt.Println(&lt;-ch) // 3&#125; Go语言允许我们使用range来读取信道: 但是range可能会造成死锁，原因是range不等到信道关闭是不会结束读取的。也就是如果缓冲信道干涸了，那么range就会阻塞当前goroutine, 所以死锁 为了避免以上情况，有以下两种方式1. 12345678910ch := make(chan int, 3)ch &lt;- 1ch &lt;- 2ch &lt;- 3for v := range ch &#123; fmt.Println(v) if len(ch) &lt;= 0 &#123; // 如果现有数据量为0，跳出循环 break &#125;&#125; 2. 1234567891011ch := make(chan int, 3)ch &lt;- 1ch &lt;- 2ch &lt;- 3// 显式地关闭信道close(ch)for v := range ch &#123; fmt.Println(v)&#125; 并行并发与并行两个队列，一个Coffee机器，那是并发两个队列，两个Coffee机器，那是并行 为了达到真正的并行，我们需要告诉Go我们允许同时最多使用多个核，例如下面的方法 1. 123456789101112131415161718192021222324import ( \"fmt\" \"runtime\")var quit chan int = make(chan int)func loop() &#123; for i := 0; i &lt; 100; i++ &#123; fmt.Printf(\"%d \", i) &#125; quit &lt;- 0&#125;func main() &#123; runtime.GOMAXPROCS(2) // 最多使用2个核 go loop() go loop() for i := 0; i &lt; 2; i++ &#123; &lt;- quit &#125;&#125; 2. 1234567891011121314151617func loop() &#123; for i := 0; i &lt; 10; i++ &#123; runtime.Gosched() // 显式地让出CPU时间给其他goroutine fmt.Printf(\"%d \", i) &#125; quit &lt;- 0&#125;func main() &#123; go loop() go loop() for i := 0; i &lt; 2; i++ &#123; &lt;- quit &#125;&#125; 上面的两个例子都用到了runtime调节器 runtime调度器 Gosched 让出cpu NumCPU 返回当前系统的CPU核数量 GOMAXPROCS 设置最大的可同时使用的CPU核数 Goexit 退出当前goroutine(但是defer语句会照常执行)","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"}]},{"title":"Golang学习笔记（二）","date":"2018-06-08T16:00:00.000Z","path":"2018/06/09/Golang学习笔记（二）/","text":"golang 接口 反射 并发一、接口设计理念Go不是传统意义上的面向对象编程语言，它没有类及其继承的概念。接口是一种契约，实现类型必须满足它，它描述了类型的行为，规定类型可以做什么。接口彻底将类型能做什么，以及如何做分离开来，使得相同接口的变量在不同的时刻表现出不同的行为，这就是多态的本质 接口的特性是golang支持鸭子类型的基础，即“如果它走起来像鸭子，叫起来像鸭子（实现了接口要的方法），它就是一只鸭子（可以被赋值给接口的值）”。凭借接口机制和鸭子类型，golang提供了一种游离于类、继承、模板之外的更加灵活强大的选择。 注意的点 类型不需要显式地声明它实现了某个接口，接口被隐式地实现，多个类型可以实现同一个接口 一个类型可以实现多个接口 实现了某个接口的类型，可以有其它的方法（多对多） 接口方法中类型T和*T的区别(指针)指针是存储一个变量的内存地址的变量。 （不支持指针运算） 取地址符是 &amp;，放到一个变量前使用就会返回相应变量的内存地址解引用指针的意思是通过指针访问被指向的值。指针 a 的解引用表示为：*a。 不要传递指向数组的指针给函数，而是使用切片假设我们需要通过函数修改一个数组。一个办法是将数组的指针作为参数传递给函数。 123456789101112131415package mainimport ( \"fmt\")func modify(arr *[3]int) &#123; (*arr)[0] = 90&#125;func main() &#123; a := [3]int&#123;89, 90, 91&#125; modify(&amp;a) fmt.Println(a)&#125; 123456789101112131415package mainimport ( \"fmt\")func modify(arr *[3]int) &#123; arr[0] = 90 //a[x] 是 (*a)[x] 的简写，因此上面的程序中，(*arr)[0] 可以替换为 arr[0]。&#125;func main() &#123; a := [3]int&#123;89, 90, 91&#125; modify(&amp;a) fmt.Println(a)&#125; 123456789101112131415package mainimport ( \"fmt\")func modify(sls []int) &#123; sls[0] = 90&#125;func main() &#123; a := [3]int&#123;89, 90, 91&#125; modify(a[:]) //虽然可以通过传递数组指针给函数的方式来修改原始数组的值，但这在 Go 中不是惯用的方式，我们可以使用切片完成同样的事情。 fmt.Println(a)&#125; Go 语言规范定义了接口方法集的调用规则： 类型 T 的可调用方法集包含接受者为 T 或 T 的所有方法集类型 T 的可调用方法集包含接受者为 T 的所有方法类型 T 的可调用方法集不包含接受者为 *T 的方法 空接口什么方法都没定义的接口就是空接口。根据Golang的概念，空接口被任何类型隐式实现，所以空接口可以容纳任何类型。 二、反射反射是在golang程序运行时检查变量所具有类型的一种机制 在基本的层面上，反射只是一个检查存储在接口变量中的类型和值的算法。使用反射机制，首先需要导入reflect包，reflect包中有两个重要类型需要了解，reflect.Type和reflect.Value，这两个类型使得可以访问变量的内容。与此相关的，还有两个简单的函数，reflect.TypeOf和reflect.ValueOf，可以从接口值中分别获取reflect.Type和reflect.Value。 1234567891011121314import ( \"fmt\" \"reflect\")func main() &#123; var x float64 = 1.1 fmt.Println(\"reflect.Value:\", reflect.ValueOf(x)) fmt.Println(\"reflect.Type:\", reflect.TypeOf(x)) v := reflect.ValueOf(x) fmt.Println(\"reflect.Type:\",v.Type()) fmt.Println(\"actual value:\", v.Float()) fmt.Println(\"kind is float64?\", v.Kind() == reflect.Float64)&#125; golang采用静态类型机制，TypeOf返回静态类型 反射三法则 官方文档 http://blog.golang.org/laws-of-reflection 法则一：从接口值到反射对象的反射（Reflection goes from interface value toreflection object） 代表方法为reflect.ValueOf和reflect.TypeOffunc ValueOf(i interface{}) Valuefunc TypeOf(i interface{}) Type 法则二：从反射对象到接口值的反射（Reflection goes from reflection object to interface value） 从reflect.Value可以使用Interface方法还原接口值；可以高效地打包类型和值信息到接口表达中，并返回这个结果 方法声明： 1func (v Value) Interface() interface&#123;&#125; 通过反射对象 v 可以打印 float64 的表达值 12y :=v.Interface().(float64) // y 将为类型 float64。fmt.Println(y) 更为简洁的实现 1fmt.Println(v.Interface()) 法则三：为了修改反射对象，其值必须可设置（To modify a reflectionobject, the value must be settable） 反射对象可以通过SetFloat等方法设置值，通过CanSet判断可设置性。但是这里面有坑，有些值是不可设置的 1234567891011import ( \"fmt\" \"reflect\")func main() &#123; var x float64 = 1.1 v := reflect.ValueOf(x) fmt.Println(\"settability of v:\",v.CanSet()) v.SetFloat(1.2)//错误&#125; V := reflect.ValueOf(x)，这个函数是值传递，即传递了一个x的副本到函数中，而非x本身，值传递的参数是不能被真正修改的 借助Elem方法，通过指针来修改指针指向的具体值。 123func (v Value)Elem() Value//Elem returns the value that the interface v contains or that the pointer vpoints to. //It panics if v's Kind is not Interface or Ptr. It returns the zeroValue if v is nil. 12345678func main() &#123; var x float64 = 1.1 p := reflect.ValueOf(&amp;x) fmt.Println(\"type of p:\",p.Type()) v := p.Elem() fmt.Println(\"type of v:\",v.Type()) fmt.Println(\"settability of v:\",v.CanSet())&#125; 虽然p是不可修改的，但是v可以修改。这种方法思路上类似引用传参，传入地址，修改地址所指向的具体值","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"}]},{"title":"Golang学习笔记（一）","date":"2018-06-06T16:00:00.000Z","path":"2018/06/07/Golang学习笔记（一）/","text":"研究方向golang区块链以太坊源码以太坊智能合约代币合约共识机制 https://github.com/ethereum/go-ethereum 以太坊 https://github.com/abiosoft/ishell https://github.com/urfave/cli go tool pprof性能监控 分为两方面 1.net/http/pprof 做WEB服务器的性能监控检查服务器状态func main() { go func() { http.ListenAndServe(“localhost:6060”, nil) }() 2.runtime/pprof 做应用程序性能监控 CPU消耗分析func main() { f, err := os.OpenFile(“./tmp/cpu.prof”, os.O_RDWR|os.O_CREATE, 0644) if err != nil { log.Fatal(err) } defer f.Close() pprof.StartCPUProfile(f) defer pprof.StopCPUProfile() 导出prof文件使用 go tool pprof (应用程序) （应用程序的prof文件） 方式来对这个 prof 文件进行分析。 $ go tool pprof HuaRongDao ./tmp/cpu.profEntering interactive mode (type “help” for commands) 官方文档 https://blog.golang.org/profiling-go-programs net/http/pprof和runtime/pprof指的并不是分析WEB服务器性能监控和应用程序性能监控 这两个监控的是一个东西 内容都是一样的只不过是net/http/pprof把监控的内容以WEB的形式展示出来并不是说net/http/pprof是用来监控WEB服务器的性能的跟WEB服务器没有关系 net/http/pprof 只是把 runtime/pprof进行封装了一下实际上调用的还是 runtime/pprof","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"}]},{"title":"C#导出Excel的方法总结","date":"2017-04-11T16:00:00.000Z","path":"2017/04/12/C#导出Excel的方法总结/","text":"最近做了一个有关后台数据的导出功能 趁着这个机会把收集到的有关导出Excel的各种方法总结一下 Npoi导出Excel简介：NPOI 是 POI 项目的 .NET 版本POI是一个开源的Java读写Excel、WORD等微软OLE2组件文档的项目 主要优点：可以实现Excel的导入导出，而且不需要本机上装Office 需要的引用可以在VS的NuGet上直接下载，现在用的版本是2.3.0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758using System;using System.Collections.Generic;using System.Data;using System.IO;using System.Text;using System.Web;using NPOI.SS.UserModel;using NPOI.HSSF.UserModel;/* * / &lt;summary&gt; * / NpoiforExcel 的摘要说明 * / &lt;/summary&gt; */ public class NpoiforExcel &#123; public NpoiforExcel( DataTable dt, string fileName ) &#123; /* 生成Excel */ IWorkbook book = BuildWorkbook( dt ); /* web 下载 */ if ( fileName == &quot;&quot; ) fileName = string.Format( &quot;&#123;0:yyyyMMddHHmmssffff&#125;&quot;, DateTime.Now ); fileName = fileName.Trim(); string ext = Path.GetExtension( fileName ); if ( ext.ToLower() == &quot;.xls&quot; || ext.ToLower() == &quot;.xlsx&quot; ) fileName = fileName.Replace( ext, string.Empty ); HttpResponse httpResponse = HttpContext.Current.Response; httpResponse.Clear(); httpResponse.Buffer = true; httpResponse.Charset = Encoding.UTF8.BodyName; httpResponse.AppendHeader( &quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + fileName + &quot;.xls&quot; ); httpResponse.ContentEncoding = Encoding.UTF8; httpResponse.ContentType = &quot;application/vnd.ms-excel; charset=UTF-8&quot;; book.Write( httpResponse.OutputStream ); httpResponse.End(); &#125; public static HSSFWorkbook BuildWorkbook( DataTable dt ) &#123; HSSFWorkbook book = new HSSFWorkbook(); ISheet sheet = book.CreateSheet( &quot;Sheet1&quot; ); /* Data Rows */ for ( int i = 0; i &lt; dt.Rows.Count; i++ ) &#123; IRow drow = sheet.CreateRow( i ); for ( int j = 0; j &lt; dt.Columns.Count; j++ ) &#123; ICell cell = drow.CreateCell( j, CellType.String ); cell.SetCellValue( dt.Rows[i][j].ToString() ); &#125; &#125; /* 自动列宽 */ for ( int i = 0; i &lt;= dt.Columns.Count; i++ ) sheet.AutoSizeColumn( i, true ); return(book); &#125;&#125; Html导出Excel首先感谢果哥，这个方法从果哥偷学来的︿(￣︶￣)︿ 主要思路是将DataTable数据转换为html格式，然后直接设置为Excel的文件格式下载 下载下来的文件打开会有安全提示，可以忽略 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960using System;using System.Collections.Generic;using System.Web;/* * / &lt;summary&gt; * / htmltoExcel 的摘要说明 * / &lt;/summary&gt; */public class htmltoExcel&#123; public htmltoExcel() &#123; /* * * TODO: 在此处添加构造函数逻辑 * */ &#125; /* * / &lt;summary&gt; * / DataTable 输出成Excel * / &lt;/summary&gt; * / &lt;param name=&quot;dtData&quot;&gt;&lt;/param&gt; * / &lt;param name=&quot;FileName&quot;&gt;&lt;/param&gt; */ public htmltoExcel( System.Data.DataTable dtData, String FileName ) &#123; System.Web.UI.WebControls.GridView dgExport = null; /* 当前对话 */ System.Web.HttpContext curContext = System.Web.HttpContext.Current; /* IO导出并返回excel文件 */ System.IO.StringWriter strWriter = null; System.Web.UI.HtmlTextWriter htmlWriter = null; if ( dtData != null ) &#123; /* 设置编码和附件格式 */ System.Web.HttpUtility.UrlEncode( FileName, System.Text.Encoding.UTF8 ); curContext.Response.AddHeader( &quot;content-disposition&quot;, &quot;attachment;filename=&quot; + System.Web.HttpUtility.UrlEncode( FileName, System.Text.Encoding.UTF8 ) + &quot;.xls&quot; ); curContext.Response.ContentType = &quot;application nd.ms-excel&quot;; curContext.Response.ContentEncoding = System.Text.Encoding.GetEncoding( &quot;UTF-8&quot; ); curContext.Response.Charset = &quot;UTF-8&quot;; /* 导出Excel文件 */ strWriter = new System.IO.StringWriter(); htmlWriter = new System.Web.UI.HtmlTextWriter( strWriter ); /* 要重新定义一个无分页的GridView */ dgExport = new System.Web.UI.WebControls.GridView(); dgExport.DataSource = dtData.DefaultView; dgExport.AllowPaging = false; dgExport.DataBind(); /*下载到客户端 */ dgExport.RenderControl( htmlWriter ); curContext.Response.Write( &quot;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=Content-Type content=\\&quot;text/html; charset=utf-8\\&quot;&gt;&quot; ); curContext.Response.Write( strWriter.ToString() ); curContext.Response.Write( &quot;&lt;/body&gt;&lt;/html&gt;&quot; ); curContext.Response.End(); &#125; &#125;&#125; Xml导出Excel这个方法从大表哥那儿搞来的，表示感谢︿(￣︶￣)︿ 这个导出思路和上面的方法类似，先拼出XML格式，再设置为Excel格式导出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184using System;using System.Collections.Generic;using System.Data;using System.Text;using System.Web;public class ExportOrder&#123; private DataTable datasource; public ExportOrder( DataTable data, string title ) &#123; System.Web.HttpContext curContext = System.Web.HttpContext.Current; if ( data != null ) &#123; datasource = data; /* 设置编码和附件格式 */ System.Web.HttpUtility.UrlEncode( title, System.Text.Encoding.UTF8 ); curContext.Response.AddHeader( &quot;content-disposition&quot;, &quot;attachment;filename=&quot; + System.Web.HttpUtility.UrlEncode( title, System.Text.Encoding.UTF8 ) + &quot;.xls&quot; ); curContext.Response.ContentType = &quot;application nd.ms-excel&quot;; curContext.Response.ContentEncoding = System.Text.Encoding.GetEncoding( &quot;UTF-8&quot; ); curContext.Response.Charset = &quot;UTF-8&quot;; /*下载到客户端 */ curContext.Response.Write( GetExcelString().ToString() ); curContext.Response.End(); &#125; &#125; private StringBuilder GetExcelString() &#123; StringBuilder xmlString = new StringBuilder(); AddHeadFile( xmlString ); AddContentFile( xmlString, datasource ); AddEndFile( xmlString ); return(xmlString); &#125; /* * / &lt;summary&gt; * /写Excel头 * / &lt;/summary&gt; * / &lt;param name=&quot;OutFileContent&quot;&gt;&lt;/param&gt; * / &lt;returns&gt;&lt;/returns&gt; */ private StringBuilder AddHeadFile( StringBuilder OutFileContent ) &#123; OutFileContent.Append( &quot;&lt;?xml version=\\&quot;1.0\\&quot;?&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;?mso-application progid=\\&quot;Excel.Sheet\\&quot;?&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Workbook xmlns=\\&quot;urn:schemas-microsoft-com:office:spreadsheet\\&quot;\\r\\n&quot; ); OutFileContent.Append( &quot; xmlns:o=\\&quot;urn:schemas-microsoft-com:office:office\\&quot;\\r\\n&quot; ); OutFileContent.Append( &quot; xmlns:x=\\&quot;urn:schemas-microsoft-com:office:excel\\&quot;\\r\\n&quot; ); OutFileContent.Append( &quot; xmlns:ss=\\&quot;urn:schemas-microsoft-com:office:spreadsheet\\&quot;\\r\\n&quot; ); OutFileContent.Append( &quot; xmlns:html=\\&quot;http://www.w3.org/TR/REC-html40\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;DocumentProperties xmlns=\\&quot;urn:schemas-microsoft-com:office:office\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Author&gt;panss&lt;/Author&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;LastAuthor&gt;Оґ¶ЁТе&lt;/LastAuthor&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Created&gt;2004-12-31T03:40:31Z&lt;/Created&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Company&gt;Prcedu&lt;/Company&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Version&gt;12.00&lt;/Version&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;/DocumentProperties&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;OfficeDocumentSettings xmlns=\\&quot;urn:schemas-microsoft-com:office:office\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;DownloadComponents/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;LocationOfComponents HRef=\\&quot;file:///F:\\\\Tools\\\\OfficeXP\\\\OfficeXP\\\\\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;/OfficeDocumentSettings&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;ExcelWorkbook xmlns=\\&quot;urn:schemas-microsoft-com:office:excel\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;WindowHeight&gt;9000&lt;/WindowHeight&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;WindowWidth&gt;10620&lt;/WindowWidth&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;WindowTopX&gt;480&lt;/WindowTopX&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;WindowTopY&gt;45&lt;/WindowTopY&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;ProtectStructure&gt;False&lt;/ProtectStructure&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;ProtectWindows&gt;False&lt;/ProtectWindows&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;/ExcelWorkbook&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Styles&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Style ss:ID=\\&quot;Default\\&quot; ss:Name=\\&quot;Normal\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Alignment ss:Vertical=\\&quot;Center\\&quot; /&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Borders/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Font ss:FontName=\\&quot;ЛОМе\\&quot; x:CharSet=\\&quot;134\\&quot; ss:Size=\\&quot;12\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Interior/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;NumberFormat/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Protection/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;/Style&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Style ss:ID=\\&quot;s62\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Alignment ss:Vertical=\\&quot;Center\\&quot; ss:Horizontal=\\&quot;Center\\&quot; ss:WrapText=\\&quot;1\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Font ss:FontName=\\&quot;ЛОМе\\&quot; x:CharSet=\\&quot;134\\&quot; ss:Size=\\&quot;9\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;/Style&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Style ss:ID=\\&quot;s74\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Alignment ss:Horizontal=\\&quot;Center\\&quot; ss:Vertical=\\&quot;Center\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Borders&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Border ss:Position=\\&quot;Bottom\\&quot; ss:LineStyle=\\&quot;Continuous\\&quot; ss:Weight=\\&quot;1\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Border ss:Position=\\&quot;Left\\&quot; ss:LineStyle=\\&quot;Continuous\\&quot; ss:Weight=\\&quot;1\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Border ss:Position=\\&quot;Right\\&quot; ss:LineStyle=\\&quot;Continuous\\&quot; ss:Weight=\\&quot;1\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Border ss:Position=\\&quot;Top\\&quot; ss:LineStyle=\\&quot;Continuous\\&quot; ss:Weight=\\&quot;1\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;/Borders&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Font ss:FontName=\\&quot;ЛОМе\\&quot; x:CharSet=\\&quot;134\\&quot; ss:Size=\\&quot;12\\&quot; ss:Bold=\\&quot;1\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Interior ss:Color=\\&quot;#BFBFBF\\&quot; ss:Pattern=\\&quot;Solid\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;/Style&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;/Styles&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Worksheet ss:Name=\\&quot;Sheet1\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Table ss:ExpandedColumnCount=\\&quot;255\\&quot; x:FullColumns=\\&quot;1\\&quot; \\r\\n&quot; ); OutFileContent.Append( &quot;x:FullRows=\\&quot;1\\&quot; ss:StyleID=\\&quot;s62\\&quot; ss:DefaultColumnWidth=\\&quot;75\\&quot; ss:DefaultRowHeight=\\&quot;20.25\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Column ss:StyleID=\\&quot;s62\\&quot; ss:AutoFitWidth=\\&quot;0\\&quot; ss:Width=\\&quot;112.5\\&quot;/&gt;\\r\\n&quot; ); return(OutFileContent); &#125; /* * / &lt;summary&gt; * / &lt;summary&gt; * / 写表格尾部 * / &lt;/summary&gt; * / &lt;param name=&quot;OutFileContent&quot;&gt;&lt;/param&gt; * / &lt;returns&gt;&lt;/returns&gt; */ private StringBuilder AddEndFile( StringBuilder OutFileContent ) &#123; OutFileContent.Append( &quot;&lt;/Table&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;WorksheetOptions xmlns=\\&quot;urn:schemas-microsoft-com:office:excel\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Unsynced/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Print&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;ValidPrinterInfo/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;PaperSizeIndex&gt;9&lt;/PaperSizeIndex&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;HorizontalResolution&gt;600&lt;/HorizontalResolution&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;VerticalResolution&gt;0&lt;/VerticalResolution&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;/Print&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Selected/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Panes&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Pane&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Number&gt;3&lt;/Number&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;RangeSelection&gt;R1:R65536&lt;/RangeSelection&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;/Pane&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;/Panes&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;ProtectObjects&gt;False&lt;/ProtectObjects&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;ProtectScenarios&gt;False&lt;/ProtectScenarios&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;/WorksheetOptions&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;/Worksheet&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Worksheet ss:Name=\\&quot;Sheet2\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Table ss:ExpandedColumnCount=\\&quot;1\\&quot; ss:ExpandedRowCount=\\&quot;1\\&quot; x:FullColumns=\\&quot;1\\&quot;\\r\\n&quot; ); OutFileContent.Append( &quot;x:FullRows=\\&quot;1\\&quot; ss:DefaultColumnWidth=\\&quot;54\\&quot; ss:DefaultRowHeight=\\&quot;14.25\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Row ss:AutoFitHeight=\\&quot;0\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;/Table&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;WorksheetOptions xmlns=\\&quot;urn:schemas-microsoft-com:office:excel\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Unsynced/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;ProtectObjects&gt;False&lt;/ProtectObjects&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;ProtectScenarios&gt;False&lt;/ProtectScenarios&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;/WorksheetOptions&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;/Worksheet&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Worksheet ss:Name=\\&quot;Sheet3\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Table ss:ExpandedColumnCount=\\&quot;1\\&quot; ss:ExpandedRowCount=\\&quot;1\\&quot; x:FullColumns=\\&quot;1\\&quot;\\r\\n&quot; ); OutFileContent.Append( &quot;x:FullRows=\\&quot;1\\&quot; ss:DefaultColumnWidth=\\&quot;54\\&quot; ss:DefaultRowHeight=\\&quot;14.25\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Row ss:AutoFitHeight=\\&quot;0\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;/Table&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;WorksheetOptions xmlns=\\&quot;urn:schemas-microsoft-com:office:excel\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Unsynced/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;ProtectObjects&gt;False&lt;/ProtectObjects&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;ProtectScenarios&gt;False&lt;/ProtectScenarios&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;/WorksheetOptions&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;/Worksheet&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;/Workbook&gt;\\r\\n&quot; ); return(OutFileContent); &#125; private StringBuilder AddContentFile( StringBuilder OutFileContent, DataTable ds ) &#123; /* 写列头 */ OutFileContent.Append( &quot;&lt;Row ss:AutoFitHeight=\\&quot;0\\&quot;&gt;&quot; ); for ( int i = 0; i &lt; ds.Columns.Count; i++ ) &#123; OutFileContent.Append( &quot;&lt;Cell&gt;&lt;Data ss:Type=\\&quot;String\\&quot;&gt;&quot; + ds.Columns[i].ColumnName + &quot;&lt;/Data&gt;&lt;/Cell&gt;&quot; ); &#125; OutFileContent.Append( &quot;&lt;/Row&gt;&quot; ); /* 写内容 */ foreach ( DataRow row in ds.Rows ) &#123; OutFileContent.Append( &quot;&lt;Row ss:AutoFitHeight=\\&quot;0\\&quot;&gt;&quot; ); for ( int i = 0; i &lt; ds.Columns.Count; i++ ) &#123; OutFileContent.Append( &quot;&lt;Cell&gt;&lt;Data ss:Type=\\&quot;String\\&quot;&gt;&quot; + row[i].ToString() + &quot;&lt;/Data&gt;&lt;/Cell&gt;&quot; ); &#125; OutFileContent.Append( &quot;&lt;/Row&gt;&quot; ); &#125; return(OutFileContent); &#125;&#125; 另外还知道的两个方法openxml和EPPLUS","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://joker208.github.io/tags/设计模式/"}]},{"title":"设计模式初探之单例模式","date":"2017-03-16T06:02:01.000Z","path":"2017/03/16/设计模式初探之单例模式/","text":"单例模式 定义 保证一个类仅有一个实例，并提供一个访问它的全局访问点 目的 单例模式的目的就是要控制特定的类只产生一个对象，当然也允许在一定情况下灵活的改变对象的个数 特点 单例类只能有一个实例 单例类必须自己创建自己的唯一实例 单例类必须给所有其它对象提供这一实例 应用 每台计算机可以有若干个打印机，但只能有一个Printer Spooler，避免两个打印作业同时输出到打印机 一个具有自动编号主键的表可以有多个用户同时使用，但数据库中只能有一个地方分配下一个主键编号，否则会出现主键重复 下面的是C#中单例模式的三种写法 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Singleton1&#123; private static Singleton1 _instance = null; private Singleton1() &#123; &#125; public static Singleton1 CreateInstance() &#123; if ( _instance == null ) &#123; _instance = new Singleton1(); &#125; return(_instance); &#125;&#125;public class Singleton2&#123; private volatile static Singleton2 _instance = null; private static readonly object lockHelper = new object(); private Singleton2() &#123; &#125; public static Singleton2 CreateInstance() &#123; if ( _instance == null ) &#123; lock ( lockHelper ) &#123; if ( _instance == null ) _instance = new Singleton2(); &#125; &#125; return(_instance); &#125;&#125;sealed class Singleton3&#123; private Singleton3() &#123; &#125; public static readonly Singleton3 instance = new Singleton3();&#125; 其中第三种实现方法为C#中独有的 使得代码减少了许多，同时也解决了线程问题带来的性能上损失 它的工作原理又是什么呢？ Singleton类被声明为sealed，以此保证它自己不会被继承其次没有了Instance的方法，将原来_instance成员变量变成public readonly，并在声明时被初始化通过这些改变，我们确实得到了Singleton的模式，原因是在JIT的处理过程中如果类中的static属性被任何方法使用时，.NET Framework将对这个属性进行初始化于是在初始化Instance属性的同时Singleton类实例得以创建和装载而私有的构造函数和readonly(只读)保证了Singleton不会被再次实例化这正是Singleton设计模式的意图 不过这也带来了一些问题，比如无法继承，实例在程序一运行就被初始化，无法实现延迟初始化等 单利模式就先介绍到这里，以后还会继续补充，希望大家多提意见ヽ(￣ω￣(￣ω￣〃)ゝ 文章参考 《深入浅出设计模式》 从c#的singleton设计模式 c#设计模式-单例模式","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://joker208.github.io/tags/设计模式/"}]},{"title":".NET验证码","date":"2017-03-01T07:56:27.000Z","path":"2017/03/01/net验证码/","text":"网上的验证码总是不太好用 最近公司做的一个网站被用作短信轰炸 需要加上图片验证码 分享一下.NET验证码的Demo 也算做个备份，(๑•̀ㅂ•́)و✧ validatecode.aspx1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;%@ WebHandler Language=&quot;C#&quot; Class=&quot;validatecode&quot; %&gt;using System;using System.Web;using System.Drawing;public class validatecode : IHttpHandler, System.Web.SessionState.IRequiresSessionState&#123; public string charSet = &quot;0,1,2,3,4,5,6,8,9,A,B,C,D,E,F,G,H,J,K,M,N,P,R,S,U,W,X,Y&quot;; public void ProcessRequest(HttpContext context) &#123; string validateCode = CreateRandomCode(4); context.Session[&quot;ValidateCode&quot;] = validateCode; context.Response.SetCookie(new HttpCookie(&quot;ValidateCode&quot;, validateCode)); CreateImage(validateCode, context); &#125; public bool IsReusable &#123; get &#123; return false; &#125; &#125; /// &lt;summary&gt; /// 生成验证码 /// &lt;param name=&quot;n&quot;&gt;位数&lt;/param&gt; /// &lt;returns&gt;验证码字符串&lt;/returns&gt; private string CreateRandomCode(int n) &#123; string[] CharArray = charSet.Split(&apos;,&apos;); string randomCode = &quot;&quot;; int temp = -1; Random rand = new Random(); for (int i = 0; i &lt; n; i++) &#123; if (temp != -1) &#123; rand = new Random(i * temp * ((int)DateTime.Now.Ticks)); &#125; int t = rand.Next(CharArray.Length - 1); if (temp == t) &#123; return CreateRandomCode(n); &#125; temp = t; randomCode += CharArray[t]; &#125; return randomCode; &#125; private void CreateImage(string checkCode, HttpContext context) &#123; int iwidth = (int)(checkCode.Length * 13); System.Drawing.Bitmap image = new System.Drawing.Bitmap(iwidth, 23); Graphics g = Graphics.FromImage(image); Font f = new System.Drawing.Font(&quot;Arial&quot;, 12, (System.Drawing.FontStyle.Italic | System.Drawing.FontStyle.Bold)); // 前景色 Brush b = new System.Drawing.SolidBrush(Color.Black); // 背景色 g.Clear(Color.White); // 填充文字 g.DrawString(checkCode, f, b, 0, 1); // 随机线条 Pen linePen = new Pen(Color.Gray, 0); Random rand = new Random(); for (int i = 0; i &lt; 5; i++) &#123; int x1 = rand.Next(image.Width); int y1 = rand.Next(image.Height); int x2 = rand.Next(image.Width); int y2 = rand.Next(image.Height); g.DrawLine(linePen, x1, y1, x2, y2); &#125; // 随机点 for (int i = 0; i &lt; 30; i++) &#123; int x = rand.Next(image.Width); int y = rand.Next(image.Height); image.SetPixel(x, y, Color.Gray); &#125; // 边框 g.DrawRectangle(new Pen(Color.Gray), 0, 0, image.Width - 1, image.Height - 1); // 输出图片 System.IO.MemoryStream ms = new System.IO.MemoryStream(); image.Save(ms, System.Drawing.Imaging.ImageFormat.Jpeg); context.Response.ClearContent(); context.Response.ContentType = &quot;image/Jpeg&quot;; context.Response.BinaryWrite(ms.ToArray()); g.Dispose(); image.Dispose(); &#125;&#125; index.aspx123456789101112131415161718192021222324&lt;span&gt;验证码：&lt;/span&gt;&lt;input type=&quot;text&quot; id=&quot;input&quot; /&gt;&lt;a href=&quot;javascript:;&quot;&gt; &lt;img src=&quot;validatecode.ashx&quot; id=&quot;codeImg&quot; onclick=&quot;this.src=&apos;validatecode.ashx?time=&apos;+new Date().getTime()&quot;&gt;&lt;/a&gt;&lt;a class=&quot;submit&quot;&gt;提交&lt;/a&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(&quot;.submit&quot;).click(function()&#123; if ($(&quot;#input&quot;).val().toUpperCase().trim() != GetCookie(&quot;ValidateCode&quot;)) &#123; $(&quot;#codeImg&quot;).attr(&quot;src&quot;, &quot;validatecode.ashx?time=&quot; + new Date().getTime()); alert(&quot;验证码错误&quot;); return; &#125; else &#123; alert(&quot;验证码正确&quot;); return; &#125; &#125;) function GetCookie(sMainName) &#123; var re = new RegExp((sMainName + &quot;=([^;$]*)&quot;), &quot;i&quot;); return re.test(unescape(document.cookie)) ? RegExp[&quot;$1&quot;] : &quot;&quot;; &#125;&lt;/script&gt;","tags":[{"name":".NET","slug":"NET","permalink":"https://joker208.github.io/tags/NET/"},{"name":"验证码","slug":"验证码","permalink":"https://joker208.github.io/tags/验证码/"}]},{"title":"设计模式初探","date":"2017-02-21T10:03:54.000Z","path":"2017/02/21/设计模式初探/","text":"前言刚到公司时 我就向我们的主管果哥问过一个问题 从我这样的初级开发到您这样的开发大牛都需要学习些什么？ 是需要知道比如说clr这些底层的东西吗？ 果哥说，你先去看看设计模式吧 于是果断开始研究“设计模式” 先从基本的概念说起~ 模式“设计模式”的概念是从“模式”这个词引用过来的 “模式”一次最早应用于建筑学 Christopher Alexander，哈佛大学建筑学博士他和他的团队用20年的时间对住宅和周边环境进行研究发现人们对舒适住宅和城市环境存在一些共同的认同规律并把这些认同规律归纳为253个模式 模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案 设计模式GoF(Gang of Four)(Erich Gamma、Richard Helm、Ralph Johnson、John Vlissides)将模式的概念引入软件工程领域，标志着软件模式的诞生。 设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结使用设计模式是为了可重用代码、让代码共容易被他人理解并且保证代码可靠性","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://joker208.github.io/tags/设计模式/"}]},{"title":"设计模式初探之工厂模式","date":"2017-02-21T10:03:54.000Z","path":"2017/02/21/设计模式初探之工厂模式/","text":"设计模式是很抽象的东西 是各位编程届前辈不断实践总结，不断探索出来的 是规则 是经验 太抽象的东西往往不容易理解 那么就用简单的事例来把抽象的东西具体化 故事要从很久很久以前说起 (￣o￣) . z Z 话说有一个暴发户他家有三辆汽车——Benz 奔驰、 Bmw 宝马、 Audi 奥迪还雇了司机为他开车不过，暴发户坐车时总是怪怪的上 Benz 车后跟司机说“开奔驰车！”坐上 Bmw 后他说“开宝马车！ ”坐上 Audi 说“开奥迪车！ ”你一定说：这人有病！直接说开车不就行了？！而当把这个暴发户的行为放到我们程序设计中来时会发现这是一个普遍存在的现象 用代码表现出来就是这样色儿地 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* 抽象产品角色 */public interface Car &#123; void drive();&#125;/* 具体产品角色 */public class Benz : Car &#123; public void drive() &#123; Console.WriteLine( &quot;Driving Benz&quot; ); &#125;&#125;public class Bmw : Car &#123; public void drive() &#123; Console.WriteLine( &quot;Driving Bmw&quot; ); &#125;&#125;public class Audi : Car &#123; public void drive() &#123; Console.WriteLine( &quot;Driving Audi&quot; ); &#125;&#125;/* 工厂类角色 */public class Driver &#123; public static Car driverCar( String s ) &#123; if ( s == &quot;Benz&quot; ) return(new Benz() ); else if ( s == &quot;Bmw&quot; ) return(new Bmw() ); else if ( s == &quot;Audi&quot; ) return(new Audi() ); else throw new Exception(); &#125;&#125;class Program&#123; static void Main( string[] args ) &#123; try &#123; /* 告诉司机今天坐奔驰 */ Car car = Driver.driverCar( &quot;Benz&quot; ); /*下命令：开车 */ car.drive(); &#125; catch ( Exception e ) &#123; Console.WriteLine( e ); &#125; finally &#123; Console.ReadKey(); &#125; &#125;&#125; 工厂模式工厂模式主要是为创建对象提供过渡接口 以便将创建对象的具体过程屏蔽隔离起来 达到提高灵活性的目的 工厂模式可分为三种分别是 简单工厂模式 工厂方法模式 抽象工厂模式 简单工厂模式 定义 简单工厂模式又称静态工厂方法模式 定义一个用于创建对象的接口 组成 工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑 抽象产品角色：它一般是具体产品继承的父类或者实现的接口 具体产品角色：工厂类所创建的对象就是此角色的实例 缺陷分析 对产品部分来说，它是符合开闭原则的 但是工厂部分好像不太理想，因为每增加一辆车，都要在工厂类中增加相应的业务逻辑或者判断逻辑，这显然是违背开闭原则的 可想而知对于新产品的加入，工厂类是很被动的 工厂方法模式我们来继续讲故事 暴发户生意越做越大，自己的爱车也越来越多。这可苦了那位司机师傅了，什么车它都要记得，维护，都要经过他来使用 于是暴发户同情他说：看你跟我这么多年的份上，以后你不用这么辛苦了，我给你分配几个人手，你只管管好他们就行了！ 于是，工厂方法模式的管理出现了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* 抽象产品角色 */public interface Car&#123; void drive();&#125;/* 具体产品角色 */public class Benz : Car&#123; public void drive() &#123; Console.WriteLine( &quot;Driving Benz&quot; ); &#125;&#125;public class Bmw : Car&#123; public void drive() &#123; Console.WriteLine( &quot;Driving Bmw&quot; ); &#125;&#125;public class Audi : Car&#123; public void drive() &#123; Console.WriteLine( &quot;Driving Audi&quot; ); &#125;&#125;/* 抽象工厂角色 */public interface Driver &#123; Car driverCar();&#125;public class BenzDriver : Driver &#123; public Car driverCar() &#123; return(new Benz() ); &#125;&#125;public class BmwDriver : Driver &#123; public Car driverCar() &#123; return(new Bmw() ); &#125;&#125;public class AudiDriver : Driver &#123; public Car driverCar() &#123; return(new Audi() ); &#125;&#125;class Program&#123; static void Main( string[] args ) &#123; try &#123; Driver driver = new BenzDriver(); /* 告诉司机坐奔驰 */ Car car = driver.driverCar(); /*下命令 开车 */ car.drive(); &#125; catch ( Exception e ) &#123; Console.WriteLine( e ); &#125; finally &#123; Console.ReadKey(); &#125; &#125;&#125; 目的 工厂方法模式去掉了简单工厂模式中工厂方法的静态属性，使得它可以被子类继承 这样在简单工厂模式里集中在工厂方法上的压力可以由工厂方法模式里不同的工厂子类来分担 组成 抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关 具体工厂角色：它含有和具体业务逻辑有关的代码，由应用程序调用以创建对应的具体产品的对象 抽象产品角色：它是具体产品继承的父类或者是实现的接口 具体产品角色：具体工厂角色所创建的对象就是此角色的实例 适用范围 当客户程序不需要知道要使用对象的创建过程 客户程序使用的对象存在变动的可能，或者根本就不知道使用哪一个具体的对象 抽象工厂模式 目的 给客户端提供一个接口，可以创建多个产品族中的产品对象，而且使用抽象工厂模式还要满足一下条件： 1) 系统中有多个产品族，而系统一次只可能消费其中一族产品 2) 同属于同一个产品族的产品以其使用 组成 抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关 具体工厂角色：它含有和具体业务逻辑有关的代码，由应用程序调用以创建对应的具体产品的对象 抽象产品角色：它是具体产品继承的父类或者是实现的接口 具体产品角色：具体工厂角色所创建的对象就是此角色的实例 工厂模式区别简单工厂模式： 用来生产同一等级结构中的任意产品（对于增加新的产品，无能为力） 工厂方法模式：用来生产同一等级结构中的固定产品（支持增加任意产品） 抽象工厂模式 ：用来生产不同产品族的全部产品（对于增加新的产品，无能为力；支持增加产品族） 参考文章 《深入浅出设计模式》","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://joker208.github.io/tags/设计模式/"}]},{"title":"你见过最不求上进的人是什么样子？","date":"2017-02-20T14:51:02.000Z","path":"2017/02/20/你见过最不求上进的人是什么样子？/","text":"今天在知乎看到@布衣卿关于这个问题的回答 我想拿过来放在首页，时时惊醒 共勉我见过的最不求上进的人，既不是学霸又不全算学渣。 他们课听的迷迷糊糊，作业做一些抄一些。 想逃课又心存顾忌，行为也不公开对抗规范纪律。 为现状焦虑，又没有毅力践行决心去改变自己。 三分钟热度，时常憎恶自己的不争气，坚持最多的事情就是坚持不下去。 对感情抱有渴望，又疲于用心追寻与经营。 对曾经的珍视点到即止，直到渐渐松手，淡漠又疏离。 尚未拥有百毒不侵的内心，却提前丧失了热泪盈眶的能力。 偶尔闲暇时间想约人一起，更多时候无人可约就一个人且趴且趟窝上一天。 本想在有限的生命里体验很多种生活，却只会把同样的日子机械重复很多年。 刷着知乎想窥见别人的生活寻求激励，关闭客户端还是该干嘛干嘛去。 终日混迹社交网络，脸色蜡黄地对着手机和电脑的冷光屏，可以说上几句话的人却寥寥无几。 不曾经历过真正沧桑，却还失守了最后一点少年意气。 他们以最普通的身份埋没在人群中，却过着最最煎熬的日子。 文章来源： 你见过最不求上进的人是什么样子？ - 回答作者: 布衣卿","tags":[{"name":"鸡汤","slug":"鸡汤","permalink":"https://joker208.github.io/tags/鸡汤/"}]},{"title":"Hashtable实用案例","date":"2017-02-16T08:46:33.000Z","path":"2017/02/16/Hashtable实用案例/","text":"今天在翻看以前的项目的时候发现了项目中对Hashtable的使用 借这个机会巩固一下Hashtable的知识 Hashtable是非泛型的集合，所以在检索和存储值类型时通常会发生装箱与拆箱的操作 当把某个元素添加到 Hashtable 时，将根据键的哈希代码将该元素放入存储桶中，由于是散列算法所以会出现一个哈希函数能够为两个不同的键生成相同的哈希代码，该键的后续查找将使用键的哈希代码只在一个特定存储桶中搜索，这将大大减少为查找一个元素所需的键比较的次数 Hashtable 的加载因子确定元素与Hashtable 可拥有的元素数的最大比率。加载因子越小，平均查找速度越快，但消耗的内存也增加。默认的加载因子 0.72通常提供速度和大小之间的最佳平衡。当创建 Hashtable 时，也可以指定其他加载因子 元素总量/ Hashtable 可拥有的元素数=加载因子 当向 Hashtable 添加元素时，Hashtable 的实际加载因子将增加。当实际加载因子达到指定的加载因子时，Hashtable 中存储桶的数目自动增加到大于当前 Hashtable 存储桶数两倍的最小素数 虽然Hash具有O(1)的数据检索效率，但它空间开销却通常很大，是以空间换取时间。所以Hashtable适用于读取操作频繁，写入操作很少的操作类型 主要记录一下使用的场景以及方法，为以后作参照 根据其查找效率高的特点用作比较去重 1234567891011121314DataSet ds = app.Ds;Hashtable htData = new Hashtable();foreach (DataRow row in ds.Tables[0].Rows)&#123; string title = row[&quot;Title&quot;].ToString(); if (htData.Contains(title)) &#123; row.Delete(); &#125; else &#123; htData.Add(title, &quot;&quot;); &#125;&#125; 文章参考 Hashtable_百度百科 hashtable详细介绍 C#中HashTable的用法","tags":[{"name":"Hashtable","slug":"Hashtable","permalink":"https://joker208.github.io/tags/Hashtable/"}]},{"title":"jQuery实现简单分页","date":"2017-02-16T07:17:54.000Z","path":"2017/02/16/jQuery实现简单分页/","text":"今天做的一个首页下方的列表需要加一个分页功能 不需要特别多功能，只要有页数就行，网上的分页插件功能太多反倒累赘 于是就自己写了一个简单的分页控件 随便练习一下jQuery 贴代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&lt;li&gt;4&lt;/li&gt;&lt;li&gt;5&lt;/li&gt;&lt;li&gt;6&lt;/li&gt;&lt;li&gt;7&lt;/li&gt;&lt;li&gt;8&lt;/li&gt;&lt;li&gt;9&lt;/li&gt;&lt;li&gt;10&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;fanye&quot;&gt;&lt;a class=&quot;up&quot; href=&quot;#&quot;&gt;upup&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a class=&quot;down&quot; href=&quot;#&quot;&gt;downdown&lt;/a&gt;&lt;/div&gt;&lt;script src=&quot;http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&quot;ul li&quot;).hide(); $(&quot;ul li:lt(4)&quot;).show(); var nowPage=1;//当前页 var countRecord=$(&quot;ul li&quot;).length;//总记录数 if(countRecord&lt;5) &#123; $(&quot;.fanye a&quot;).hide(); &#125; var countPage=Math.ceil(countRecord/4); if(nowPage==1)&#123;$(&quot;.up&quot;).attr(&quot;style&quot;,&quot;visibility:hidden;&quot;);&#125; $(&quot;.fanye a&quot;).click(function()&#123; var classValue=$(this).attr(&quot;class&quot;); if(&quot;up&quot;==classValue)&#123; if(nowPage&gt;1)&#123; nowPage--; &#125; &#125;else if(&quot;down&quot;==classValue)&#123; if(nowPage&lt;countPage)&#123; nowPage++; &#125; &#125; if(nowPage==1)&#123;$(&quot;.up&quot;).attr(&quot;style&quot;,&quot;visibility:hidden;&quot;);&#125;else&#123;$(&quot;.up&quot;).attr(&quot;style&quot;,&quot;visibility:visible;&quot;);&#125; if(nowPage==countPage)&#123;$(&quot;.down&quot;).attr(&quot;style&quot;,&quot;visibility:hidden;&quot;);&#125;else&#123;$(&quot;.down&quot;).attr(&quot;style&quot;,&quot;visibility:visible;&quot;);&#125; startIndex=(nowPage-1)*4+1;//获取每页开始记录数 endIndex=nowPage*4;//获取每页结束记录数 $(&quot;ul li:gt(&quot;+(startIndex-1)+&quot;)&quot;).show(); $(&quot;ul li:lt(&quot;+(endIndex-1)+&quot;)&quot;).show(); //隐藏操作 //设置隐藏超出页数之外的数据 $(&quot;ul li:lt(&quot;+(startIndex-1)+&quot;)&quot;).css(&quot;display&quot;,&quot;none&quot;); $(&quot;ul li:gt(&quot;+(endIndex-1)+&quot;)&quot;).css(&quot;display&quot;,&quot;none&quot;); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"前端","slug":"前端","permalink":"https://joker208.github.io/tags/前端/"},{"name":"jQuery","slug":"jQuery","permalink":"https://joker208.github.io/tags/jQuery/"},{"name":"分页","slug":"分页","permalink":"https://joker208.github.io/tags/分页/"}]},{"title":".NET发送邮件","date":"2017-02-15T09:36:00.000Z","path":"2017/02/15/dot NET发送邮件/","text":"分享一个.NET后台发送邮件的方法 Demo如下 这个Demo的使用情景是 网站用户修改密码时的绑定邮箱验证 123456789101112131415161718192021222324252627/// &lt;summary&gt;/// 发送邮件/// &lt;/summary&gt;/// &lt;param name=&quot;Email&quot;&gt;用户邮箱地址&lt;/param&gt;/// &lt;param name=&quot;RanDom&quot;&gt;随机验证码&lt;/param&gt;/// &lt;param name=&quot;Name&quot;&gt;用户名&lt;/param&gt;public static void SendEmail(string Email, string RanDom, string Name)&#123; MailMessage mail = new MailMessage(); mail.To.Add(new MailAddress(Email)); mail.Subject = &quot;邮件标题&quot;; mail.SubjectEncoding = System.Text.Encoding.UTF8; mail.Body = &quot;尊敬的用户:&quot; + Name + &quot;。修改密码给你发的验证码是：&quot; + RanDom + &quot;.该验证码有效时间为30分钟，请注意自己的帐号安全，不要外泄密码！！&quot;; mail.BodyEncoding = System.Text.Encoding.UTF8; mail.IsBodyHtml = true; mail.Priority = MailPriority.High; SmtpClient smtpclient = new SmtpClient(); smtpclient.UseDefaultCredentials = true; string EmailClass = Email.Substring(Email.LastIndexOf(&apos;@&apos;)); smtpclient.Host = &quot;smtp&quot; + EmailClass; mail.From = new MailAddress(&quot;发送邮件的邮箱地址&quot;); smtpclient.Credentials = new System.Net.NetworkCredential(&quot;发送邮件的邮箱地址&quot;, &quot;密码&quot;); smtpclient.Send(mail);&#125;","tags":[{"name":".NET","slug":"NET","permalink":"https://joker208.github.io/tags/NET/"},{"name":"邮件","slug":"邮件","permalink":"https://joker208.github.io/tags/邮件/"}]},{"title":"CarouFredSel插件实现图片轮播","date":"2017-02-15T08:17:48.000Z","path":"2017/02/15/CarouFredSel插件实现鼠标移入停止/","text":"公司做北大的一个网站 里面有一个轮播效果 使用了CarouFredSel插件来实现 借这个机会好好来研究一下这个插件 先附上Demo 1234567891011121314151617&lt;ul id=&quot;time_ul&quot;&gt; &lt;li class=&quot;time_li&quot; style=&quot;height:398px;width:400px;&quot;&gt; &lt;div class=&quot;zhanlan_a&quot;&gt; &lt;img class=&quot;zh_pic&quot; src=&quot;../upload/images/&lt;%=pic %&gt;&quot;&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;time_li&quot; style=&quot;height:398px;width:400px;&quot;&gt; &lt;div class=&quot;zhanlan_a&quot;&gt; &lt;img class=&quot;zh_pic&quot; src=&quot;../upload/images/&lt;%=pic %&gt;&quot;&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;time_li&quot; style=&quot;height:398px;width:400px;&quot;&gt; &lt;div class=&quot;zhanlan_a&quot;&gt; &lt;img class=&quot;zh_pic&quot; src=&quot;../upload/images/&lt;%=pic %&gt;&quot;&gt; &lt;/div&gt; &lt;/li&gt;&lt;/ul&gt; 1234567891011121314151617&lt;script type=&quot;text/javascript&quot;&gt;$(&apos;#time_ul&apos;).carouFredSel(&#123; auto:true, direction: &apos;up&apos;, items: &#123; visible: 1, height: 398 &#125;, scroll: &#123; items:1, duration: 2000, timeoutDuration: 2500, pauseOnHover: true &#125;, pagination: &apos;#paginations&apos; &#125;);&lt;/script&gt; CarouFredSel的一些重要参数说明circular true 循环模式，true为无限循环，false为单轮循环。 infinite true 是否启用循环，默认起用。当circular设置为false的时候，再把infinite设置为false，就可以关闭循环 direction “left” 滚动方向，可选值：”right”, “left”, “up” , “down” width null 内容的宽度，如果为null，宽度自动计算 height null 内容的高度，如果为null，高度自动计算 padding 0 内容区域的padding items 5 显示个数。默认显示5个 scroll 默认等于显示的个数 一次滚动个数 auto true 是否自动播放。设置成false，不自动播放 prev null 指定某一元素控制内容向前 next null 指定某一元素控制内容向后 (“▔□▔)/(“▔□▔)/(“▔□▔)/ 另外，还学了一招–去除轮播效果 $(&apos;#time_ul&apos;).trigger(&apos;destroy&apos;);","tags":[{"name":"前端","slug":"前端","permalink":"https://joker208.github.io/tags/前端/"},{"name":"CarouFredSel","slug":"CarouFredSel","permalink":"https://joker208.github.io/tags/CarouFredSel/"}]},{"title":"图片外加a标签导致图片无法显示完整","date":"2017-02-15T07:19:05.000Z","path":"2017/02/15/前端小技巧/","text":"在公司主要做网站后端开发 不可避免的会用到前端的东西 正巧公司制作里有位大腿 没事多抱抱（@￣︶￣@） 最近就遇到问题了 问题描述： 当给图片添加链接的时候，我会用一个a标签来包裹img标签 但是这样会导致图片无法完全显示 &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;&quot;&gt;&lt;/a&gt; 解决方法： 123&lt;a style=&quot;display:block;width:100%;height:100%;&quot; href=&quot;#&quot;&gt;&lt;img src=&quot;&quot;&gt;&lt;/a&gt; 开发这一行注重经验，多积累，多整理，争取早日变成大腿","tags":[{"name":"前端","slug":"前端","permalink":"https://joker208.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"https://joker208.github.io/tags/css/"}]},{"title":"Python学习笔记（一）","date":"2016-12-16T07:08:21.000Z","path":"2016/12/16/Python学习笔记（一）/","text":"数据结构 list tuple dict set list 定义 用中括号定义 可以是空的 可以存在不同数据类型 访问 index索引值（注意不要越界） 索引值可为负数（倒数） 添加元素 append()添加到尾部 insert(value,index)添加到指定位置 删除元素 pop()删除尾部元素 pop(index) 可以替换元素 L[index]=value Tuple 定义 用小括号定义 可以是空 可以存在不同数据类型 不能重新赋值替换 创建单元素时要注意t=(1,)防止小括号单值歧义 tuple的不可变指的是指针指向位置的不可变，当包含list时，list中的元素可以改变 Dict 定义 用花括号定义 格式为Key-Value键值对，类似于HashMap 添加 可以直接通过键值对方式添加dict中的元素 访问 Key键(不可重复)访问( 字符串、整型、浮点型和元组tuple都可以作为dict的key ) 判断是否存在用 in 特点 1.查找速度快，以空间换时间 2.无序 合并 1234567891011121314&gt;&gt;&gt; d1 = &#123;&apos;mike&apos;:12, &apos;jack&apos;:19&#125;&gt;&gt;&gt; d2 = &#123;&apos;jone&apos;:22, &apos;ivy&apos;:17&#125;&gt;&gt;&gt; dMerge = dict(d1.items() + d2.items())&gt;&gt;&gt; print dMerge&#123;&apos;mike&apos;: 12, &apos;jack&apos;: 19, &apos;jone&apos;: 22, &apos;ivy&apos;: 17&#125;&gt;&gt;&gt; dMerge2 = dict(d1, **d2)&gt;&gt;&gt; print dMerge2&#123;&apos;mike&apos;: 12, &apos;jack&apos;: 19, &apos;jone&apos;: 22, &apos;ivy&apos;: 17&#125;&gt;&gt;&gt; dMerge3 = dict(d1)&gt;&gt;&gt; dMerge3.update(d2)&gt;&gt;&gt; print dMerge&#123;&apos;mike&apos;: 12, &apos;jack&apos;: 19, &apos;jone&apos;: 22, &apos;ivy&apos;: 17&#125; set 定义 set([]) 没有value值的dict 元素无序且不可重复 访问 只能查看某个元素是否在这个集合里面(in) 大小写敏感 操作 add() remove() 多用于判断一个元素是否在一些不同的条件内符合","tags":[{"name":"Python","slug":"Python","permalink":"https://joker208.github.io/tags/Python/"}]},{"title":"js天气插件","date":"2016-10-28T08:50:35.000Z","path":"2016/10/28/js天气插件/","text":"曾子曰：“吾日三省吾身——为人谋而不忠乎？与朋友交而不信乎？传不习乎？” 自从博客创建起来以后就没有再更新过 想来也是十分惭愧 工作这么长时间积攒了不少值得记录的东西 心里也一直想着要坚持更新才行 看来还是是懒 选择来到大城市就是为了能一直鞭策自己不断进步 但是一稳定下来就不想努力了 以后还是要日省吾身，保持一颗拼搏的心。 进入正题 前段时间一个网站项目里要加入天气插件 由于是定制化的页面 网上现有的插件都没法直接用 于是找了一个ajax直接获取天气数据的方法 前端代码 12&lt;div id=&quot;location&quot;&gt;&lt;/div&gt;&lt;div id=&quot;weather&quot;&gt;&lt;/div&gt; js代码 12345678910111213141516var cityUrl = &apos;http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=js&apos;;//获取ip所在地区$.getScript(cityUrl, function (script, textStatus, jqXHR) &#123;var citytq = remote_ip_info.city;// 获取城市var url = &quot;http://php.weather.sina.com.cn/iframe/index/w_cl.php?code=js&amp;city=&quot; + citytq + &quot;&amp;day=0&amp;dfc=3&quot;;//sina提供的天气接口$.ajax(&#123; url: url, dataType: &quot;script&quot;, scriptCharset: &quot;gbk&quot;, success: function (data) &#123; var _w = window.SWther.w[citytq][0]; var tq = _w.s1 + &quot; &quot; + _w.t1 + &quot;℃～&quot; + _w.t2 + &quot;℃ &quot;; $(&apos;#location&apos;).html(citytq + &apos;地区：&apos;); $(&apos;#weather&apos;).html(tq); &#125; &#125;); &#125;); 说明 在上段代码中的url里，将变量citytq赋值为北京：var url = &quot;http://php.weather.sina.com.cn/iframe/index/w_cl.php?code=js&amp;city=北京&amp;day=0&amp;dfc=3&quot;; 可获得如下数据：(function(){var w=[];w[&#39;北京&#39;]=[{s1:&#39;晴&#39;,s2:&#39;晴&#39;,f1:&#39;qing&#39;,f2:&#39;qing&#39;,t1:&#39;13&#39;,t2:&#39;2&#39;,p1:&#39;3-4&#39;,p2:&#39;≤3&#39;,d1:&#39;北风&#39;,d2:&#39;无持续风向&#39;}];var add={now:&#39;2016-10-28 20:21:07&#39;,time:&#39;1477657267&#39;,update:&#39;北京时间10月28日07:58更新&#39;,error:&#39;0&#39;,total:&#39;1&#39;};window.SWther={w:w,add:add};})();//0","tags":[{"name":"js","slug":"js","permalink":"https://joker208.github.io/tags/js/"},{"name":"天气插件","slug":"天气插件","permalink":"https://joker208.github.io/tags/天气插件/"}]},{"title":"绝命毒师影评","date":"2016-08-15T06:25:08.000Z","path":"2016/08/15/绝命毒师影评/","text":"今天终于把绝命毒师看完了 从第一季到第五季整个影片基调压抑的让人透不过气 作为一个中年化学教师 老白 兢兢业业，唯唯诺诺，一事无成，身患绝症 为了家人，为了儿子，走上制毒之路，险象环生 却被周围人唾弃 他一直在备受煎熬 当影片最后，当baby blue歌声响起 当老白倒下，顿时有一种解脱的轻松 甚至不由自主的热泪盈眶 碌碌无为五十年 在生命的最后时间 能够发现自己最热爱的东西 能够成就一番事业 并且依然深爱着自己的家人 最终死在自己心爱的实验室里 就像老白说的那样”I was alive” 值了","tags":[{"name":"影评","slug":"影评","permalink":"https://joker208.github.io/tags/影评/"}]},{"title":"网页一键分享功能","date":"2016-08-02T07:44:17.000Z","path":"2016/08/02/网页一键分享功能/","text":"公司用的一般都是现成的分享插件 推荐给大家JiaThis 现有插件的缺点很明显，样式已经固定，不能满足定制化网站的需求 下面用js来实现网页的一键分享功能 123&lt;a href=&quot;javascript:void(0)&quot; onClick=&quot;Share.sinaWeiBo(&apos;测试测试测试分享到微博,地址&apos;,&apos;http://www.baidu.com&apos;,&apos;http://09.imgmini.eastday.com/mobile/20160712/20160712191443_b7a55523e3bfc750a28992a67b664332_1.jpeg&apos;);&quot; title=&quot;分享到新浪微博&quot;&gt;一键转发新浪微博&lt;/a&gt;&lt;a href=&quot;javascript:void(0)&quot; onClick=&quot;Share.qqWeiBo(&apos;测试测试测试分享到腾讯微博&apos;,&apos;http://www.baidu.com&apos;,&apos;http://www.yn.xinhuanet.com/ent/2006-11/10/xin_351103101047078339115.jpg&apos;);&quot; class=&quot;tmblog q&quot; title=&quot;分享到腾讯微博&quot;&gt;一键转发腾讯微博&lt;/a&gt;&lt;a href=&quot;javascript:void(0)&quot; onClick=&quot;Share.qqZone(&apos;测试测试测试分享到QQ空间,地址&apos;,&apos;http://www.baidu.com&apos;,&apos;http://www.yn.xinhuanet.com/ent/2006-11/10/xin_351103101047078339115.jpg&apos;);&quot; class=&quot;tmblog q&quot; title=&quot;分享到腾讯微博&quot;&gt;一键转发QQ空间&lt;/a&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;script type=&quot;text/javascript&quot;&gt; /**分享到新浪微博，腾讯微博，QQ空间，微信朋友圈 */var Share =&#123; //新浪微博 sinaWeiBo:function(title,url,pic)&#123; var _w = 72 , _h = 16; var param = &#123; url:url, type:&apos;3&apos;, count:&apos;1&apos;, /**是否显示分享数，1显示(可选)*/ appkey:&apos;&apos;, /**您申请的应用appkey,显示分享来源(可选)*/ title:title, /**分享的文字内容(可选，默认为所在页面的title)*/ pic:pic, /**分享图片的路径(可选)*/ ralateUid:&apos;&apos;, /**关联用户的UID，分享微博会@该用户(可选)*/ rnd:new Date().valueOf() &#125; var temp = []; for( var p in param )&#123; temp.push(p + &apos;=&apos; + encodeURIComponent( param[p] || &apos;&apos; ) ) &#125; var target_url = &quot;http://service.weibo.com/share/share.php?&quot;+temp.join(&apos;&amp;&apos;); window.open(target_url,&apos;sinaweibo&apos;,&apos;height=430, width=400&apos;); &#125;, //qq微博 qqWeiBo:function(title,url,pic)&#123; var _t = encodeURI(title); var _url = encodeURIComponent(url); var _appkey = encodeURI(&apos;appkey&apos;);//你从腾讯获得的appkey var _pic = encodeURI(pic);//（例如：var _pic=&apos;图片url1|图片url2|图片url3....） var _site = &apos;http://rt.xoyo.com&apos;;//你的网站地址 var _u = &apos;http://v.t.qq.com/share/share.php?url=&apos;+_url+&apos;&amp;appkey=&apos;+_appkey+&apos;&amp;site=&apos;+_site+&apos;&amp;pic=&apos;+_pic+&apos;&amp;title=&apos;+_t; window.open( _u,&apos;&apos;, &apos;width=700, height=680, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, location=yes, resizable=no, status=no&apos; ); &#125;, //qq空间 qqZone:function(title,url,pic)&#123; var p = &#123; url:url, showcount:&apos;0&apos;,/*是否显示分享总数,显示：&apos;1&apos;，不显示：&apos;0&apos; */ desc:&apos;&apos;,/*默认分享理由(可选)*/ summary:&apos;&apos;,/*分享摘要(可选)*/ title:title,/*分享标题(可选)*/ site:&apos;&apos;,/*分享来源 如：腾讯网(可选)*/ pics:pic, /*分享图片的路径(可选)*/ style:&apos;203&apos;, width:22, height:22 &#125;; var s = []; for(var i in p)&#123; s.push(i + &apos;=&apos; + encodeURIComponent(p[i]||&apos;&apos;)); &#125; var shareURL = &apos;http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?&apos;+s.join(&apos;&amp;&apos;); window.open(shareURL,&apos;newwindow&apos;,&apos;height=400,width=400,top=100,left=100&apos;); &#125;,&#125;;&lt;/script&gt; 另微信没有专门的分享接口 一般的解决方案是把要分享的页面做成二维码 通过微信扫一扫打开 在微信右上角有分享的功能","tags":[{"name":"js","slug":"js","permalink":"https://joker208.github.io/tags/js/"},{"name":"一键分享","slug":"一键分享","permalink":"https://joker208.github.io/tags/一键分享/"}]},{"title":"hexo常用命令","date":"2016-06-10T09:07:55.000Z","path":"2016/06/10/hexo常用命令/","text":"安装bashnpm install hexo -g #安装npm update hexo -g #升级hexo init #初始化 简写hexo n “我的博客” == hexo new “我的博客” #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate –watch #监视文件变动 完成后部署两个命令的作用是相同的hexo generate –deployhexo deploy –generate hexo deploy -ghexo server -g 草稿hexo publish [layout] 模版hexo new “postName” #新建文章hexo new page “pageName” #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHub hexo new [layout] hexo new photo “My Gallery”hexo new “Hello World” –lang tw 模版（Scaffold）hexo new photo “My Gallery” 设置文章摘要以上是文章摘要 以下是余下全文 写作hexo new page hexo new post 推送到服务器上hexo n #写文章hexo g #生成hexo d #部署 #可与hexo g合并为 hexo d -g 安装RSS插件npm install hexo-generator-feed –save 开启RSS功能编辑hexo/_config.yml，添加如下代码： rss: /atom.xml #rss地址 默认即可","tags":[{"name":"hexo","slug":"hexo","permalink":"https://joker208.github.io/tags/hexo/"}]},{"title":"HEXO+githubpage搭建博客","date":"2016-06-07T06:26:54.000Z","path":"2016/06/07/HEXO-githubpage搭建博客/","text":"一、前言一千个人眼中有一千个哈姆雷特虽然网上已经不乏相关的教程，我还是把我的搭建步骤和大家分享，我的电脑是windows系统，有问题的话可以留言，我们一起来讨论哈~ 二、准备工作搭建博客首先要了解一下几个基本概念（其实我也没有看完） Git GitHub Pages Hexo Markdown 然后需要下载几个安装包，有些安装包需要翻墙不好下载，直接用我的百度云分享 Node.js（node-v6.9.5-x64.msi） Git（Git-2.11.1-64-bit.exe） 最后，记得在Github上注册个帐号ok，准备工作就做好了 三、搭建博客第一步，把上面提到的两个安装包先给安装了 第二步，将你的Github帐号与你的电脑绑定 先检查你的电脑里有没有SSH keys在电脑的桌面上点鼠标右键，选择Git Bash Here，就会出来黑框框，键入下面代码1$ ls -al ~/.ssh 默认情况下，public keys的文件名是以下的格式之一：id_dsa.pub、id_ecdsa.pub、id_ed25519.pub、id_rsa.pub如果没有SSH key，则生成新的SSH key1$ ssh-keygen -t rsa -C \"your_email@example.com\" 这里的邮箱是你申请Github帐号时的邮箱成功后会在C:\\Users\\用户名\\ .ssh路径下生成两个文件id_rsa 以及id_rsa.pub之后在github添加SSH Key,在任意界面右上角，点击你的头像，选择Settings-&gt; SSH keys-&gt;New SSH key将id_rsa.pub里面的内容全部复制到Key框里面 ok，绑定成功~ 第三步，搭建本地博客在本地新建一个文件夹，比如Blog，文件右键，选择Git Bash Here输入指令安装hexo1$ npm install -g hexo 稍等片刻。。。安装完成后，输入以下指令1$ hexo init 该命令会在目标文件夹内建立网站所需要的所有文件接下来是安装依赖包1$ npm install 部署形成文件1$ hexo generate 再接下来运行server 跑起hexo服务1$ hexo server 这样博客在本地已经搭建好了，我们可以打开浏览器，输入http://localhost:4000/便可看到默认的博客了 鼓掌（/≧▽≦/），等等，其实还有第四步 第四步，博客上线 登录Github，点击”New repository”，新建一个版本库输入仓库名：你的Github名称.github.io然后点击Create repository这里的Repository name一定要用的github的用户名，不然显示不出来，因为githubPage只能你的用户名接下来，点击右边的“Setting”菜单进入设置,点击”Launch automatic page generator”进入之后点击底部的”Continue to layouts”之后选择一个随意模版，点击”Publish page”,发布github默认生成的一个静态站点ok，线上的工作完成，接下来修改一下本地文件 打开本地博客根目录下的配置文件_config.yml编辑最后面的deploy属性，加入代码123type: gitrepository: git@github.com:username/username.github.io.gitbranch: master 这里列举配置文件_config.yml的部分关键配置，可自行修改123456789101112131415161718192021222324252627# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: #网站的标题subtitle: #副标题description: #描述author: #作者信息avatar: #头像，图片位置在相应主题目录下的imageslanguage: zh-Hans #中文简体email: timezone:# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: #配置主题stylus: compress: true #自适应布局# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git #部署环境，基于hexo+githubpage,所以这里使用git。注意：不同版本的hexo，type有可能不同，3.x以后应使用git,具体参看官方文档 repository: git@github.com:username/username.github.io.git #git仓库地址，替换成你的username即可，其他保持不变，后面会提到如何创建git仓库 branch: master 安装hexo-deployer-git插件1npm install hexo-deployer-git --save 部署你本地的主题到github上123hexo cleanhexo generator #简写 hexo ghexo deploy #简写 hexo d 最后，就可以在线上查看搭建好的博客了https://username.github.io 这次，博客真的就搭建完成了，干杯!~( ゜▽゜)つロ 对了，附送我用的主题以及知乎上的主题收集 hexo-theme-yilia 有哪些好看的 Hexo 主题？-知乎 文章参考 http://crazymilk.github.io/ http://blog.csdn.net/wx_jin/article/details/51027783 补充：HEXO里面一定要注意空格，配置文件_config.yml中的属性一定要在冒号后面空一格，不然会报错。","tags":[{"name":"github","slug":"github","permalink":"https://joker208.github.io/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"https://joker208.github.io/tags/hexo/"}]}]