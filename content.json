[{"title":"Golang Docker host","date":"2020-05-15T16:00:00.000Z","path":"2020/05/16/Golang docker host/","text":"问题描述在docker的alpine容器中使用httpclient向另一个容器发起http请求 1response, err := httpClient.Do(request) 程序应该会使用/etc/hosts中配置的IP，但实际使并没有，导致没有返回结果 经查证发现程序使用了从dns server中查询到的ip 解决方法进入容器添加nsswitch.conf文件 1echo &quot;hosts: files dns&quot; &gt; /etc/nsswitch.conf 问题原因 golang程序解析域名时默认使用/etc/nsswitch.conf文件中的解析顺序，如果nsswitch.conf文件不存在，则优先使用dns服务器解析域名 golang程序解析域名时按照etc/nsswitch.conf文件中的顺序解析，如果nsswitch.conf不存在，则优先使用dns解析域名 参考资料 https://github.com/golang/go/issues/22846 https://www.lijiaocn.com/%E9%97%AE%E9%A2%98/2017/11/09/problem-docker-not-use-hosts-file.html https://blog.csdn.net/u010278923/article/details/79179779 https://blog.csdn.net/huangruifeng/article/details/96594065","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"},{"name":"Docker","slug":"Docker","permalink":"https://joker208.github.io/tags/Docker/"},{"name":"host","slug":"host","permalink":"https://joker208.github.io/tags/host/"}]},{"title":"gorm save update区别","date":"2020-03-22T16:00:00.000Z","path":"2020/03/23/gorm save update区别/","text":"在程序里使用gorm的update更新数据的时候，发现有部分数据没有修改成功。 当使用Updates更新结构体的时候，当结构体的值是””或者0，false等，这些值会被忽略掉。 如果需要更新全部字段建议使用Save方法。 下面是官方的说明文档： Update Changed Fields If you only want to update changed Fields, you could use Update, Updates 12345678910111213141516171819// Update single attribute if it is changed db.Model(&amp;user).Update(\"name\", \"hello\") //// UPDATE users SET name='hello', updated_at='2013-11-17 21:34:10' WHERE id=111; // Update single attribute with combined conditions db.Model(&amp;user).Where(\"active = ?\", true).Update(\"name\", \"hello\") //// UPDATE users SET name='hello', updated_at='2013-11-17 21:34:10' WHERE id=111 AND active=true; // Update multiple attributes with `map`, will only update those changed fieldsdb.Model(&amp;user).Updates(map[string]interface&#123;&#125;&#123;\"name\": \"hello\", \"age\": 18, \"actived\": false&#125;) //// UPDATE users SET name='hello', age=18, actived=false, updated_at='2013-11-17 21:34:10' WHERE id=111; // Update multiple attributes with `struct`, will only update those changed &amp; non blank fields db.Model(&amp;user).Updates(User&#123;Name: \"hello\", Age: 18&#125;) //// UPDATE users SET name='hello', age=18, updated_at = '2013-11-17 21:34:10' WHERE id = 111; // WARNING when update with struct, GORM will only update those fields that with non blank value // For below Update, nothing will be updated as \"\", 0, false are blank values of their types db.Model(&amp;user).Updates(User&#123;Name: \"\", Age: 0, Actived: false&#125;) // WARNING when update with struct, GORM will only update those fields that with non blank value // For below Update, nothing will be updated as “”, 0, false are blank values of their types 当用结构体更新的时候，当结构体的值是””或者0，false等，这些值会被忽略掉。 如果需要更新全部字段建议使用save方法 Update All Fields Save will include all fields when perform the Updating SQL, even it is not changed 12345db.First(&amp;user) user.Name = \"jinzhu 2\" user.Age = 100 db.Save(&amp;user) //// UPDATE users SET name='jinzhu 2', age=100, birthday='2016-01-01', updated_at = '2013-11-17 21:34:10' WHERE id=11 参考资料 官方文档：http://gorm.io/docs/update.html https://www.jianshu.com/p/e8502adac645 https://www.cnblogs.com/oxspirt/p/11240527.html","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"},{"name":"gorm","slug":"gorm","permalink":"https://joker208.github.io/tags/gorm/"}]},{"title":"ERROR 2059(HY000) Authentication plugin 'caching_sha2_password' cannot be loaded","date":"2020-03-17T16:00:00.000Z","path":"2020/03/18/ERROR 2059/","text":"出现这个原因是mysql8 之前的版本中加密规则是mysql_native_password，而在mysql8之后,加密规则是caching_sha2_password，解决问题方法有两种，一种是升级navicat驱动，一种是把mysql用户登录密码加密规则还原成mysql_native_password。 问题：连接Docker启动的mysql出现：ERROR 2059 (HY000): Authentication plugin ‘caching_sha2_password’ cannot be loaded 1234C:\\mysqldata&gt;mysql -h 127.0.0.1 -P 13306 -uroot -pEnter password: ****ERROR 2059 (HY000): Authentication plugin &apos;caching_sha2_password&apos; cannot be loaded: ÕÒ²»µ½Ö¸¶¨µÄÄ£¿é¡£ 解决也很简单 解决方案： 进入mysql容器 1docker exec -it mysql01 /bin/bash 进入mysql 1mysql -uroot -pxxx 修改密码 1ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;xxxx&apos;;","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://joker208.github.io/tags/MySQL/"}]},{"title":"openvpn配置","date":"2020-03-15T16:00:00.000Z","path":"2020/03/16/openvpn配置/","text":"搭建好服务器以后需要经常维护，有时候服务器很难远程访问到，可以搭建openVPN代理，这样维护服务器就很方便了，这里介绍一下openVPN客户端的安装方法。 Windows平台下载客户端 官方下载地址页面 客户端选择 官网提供两种Windows的客户端，根据自己的Windows版本安装即可 openvpn-install-2.4.8-I602-Win7.exe openvpn-install-2.4.8-I602-Win10.exe 安装OpenVPN 双击下载好的exe文件 一路下一步直至安装完成 获取OpenVPN配置文件 OpenVPN的客户端配置文件为*.ovpn 在使用证书认证的情况下，在ovpn文件同一个目录下面会有 *.crt *.key ca.crt 再开启了tls-auth时还会有ta.key文件 证书文件可以内嵌到ovpn文件中，因此有时候会只有一个ovpn文件 配置文件使用方式 直接双击ovpn文件 Windows版OpenVPN客户端安装完成之后，会自动关联ovpn文件，双击即可打开OpenVPN 复制到配置目录 OpenVPN默认会从这两个目录找配置文件，可以存在多个不同的ovpn配置 C:\\Program Files\\OpenVPN\\config C:\\User\\用户名\\OpenVPN\\config（通过双击ovpn的方式会把ovpn拷贝到这个目录） 连接OpenVPN服务器 双击桌面的OpenVPN GUI图标 在任务栏右下角通知栏中找到OpenVPN的图标，右键 点击连接，在有多个ovpn配置时，可以根据名字选择不同的ovpn配置，然后点击连接 连接过程会出现很多日志，连接成功后，右下角会提示连接成功 开机自启动 把 ovpn 配置文件放在 C:\\Program Files\\OpenVPN\\config 运行 services.msc 找到 OpenVPNService ，点击 右键 ，选择 属性 把启动类型改为 自动 ，点击 启动 ，点击 确定 Linux平台 这里以CentOS-7.7为例，YUM源自带了OpenVPN-2.4.8 安装客户端 yum install -y openvpn 获取配置文件 CentOS-7.7安装OpenVPN之后系统服务会识别*.conf的文件 配置文件跟Windows平台只有扩展名的区别，可以直接把Windows平台的ovpn文件改名为conf文件 复制到配置目录 CentOS-7.7安装OpenVPN之后会在/etc/openvpn下创建client和server目录 启动OpenVPN客户端服务 以配置文件abc.conf为例 systemctl start openvpn-client@abc.service 开机自启动 systemctl enable openvpn-client@abc.service MacOS平台系统要求 OS X 10.8 Mountain Lion OS X 10.9 Mavericks OS X 10.10 Yosemite OS X 10.11 El Capitan macOS 10.12 Sierra macOS 10.13 High Sierra macOS 10.14 Mojave 下载客户端 官网下载页面 里面有几个客户端可以选择 OpenVPN Connect Client for macOS version 2.7.1.100 OpenVPN Connect for macOS version 3.1.0 (885) beta Tunnelblick 以上下载到的都是dmg文件，直接安装 文章参考 OpenVPN客户端(Windows/Linux/MacOS)连接OpenVPN服务器","tags":[{"name":"Linux","slug":"Linux","permalink":"https://joker208.github.io/tags/Linux/"},{"name":"openVPN","slug":"openVPN","permalink":"https://joker208.github.io/tags/openVPN/"}]},{"title":"ssh登陆忽略known_hosts文件","date":"2020-03-04T16:00:00.000Z","path":"2020/03/05/ssh登陆忽略known_hosts文件/","text":"在平时工作中，需要SSH登陆到别的Linux主机上去，但有时候SSH登陆会被禁止 并弹出如下类似提示： @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that the RSA host key has just been changed.The fingerprint for the RSA key sent by the remote host is36:68:a6:e6:43:34:6b:82:d7:f4:df:1f:c2:e7:37:cc.Please contact your system administrator.Add correct host key in /u/xlian008/.ssh/known_hosts to get rid of this message.Offending key in /u/xlian008/.ssh/known_hosts:2RSA host key for 135.1.35.130 has changed and you have requested strict checking.Host key verification failed. 比较奇怪，于是研究了一下。 ssh会把你每个你访问过计算机的公钥(public key)都记录在~/.ssh/known_hosts。当下次访问相同计算机时，OpenSSH会核对公钥。如果公钥不同，OpenSSH会发出警告， 避免你受到DNS Hijack之类的攻击。我在上面列出的情况，就是这种情况。 原因：一台主机上有多个Linux系统，会经常切换，那么这些系统使用同一ip，登录过一次后就会把ssh信息记录在本地的~/.ssh/known_hsots文件中，切换该系统后再用ssh访问这台主机就会出现冲突警告，需要手动删除修改known_hsots里面的内容。 有以下两个解决方案： 手动删除修改known_hsots里面的内容； 修改配置文件“~/.ssh/config”，加上这两行，重启服务器。 StrictHostKeyChecking no UserKnownHostsFile /dev/null 优缺点： 需要每次手动删除文件内容，一些自动化脚本的无法运行（在SSH登陆时失败），但是安全性高； SSH登陆时会忽略known_hsots的访问，但是安全性低； 文章参考 https://blog.csdn.net/yasaken/article/details/7348441","tags":[{"name":"Linux","slug":"Linux","permalink":"https://joker208.github.io/tags/Linux/"}]},{"title":"crontab用法总结","date":"2020-02-03T06:25:08.000Z","path":"2020/02/03/crontab用法总结/","text":"搭建好服务器以后，经常需要开启一些定时任务，例如定时校对时间 借着这个机会总结一下crontab定时任务的用法 crond介绍crond 和crontab是不可分割的。crontab是一个命令，常见于Unix和类Unix的操作系统之中，用于设置周期性被执行的指令。该命令从标准输入设备读取指令，并将其存放于“crontab”文件中，以供之后读取和执行。该词来源于希腊语chronos(χρόνος)，原意是时间。 而crond正是它的守护进程。cron服务是一个定时执行的服务，可以通过crontab 命令添加或者编辑需要定时执行的任务。 安装 并设置开机自启 1234yum install crontabs systemctl enable crond systemctl start crond systemctl stop crond 设置定时任务 1vi /etc/crontab 打开后显示 SHELL=/bin/bash PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root # For details see man 4 crontabs # Example of job definition: # .—————- minute (0 - 59) 表示分钟1～59 每分钟用或者 /1表示 # | .————- hour (0 - 23) 表示小时1～23（0表示0点） # | | .———- day of month (1 - 31) 表示日期1～31 # | | | .——- month (1 - 12) OR jan,feb,mar,apr … 月份1～12(可以使用英文简写) # | | | | .—- day of week (0 - 6) (Sunday=0 or 7)OR sun,mon,tue,wed,thu,fri,sat星期0～6(0或7表示星期天)(可以使用英文简写) # | | | | | # * user-name command to be executed 表示运行的命令 12#加载任务,使之生效 crontab /etc/crontab crontab /etc/crontab 加载任务的原理可以理解为 把/etc/crontab文件里面的内容复制到crontab的执行列表里，执行列表里的内容可能和/etc/crontab文件的内容一样，但是这两个东西正常情况下不会互相影响，只有在执行crontab /etc/crontab时才会把内容复制过去 crontab的执行列表中的内容可以使用以下语句直接操作 12345678#查看任务 crontab -l #编辑crontab crontab -e #删除（不会删除/etc/crontab内容，只删除当前已加载的任务） crontab -r #添加（不会添加/etc/crontab内容，直接添加任务）crontab -e crond三种设置方式 第一种 在/etc/crontab下设置，指定用户名的 vim命令进入/etc/crontab 在最后一行加上执行的命令（需要指定用户名） crontab /etc/crontab或者重启crontab，使配置生效 第二种 直接用crontab -e，不需要指定用户，如果是root权限，默认是root定时的 crontab -e进入 直接输入执行的命令 （可以不指定用户） 保存退出（配置已经生效） 第三种 直接写入/var/spool/cron/root vi /var/spool/cron/root 保存退出（配置已经生效） 设置时间格式举例 发现网上有很多错误的写法 错误说法： 每一小时重启apache * /1 /usr/local/etc/rc.d/lighttpd restart 正确说法： 每一小时重启apache(错误的) *代表每分钟就执行一次，语句的意思为每小时的每分钟都在执行重启apache * /1 /usr/local/etc/rc.d/lighttpd restart 其实，下面的两种写法效果相同 * /1 /usr/local/etc/rc.d/lighttpd restart * /usr/local/etc/rc.d/lighttpd restart 另外，注意区分每小时执行任务的写法 0 # 错误 /60 * # 正确 第一个写法是在每小时的0分执行，与任务的开始时间无关 第二个写法是从执行任务的时间点开始，每隔一小时执行一次 其他用法 #每天，每30分钟执行一次 mycommand命令 /30 root /usr/local/mycommand.sh #每天凌晨三点，执行命令脚本，PS:这里由于第一个的分钟没有设置，那么就会每天凌晨3点的每分钟都执行一次命令 3 root /usr/local/mycommand.sh #这样就是每天凌晨三点整执行一次命令脚本 0 3 root /usr/local/mycommand.sh #每天11点到13点之间，每10分钟执行一次命令脚本 /10 11-13 root /usr/local/mycommand.sh #每小时的10-30分钟，每分钟执行一次命令脚本，共执行20次 10-30 root /usr/local/mycommand.sh #每小时的10,30分钟，分别执行一次命令脚本，共执行2次 10,30 root /usr/local/mycommand.sh 附上crontab测试方法 思路：将当前时间输入到日志中 DATEVAR=date * root /bin/echo $($DATEVAR) &gt;&gt; /tmp/crontab.log 文章参考 https://www.cnblogs.com/emanlee/p/10293762.html https://www.jb51.net/article/117241.htm https://www.cnblogs.com/p0st/p/9482167.html https://blog.csdn.net/liu0808/article/details/80668705 https://www.cnblogs.com/p0st/p/9482167.html http://www.voidcn.com/article/p-epupsmuh-bty.html","tags":[{"name":"crontab","slug":"crontab","permalink":"https://joker208.github.io/tags/crontab/"},{"name":"Linux","slug":"Linux","permalink":"https://joker208.github.io/tags/Linux/"}]},{"title":"Docker访问宿主机端口","date":"2019-12-19T06:25:08.000Z","path":"2019/12/19/Docker访问宿主机端口/","text":"Docker容器有的时候需要访问宿主机的服务，但是127.0.0.1并不是宿主机而是Docker自己的服务，可以用下面的语句查询宿主机的ip： 1ip addr show docker0 | grep -Po &apos;inet \\K[\\d.]+&apos; 得到的ip地址为172.17.42.1 经过测试发现这个地址是固定的，每一个Docker容器都是这个ip 以下为stackoverflow原文的问题和解答： I have a docker container running jenkins. As part of the build process, I need to access a web server that is run locally on the host machine. Is there a way the host web server (which can be configured to run on a port) can be exposed to the jenkins container? EDIT: I’m running docker natively on a Linux machine. UPDATE: In addition to @larsks answer below, to get the IP address of the Host IP from the host machine, I do the following: 1ip addr show docker0 | grep -Po &apos;inet \\K[\\d.]+&apos; 172.17.42.1 When running Docker natively on Linux, you can access host services using the IP address of the docker0 interface. From inside the container, this will be your default route. For example, on my system: 12345678910111213$ ip addr show docker0 7: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default link/ether 00:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80::f4d2:49ff:fedd:28a0/64 scope link valid_lft forever preferred_lft forever And inside a container: 123# ip route show default via 172.17.0.1 dev eth0 172.17.0.0/16 dev eth0 src 172.17.0.4 It’s fairly easy to extract this IP address using a simple shell script: 123#!/bin/sh hostip=$(ip route show | awk &apos;/default/ &#123;print $3&#125;&apos;) echo $hostip You may need to modify the iptables rules on your host to permit connections from Docker containers. Something like this will do the trick: 1\\# iptables -A INPUT -i docker0 -j ACCEPT This would permit access to any ports on the host from Docker containers. Note that: iptables rules are ordered, and this rule may or may not do the right thing depending on what other rules come before it. you will only be able to access host services that are either (a) listening on INADDR_ANY (aka 0.0.0.0) or that are explicitly listening on the docker0 interface. 文章参考 https://stackoverflow.com/questions/31324981/how-to-access-host-port-from-docker-container","tags":[{"name":"docker","slug":"docker","permalink":"https://joker208.github.io/tags/docker/"}]},{"title":"服务器全局代理","date":"2019-08-15T06:25:08.000Z","path":"2019/08/15/服务器全局代理/","text":"为了给服务器更新一些应用 需要给服务器科学上网并开启全局代理 ss客户端安装 pip install shadowsocks sudo vi /etc/shadowsocks.json { ​ “server”:”103.16.229.46”, ​ “server_port”:5432, ​ “local_address”: “127.0.0.1”, ​ “local_port”:1080, ​ “password”:”biubiubiu~”, ​ “timeout”:300, ​ “method”:”aes-256-cfb” } 客戶端启动或者停止ss服务。 sslocal -c /etc/shadowsocks.json -d start sslocal -c /etc/shadowsocks.json -d stop privoxy安装wget https://nchc.dl.sourceforge.net/project/ijbswa/Sources/3.0.26%20%28stable%29/privoxy-3.0.26-stable-src.tar.gz tar xf privoxy-3.0.26-stable-src.tar.gz cd privoxy-3.0.26-stable useradd privoxy autoheader &amp;&amp; autoconf ./configure make &amp;&amp; make install sudo vim /usr/local/etc/privoxy/config 修改 listen-address 127.0.0.1:8118 forward-socks5t / 127.0.0.1:1080 . sudo vim /etc/profile 添加以下几行： export http_proxy=http://127.0.0.1:8118 export ftp_proxy=http://127.0.0.1:8118 source /etc/profile service privoxy start 验证curl http://httpbin.org/ip","tags":[{"name":"ss","slug":"ss","permalink":"https://joker208.github.io/tags/ss/"},{"name":"代理","slug":"代理","permalink":"https://joker208.github.io/tags/代理/"}]},{"title":"马来西亚旅游攻略","date":"2019-07-08T07:08:21.000Z","path":"2019/07/08/马来西亚旅行攻略/","text":"马来西亚双人旅行注意事项： 插头不同 没有时差 货币兑换：1MYR=1.7RMB 地铁乘坐价格，交通价格 亚行飞机开的很足，坐飞机需要带衣服 签证/机票预定 提前准备电话卡 潜水提前准备（水母服、脚蹼等） 整体行程概览： 9/30-10/1 广州-&gt;吉隆坡 飞机 10/2 吉隆坡-&gt;斗湖 飞机 10/2 斗 湖-&gt;仙本那 坐车（机场打车，25MYR/人） 10/6-10/7 吉隆坡-&gt;广州 价格：¥2100*2=¥4200（往返） 吉隆坡：**费用总计：¥1000** 双子塔： 用时1-3小时 交通：前往国家石油公司双子塔，可乘Putra线轻轨直达底层；或乘LRT到KLCC站，出站便可到达KLCC商场内 门票： MYR 80 = ¥140 *2=¥280 开放时间：09:00-21:00,停止入场时间:20:30 历史：建成于1997年，是一座超经典现代的建筑物，也是目前全世界最高的两座相连建筑物。这座美轮美奂的特出建筑物的建筑理念是由伊斯兰5大支柱思想所激发而来的，共88层楼高。双峰塔内设有国油交响乐厅，是马来西亚交响乐队及国油表演艺术团例常练习及表演的场所。登上双塔大楼，整个吉隆坡市秀丽风光尽收眼底，尤其是在晚上灯光璀璨的时候，景色尤为壮美。 安排：看看吉隆坡景色，逛逛街。午餐就在这儿吃啦 国家清真寺：用时1-3小时（男士、女士需穿长衣） 交通：国家清真寺位于吉隆坡的Jl Perdana街，吉隆坡老火车站边上，可步行前往 门票：免费（tips: 在正门入口处作访客登记） 开放时间：周一-周四：09:00-12:00；周五：17:30-18:30；周六-周日：15:00-16:00 历史：建于1974年，可容纳8000人同时祈祷，最令人瞩目之处则在于其层叠的伞状屋顶。回教堂的主要圆顶处有18颗星，代表马来13州属及回教的5大支柱。令人惊叹的是其多褶伞形屋顶，73公尺高尖塔更直指蓝天，精致巍然。寺内经堂、走廊、图书室等的装潢与麦加的三大清真寺相仿。每逢星期五主麻日，虔诚的教徒们便涌向这里做祈祷。 安排：感受宗教文化，体会当地宗教特色 独立广场：用时1小时以下 交通：独立广场位于苏丹阿都沙末大厦对面，可乘坐LRT黄线到Masjid Jamek站，再向西步行约10-15分钟即达。 门票：免费 开放时间：全天 历史：独立广场坐落于苏丹阿都沙末大厦对面，绿草如茵的广场极具历史价值。为纪念马来西亚脱离英国统治独立而建，每年会在此举办国庆活动。广场对面是城市长廊，门口的“I LOVE KL”是其标志性logo。周边有圣玛丽教堂、历史博物馆、雪兰莪俱乐部等很多混合各国特色的老式建筑。 安排：随便走走 中央市场 交通：乘坐LRT黄线到Pasar Seni站，再往北步行约10分钟；或乘坐LRT黄线（或红线）到Masjid Jamek站，再往南步行约10分钟 无门票 开放时间：早上10点至晚上10点 历史：过去是吉隆坡主要“湿市场”，现在这个露天集式的艺术及手工艺品中心，则汇集了本地艺术家与工匠的杰作；既可即时让画家给你画张肖像画，也可慢慢欣赏和挑选纪念品，更可到传统药材店搜罗珍贵的药品。 安排：到处看看逛逛，买点特色商品。吃晚餐 住宿（双子塔对面民宿，无边泳池） 价格：¥500 安排：晚上看精力，有时间的话，就去无边泳池玩，没时间的话第二天早上去，在无边泳池照日出 10/2吉隆坡-&gt;斗湖-&gt;仙本那 费用总计：¥2000 路程：吉隆坡-&gt;斗湖 飞机两小时；斗湖-&gt;仙本那 汽车1-2小时 价格：机票往返：¥800*2=¥1600 车费：单程¥45*2=¥90； 仙本那 10/2-10/3镇上呆一天，逛逛 住宿：¥300 10/3-10/5仙本那水屋，潜水 住宿：¥4500（使用信用卡有1%手续费） 10/5 回吉隆坡 车费：¥100 10/6-10/7 回广州","tags":[{"name":"马来西亚🇲🇾","slug":"马来西亚🇲🇾","permalink":"https://joker208.github.io/tags/马来西亚🇲🇾/"}]},{"title":"以太坊学习笔记（十六）","date":"2018-09-25T16:00:00.000Z","path":"2018/09/26/以太坊学习笔记（十六）/","text":"以太坊源码分析以太坊共识算法分为两类 Ethash算法 Clique算法 EthashEthash算法也叫做挖矿算法，是以太坊基于POW工作量证明的共识引擎 Ethash算法过程： 通过扫描块头为每个区块计算出一个seed 根据seed计算一个16MB的伪随机缓存cache，供轻客户端缓存 从缓存cache中生成一个数据集，完整的客户端存储这个数据集 Ethash算法在以太坊中使用Seal方法实现 1Seal(chain ChainReader, block *types.Block, stop &lt;-chan struct&#123;&#125;) (*types.Block, error)//该方法通过输入一个包含本地矿工挖出的最高区块在主干上生成一个新块 该方法包含的参数有ChainReader Block stop ChainReader 1234567891011121314151617181920// 定义了一些方法，用于在区块头验证以及叔块验证期间，访问本地区块链。type ChainReader interface &#123; // 获取区块链的链配置 Config() *params.ChainConfig // 从本地链获取当前块头 CurrentHeader() *types.Header // 通过hash和number从主链中获取一个区块头 GetHeader(hash common.Hash, number uint64) *types.Header // 通过number从主链中获取一个区块头 GetHeaderByNumber(number uint64) *types.Header // 通过hash从主链中获取一个区块头 GetHeaderByHash(hash common.Hash) *types.Header // 通过hash和number从主链中获取一个区块 GetBlock(hash common.Hash, number uint64) *types.Block&#125; ChainReader主要作用是获取header Block 1234567891011121314151617// Block代表以太坊区块链中的一个完整的区块type Block struct &#123; header *Header // 区块包括头 uncles []*Header // 叔块 transactions Transactions // 交易集合 // caches缓存 hash atomic.Value size atomic.Value // Td用于core包存储所有的链上的难度 td *big.Int // 这些字段用于eth包来跟踪inter-peer内部端点区块的接替 ReceivedAt time.Time ReceivedFrom interface&#123;&#125;&#125; Block就是一个完整的区块，包括header uncles transaction等重要信息 stop stop是一个空结构体作为信号源 Seal方法的完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960func (ethash *Ethash) Seal(chain consensus.ChainReader, block *types.Block, stop &lt;-chan struct&#123;&#125;) (*types.Block, error) &#123; // fake模式立即返回0 nonce if ethash.fakeMode &#123; header := block.Header() header.Nonce, header.MixDigest = types.BlockNonce&#123;&#125;, common.Hash&#123;&#125; return block.WithSeal(header), nil &#125; // 共享pow的话，则转到它的共享对象执行Seal操作 if ethash.shared != nil &#123; return ethash.shared.Seal(chain, block, stop) &#125; // 创建一个runner以及它指挥的多重搜索线程 abort := make(chan struct&#123;&#125;) found := make(chan *types.Block) ethash.lock.Lock() // 线程上锁，保证内存的缓存（包含挖矿字段）安全 threads := ethash.threads // 挖矿的线程s if ethash.rand == nil &#123;// rand为空，则为ethash的字段rand赋值 // 获得种子 seed, err := crand.Int(crand.Reader, big.NewInt(math.MaxInt64)) if err != nil &#123;// 执行失败，有报错 ethash.lock.Unlock() // 先解锁 return nil, err // 程序中止，直接返回空块和报错信息 &#125; ethash.rand = rand.New(rand.NewSource(seed.Int64())) // 执行成功，拿到合法种子seed，通过其获得rand对象，赋值。 &#125; ethash.lock.Unlock() // 解锁 if threads == 0 &#123;// 挖矿线程编号为0，则通过方法返回当前物理上可用CPU编号 threads = runtime.NumCPU() &#125; if threads &lt; 0 &#123; // 非法结果 threads = 0 // 置为0，允许在本地或远程没有额外逻辑的情况下，取消本地挖矿操作 &#125; var pend sync.WaitGroup // 创建一个倒计时锁对象，go语法参照 http://www.cnblogs.com/Evsward/p/goPipeline.html#sync.waitgroup for i := 0; i &lt; threads; i++ &#123; pend.Add(1) go func(id int, nonce uint64) &#123;// 核心代码通过闭包多线程技术来执行。 defer pend.Done() ethash.mine(block, id, nonce, abort, found) // Seal核心工作 &#125;(i, uint64(ethash.rand.Int63()))//闭包第二个参数表达式uint64(ethash.rand.Int63())通过上面准备好的rand函数随机数结果作为nonce实参传入方法体 &#125; // 直到seal操作被中止或者找到了一个nonce值，否则一直等 var result *types.Block // 定义一个区块对象result，用于接收操作结果并作为返回值返回上一层 select &#123; // go语法参照 http://www.cnblogs.com/Evsward/p/go.html#select case &lt;-stop: // 外部意外中止，停止所有挖矿线程 close(abort) case result = &lt;-found: // 其中一个线程挖到正确块，中止其他所有线程 close(abort) case &lt;-ethash.update: // ethash对象发生改变，停止当前所有操作，重启当前方法 close(abort) pend.Wait() return ethash.Seal(chain, block, stop) &#125; // 等待所有矿工停止或者返回一个区块 pend.Wait() return result, nil&#125; 在seal中首先进行了状态校验并进行对应的流程梳理，其中最重要的是mine方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// mine函数是真正的pow矿工，用来搜索一个nonce值，nonce值开始于seed值，seed值是能最终产生正确的可匹配可验证的区块难度func (ethash *Ethash) mine(block *types.Block, id int, seed uint64, abort chan struct&#123;&#125;, found chan *types.Block) &#123; // 从区块头中提取出一些数据，放在一个全局变量域中 var ( header = block.Header() hash = header.HashNoNonce().Bytes() target = new(big.Int).Div(maxUint256, header.Difficulty) // 用来验证的target number = header.Number.Uint64() dataset = ethash.dataset(number) ) // 开始生成随机nonce值知道我们中止或者成功找到了一个合适的值 var ( attempts = int64(0) // 初始化一个尝试次数的变量，下面会利用该变量耍一些花枪 nonce = seed // 初始化为seed值，后面每次尝试以后会累加 ) logger := log.New(\"miner\", id) logger.Trace(\"Started ethash search for new nonces\", \"seed\", seed) for &#123; select &#123; case &lt;-abort: // 中止命令 // 挖矿中止，更新状态，中止当前操作，返回空 logger.Trace(\"Ethash nonce search aborted\", \"attempts\", nonce-seed) ethash.hashrate.Mark(attempts) return default: // 默认执行 // 我们没必要在每一次尝试nonce值的时候更新hash率，可以在尝试了2的X次方nonce值以后再更新即可 attempts++ // 通过次数attemp来控制 if (attempts % (1 &lt;&lt; 15)) == 0 &#123;// 这里是定的2的15次方 ethash.hashrate.Mark(attempts) // 满足条件了以后，要更新ethash的hash率字段的状态值 attempts = 0 // 重置尝试次数 &#125; // 为这个nonce值计算pow值 digest, result := hashimotoFull(dataset, hash, nonce) // 调用的hashimotoFull函数在本包的算法库中 if new(big.Int).SetBytes(result).Cmp(target) &lt;= 0 &#123; // 验证标准 // 找到正确nonce值，创建一个基于它的新的区块头 header = types.CopyHeader(header) header.Nonce = types.EncodeNonce(nonce) // 将输入的整型值转换为一个区块nonce值 header.MixDigest = common.BytesToHash(digest) // 将字节数组转换为Hash对象【Hash是32位的根据任意输入数据的Keccak256哈希算法的返回值】 // 封装返回一个区块 select &#123; case found &lt;- block.WithSeal(header): logger.Trace(\"Ethash nonce found and reported\", \"attempts\", nonce-seed, \"nonce\", nonce) case &lt;-abort: logger.Trace(\"Ethash nonce found but discarded\", \"attempts\", nonce-seed, \"nonce\", nonce) &#125; return &#125; nonce++ // 累加nonce &#125; &#125;&#125; mine方法主要就是对nonce的操作，以及对区块头的重建操作 CliqueClique是以太坊基于权利证明的POA共识算法 Clique通过函数Ethereum.StartMining进行初始化 1234567891011121314151617181920212223func (s *Ethereum) StartMining(local bool) error &#123; eb, err := s.Etherbase()//用户地址 if err != nil &#123; log.Error(\"Cannot start mining without etherbase\", \"err\", err) return fmt.Errorf(\"etherbase missing: %v\", err) &#125; if clique, ok := s.engine.(*clique.Clique); ok &#123; //如果是clique共识算法 wallet, err := s.accountManager.Find(accounts.Account&#123;Address: eb&#125;) // 根据用它胡地址获取wallet对象 if wallet == nil || err != nil &#123; log.Error(\"Etherbase account unavailable locally\", \"err\", err) return fmt.Errorf(\"signer missing: %v\", err) &#125; clique.Authorize(eb, wallet.SignHash) // 注入签名者以及wallet对象获取签名方法 &#125; if local &#123; // 如果本地CPU已开始挖矿，我们可以禁用引入的交易拒绝机制来加速同步时间。CPU挖矿在主网是荒诞的，所以没有人能碰到这个路径，然而一旦CPU挖矿同步标志完成以后，将保证私网工作也在一个独立矿工结点。 atomic.StoreUint32(&amp;s.protocolManager.acceptTxs, 1) &#125; go s.miner.Start(eb) return nil&#125; Clique算法在以太坊中也是通过seal来实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//通过本地签名认证创建已密封的区块func (c *Clique) Seal(chain consensus.ChainReader, block *types.Block, stop &lt;-chan struct&#123;&#125;) (*types.Block, error) &#123; header := block.Header() // 不密封创世块 number := header.Number.Uint64() if number == 0 &#123; return nil, errUnknownBlock &#125; // 不支持0-period的链，不支持空块密封，没有奖励但是能够密封 if c.config.Period == 0 &amp;&amp; len(block.Transactions()) == 0 &#123; return nil, errWaitTransactions &#125; // 在整个密封区块的过程中不要持有signer签名者字段 c.lock.RLock() signer, signFn := c.signer, c.signFn //获取签名者和签名方法 c.lock.RUnlock() snap, err := c.snapshot(chain, number-1, header.ParentHash, nil) //调用获取快照 if err != nil &#123; return nil, err &#125;//检查我们是否被授权去签名一个区块 if _, authorized := snap.Signers[signer]; !authorized &#123; return nil, errUnauthorized &#125; // 如果我们是在‘最近签名者’中则等待下一个区块 for seen, recent := range snap.Recents &#123; if recent == signer &#123; // 当前签名者在‘最近签名者’中，如果当前区块没有剔除他的话只能等待（这里涉及到机会均等） if limit := uint64(len(snap.Signers)/2 + 1); number &lt; limit || seen &gt; number-limit &#123; log.Info(\"Signed recently, must wait for others\") &lt;-stop return nil, nil &#125; &#125; &#125; // 协议已经允许我们来签名这个区块，等待我们的时间 delay := time.Unix(header.Time.Int64(), 0).Sub(time.Now()) // nolint: gosimple if header.Difficulty.Cmp(diffNoTurn) == 0 &#123; // 这不是我们的轮次来签名，延迟一点，随机延迟，这样对于每一个签名者来说来允许并发签名 wiggle := time.Duration(len(snap.Signers)/2+1) * wiggleTime delay += time.Duration(rand.Int63n(int64(wiggle))) log.Trace(\"Out-of-turn signing requested\", \"wiggle\", common.PrettyDuration(wiggle)) &#125; log.Trace(\"Waiting for slot to sign and propagate\", \"delay\", common.PrettyDuration(delay)) select &#123; case &lt;-stop: return nil, nil case &lt;-time.After(delay): &#125; // 通过signFn签名函数开始签名 sighash, err := signFn(accounts.Account&#123;Address: signer&#125;, sigHash(header).Bytes()) if err != nil &#123; return nil, err &#125; //将签名结果替换保存在区块头的Extra字段中 copy(header.Extra[len(header.Extra)-extraSeal:], sighash) //通过区块头重新组装生成一个区块 return block.WithSeal(header), nil&#125; 注意以下几点： signer不在snapshot的signer中不允许签名 signer不是本区块的签名者需要延时随机一段时候后再签名，是本区块的签名者则直接签名 签名存放在Extra的extraSeal的65个字节中 为了保证机会均等，clique中规定每一个认证节点在连续SIGNER_LIMIT个区块中，最多只能签发一个区块，每一轮中，最多只有SIGNER_COUNT - SIGNER_LIMIT个认证节点可以参与区块签发 为了保证计算难度相同，每个节点在签发时都会判断本节点是不是本轮的inturn节点，若是inturn节点，则该节点产生的区块难度为2，否则为1 文章来源 https://blog.csdn.net/sportshark/article/details/51905955 https://blog.csdn.net/sportshark/article/details/51905965 https://blog.csdn.net/itcastcpp/article/details/80304343 https://www.cnblogs.com/Evsward/p/ethash.html https://www.cnblogs.com/Evsward/p/miner.html https://blog.csdn.net/ddffr/article/details/78773961 https://ethfans.org/posts/Clique-Consensus-Algorithm https://segmentfault.com/a/1190000014544347","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"},{"name":"以太坊","slug":"以太坊","permalink":"https://joker208.github.io/tags/以太坊/"}]},{"title":"以太坊学习笔记（十五）","date":"2018-09-23T16:00:00.000Z","path":"2018/09/24/以太坊学习笔记（十五）/","text":"以太坊数据存储区块区块block主要由header和body两部分组成 block源码 12345678910111213141516171819202122232425262728293031type Block struct &#123; header *Header //区块头 uncles []*Header //叔节点 transactions Transactions //交易数组 hash atomic.Value size atomic.Value td *big.Int //所有区块Difficulty之和 ReceivedAt time.Time ReceivedFrom interface&#123;&#125;&#125;type Header struct &#123; ParentHash common.Hash //指向父区块的指针 UncleHash common.Hash //block中叔块数组的RLP哈希值 Coinbase common.Address //挖出该区块的人的地址 Root common.Hash //StateDB中的stat trie的根节点的RLP哈希值 TxHash common.Hash //tx trie的根节点的哈希值 ReceiptHash common.Hash //receipt trie的根节点的哈希值 Bloom Bloom //布隆过滤器，用来判断Log对象是否存在 Difficulty *big.Int //难度系数 Number *big.Int //区块序号 GasLimit uint64 //区块内所有Gas消耗的理论上限 GasUsed uint64 //区块内消耗的总Gas Time *big.Int //区块应该被创建的时间 Nonce BlockNonce //挖矿必须的值&#125;type Body struct &#123; Transactions []*Transaction //交易的数组 Uncles []*Header&#125; MPT树MPT是以太坊自定义的树形数据结构 Trie树 123456type Trie struct &#123; root node //根节点 db Database //数据库相关 originalRoot common.Hash //初次创建trie时候需要用到 cachegen, cachelimit uint16 //cache次数的计数器，每次Trie的变动提交后自增&#125; 在Trie结构体中，root作为整个MPT的根节点，root接口有四种实现类 12345678910111213type ( fullNode struct &#123; Children [17]node flags nodeFlag &#125; shortNode struct &#123; Key []byte Val node flags nodeFlag &#125; hashNode []byte valueNode []byte) fullNode：有一个容量为17的node数组成员变量Children，数组中前16个空位分别对应16进制(hex)下的0-9a-f，根据子节点的key值16进制形式下的第一位的值，分别对应到16个空位上，Children的第17位留给fullNode的数据部分 shortNode：仅有一个子节点，成员Val对应的该子节点，key是任意长度的字符串。MPT会通过合并只有一个子节点的父节点和其子节点来缩短trie的深度，所以有些节点会有长度更长的key valueNode：是MPT的叶子节点，valueNode就是所携带数据部分的RLP哈希值，长度32byte，数据的RLP编码值作为valueNode的匹配项存储在数据库里 hashNode：存放32byte的哈希值，也没有子节点，是fullNode或者shortNode对象的RLP哈希值 每个父节点的哈希值来源于所有子节点哈希值的组合，一个顶点的哈希值能够代表一整个树形结构 存储以太坊中使用levelDB数据库 header和block存储规则 12345678 headerPrefix = []byte(\"h\") // headerPrefix + num (uint64 big endian) + hash -&gt; header tdSuffix = []byte(\"t\") // headerPrefix + num (uint64 big endian) + hash + tdSuffix -&gt; td numSuffix = []byte(\"n\") // headerPrefix + num (uint64 big endian) + numSuffix -&gt; hash blockHashPrefix = []byte(\"H\") // blockHashPrefix + hash -&gt; num (uint64 big endian) bodyPrefix = []byte(\"b\") // bodyPrefix + num (uint64 big endian) + hash -&gt; block body blockReceiptsPrefix = []byte(\"r\") // blockReceiptsPrefix + num (uint64 big endian) + hash -&gt; block receipts lookupPrefix = []byte(\"l\") // lookupPrefix + hash -&gt; transaction/receipt lookup metadatabloomBitsPrefix = []byte(\"B\") // bloomBitsPrefix + bit (uint16 big endian) + section (uint64 big endian) + hash -&gt; bloom bits 其中num为区块号 hash为区块哈希值 Header的父指针是不能修改的，当把Header写入数据库是必须把他的父节点和父节点的父节点等等写入数据库 交易存储 123456789101112131415161718func WriteTxLookupEntries(db ethdb.Putter, block *types.Block) error &#123; // 遍历每个交易并且编码元数据 for i, tx := range block.Transactions() &#123; entry := TxLookupEntry&#123; BlockHash: block.Hash(), BlockIndex: block.NumberU64(), Index: uint64(i), &#125; data, err := rlp.EncodeToBytes(entry) if err != nil &#123; return err &#125; if err := db.Put(append(lookupPrefix, tx.Hash().Bytes()...), data); err != nil &#123; return err &#125; &#125; return nil&#125; 将区块号、区块哈希值等数据编码进行存储 StateDB模块 所有的账户由StateDB管理，StateDB中有一个trie结构和一个map结构，都用来存储stateObject，每个stateObject有20bytes的地址，可以作为key使用 存储账户(stateObject) 一个stateObject对应一个账户，一个账户包含余额、合约发起次数等数据，stateObject还包含了一个trie，用来存储State数据 文章来源： http://www.blockchainbrother.com/article/805 https://blog.csdn.net/ddffr/article/details/74517608 https://juejin.im/post/5a4f3aa9f265da3e5468e08e https://blog.csdn.net/teaspring/article/details/75390210","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"},{"name":"以太坊","slug":"以太坊","permalink":"https://joker208.github.io/tags/以太坊/"}]},{"title":"以太坊学习笔记（十四）","date":"2018-09-21T16:00:00.000Z","path":"2018/09/22/以太坊学习笔记（十四）/","text":"以太坊源码分析RLPx加密通信协议PLPx属于会话层协议，主要功能是在节点之间建立并维持通信 RLPx协议每次建立连接都使用不同的密钥，即使现有的密钥泄露也不会导致之前的信息被破解 实现原理：连接双方各自生成一个私钥，然后将得到的公钥发送给对方，双方再利用自己的私钥和对方的公钥生成一个共享密钥，本次传输将使用这个共享密钥 主要成员： newRLPx()：返回一个transport对象 ReadMsg()：调用读写器的ReadMsg WriteMsg()：调用读写器的WriteMsg写信息 close()：关闭连接并返回关闭原因 doEncHandshake()： 加密握手，成功后返回带有共享密钥的secrets对象 doProtoHandshake()：协议握手，输入输出均是protoHandshake对象 doEncHandshake()：加密握手，握手过程分为两个部分 发起方使用自己的私钥和对方的公钥生成一个共享token，并使用一个随机数和一个随机生成的私钥对其签名，将这些信息发送给接收方 接收方也使用自己的私钥和对方的公钥生成一个token，并使用随机数和发送过来的随机数进行签名，将信息再次返回 双方通过各自得到的信息生成一组共享密钥 Diffie – HellmanRLPx协议的实现过程其实是一次Diffie–Hellman密钥交换 Diffie–Hellman是一种安全协议，让双方在完全没有对方任何预先信息的条件下通过不安全信道建立起一个密钥，这个密钥一般作为“对称加密”的密钥而被双方在后续数据传输中使用 以太坊公钥私钥私钥本质上是一个包含64位的随机数 私钥只能由钱包自己来生成，加密存储在keyStore目录下 一个钱包地址只有一个私钥，谁拥有私钥，谁就拥有了这些数字货币的控制权 公钥由私钥通过椭圆曲线加密算法生成的，变换后是一个65个byte的数组 拥有私钥，就可以算出公钥，而公钥不能计算私钥 文章来源: http://www.8btc.com/blockchain-11-rlpx https://blog.csdn.net/itcastcpp/article/details/80305636 https://blog.csdn.net/weixin_41814722/article/details/80680749 https://www.cnblogs.com/hyddd/p/7689132.html https://blog.csdn.net/lee244868149/article/details/51790397 https://www.jianshu.com/p/61493dbe7cc3 https://bitshuo.com/topic/58c7a1ef0a3de8932e6f753b https://blog.csdn.net/luoyhang003/article/details/79970254","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"},{"name":"以太坊","slug":"以太坊","permalink":"https://joker208.github.io/tags/以太坊/"}]},{"title":"以太坊学习笔记（十三）","date":"2018-09-20T16:00:00.000Z","path":"2018/09/21/以太坊学习笔记（十三）/","text":"以太坊源代码分析P2P底层通信P2P即对等网络，是一种在对等者（Peer）之间分配任务和工作负载的分布式应用架构 网络中所有的个体地位和功能上是平等的 另外网络中的个体不需要与其他所有个体保持通信，只需要与相邻个体保持通信 以太坊使用了kademlia网络，是一种分布式散列表(DHT)技术，以异或运算为距离度量基础 ProtocolManager以太坊中通过ProtocolManager来管理个体间的通信 主要成员包括： peerSet()：来缓存相邻个体列表 通过通道和订阅的方式进行信息更新 Fetcher：收集其他成员的消息，来安排获取请求 Downloader：负责所有向相邻个体主动发起的同步流程 Start()：启动p2p通信 Start分别启动四个函数 四个函数的逻辑分别是： 广播新出现的交易对象 广播新挖掘的区块 定时与相邻个体进行区块链的同步 将新出现的交易对象均匀的同步给相邻个体 注意：本体向其他个体主动发起的通信中，按照数据类型可分两类：交易tx和区块block；而按照通信方式划分，亦可分为广播新的单个数据和同步一组同类型数据 handle()：主动请求的回调函数 在节点间通信时，除了主动互相通知外，还需要一种被请求调用的通信，使用handle函数来实现回调 123456789101112131415161718192021func (pm *ProtocolManager) handle(p *peer) error &#123; td, head, genesis := pm.blockchain.Status() p.Handshake(pm.networkId, td, head, genesis) if rw, ok := p.rw.(*meteredMsgReadWriter); ok &#123; rm.Init(p.version) &#125; pm.peers.Register(p) defer pm.removePeer(p.id) pm.downloader.RegisterPeer(p.id, p.version, p) pm.syncTransactions(p) ... for &#123; if err := pm.handleMsg(p); err != nil &#123; return err &#125; &#125;&#125; handle函数的逻辑为与对方确定状态，初始化读写通道，将要访问的节点存入相邻列表，在Downloader成员注册节点，向对方节点发送请求，监听返回的消息并进行处理 建立新peer连接Node.Start()中首先会创建p2p.Server{}，将Node中载入的所有实现体中的Protocol都作为Server.Protocols列表，启动Server对象，并将Server对象作为参数去逐一启动每个实现体,ProtocolManager.Protocols最终被导入了p2p.Server.Protocols 文章来源: https://blog.csdn.net/screscent/article/details/79416251 https://blog.csdn.net/screscent/article/details/79416318 http://baijiahao.baidu.com/s?id=1604499731426119688&amp;wfr=spider&amp;for=pc https://blog.csdn.net/teaspring/article/details/78455046","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"},{"name":"以太坊","slug":"以太坊","permalink":"https://joker208.github.io/tags/以太坊/"}]},{"title":"Golang学习笔记（六）","date":"2018-09-19T16:00:00.000Z","path":"2018/09/20/Golang学习笔记（六）/","text":"Golang记录copy复制会比等号复制慢。但是copy复制为值复制，改变原切片的值不会影响新切片。而等号复制为指针复制，改变原切片或新切片都会对另一个产生影响。 c++声明数组12345678910//静态 定义了数组array，并未对数组进行初始化 int array[100]; //静态 定义并初始化了数组array int array[100] = &#123;1，2&#125;; //动态 分配了长度为100的数组array int* array = new int[100]; delete []array; //动态 为长度为100的数组array初始化前两个元素 int* array = new int[100](1，2); delete []array; golang 声明数组1234567891011121314151617181920212223//第一种 //var &lt;数组名称&gt; [&lt;数组长度&gt;]&lt;数组元素&gt; var arr [2]int arr[0]=1 arr[1]=2 //第二种 //var &lt;数组名称&gt; = [&lt;数组长度&gt;]&lt;数组元素&gt;&#123;元素1,元素2,...&#125; var arr = [2]int&#123;1,2&#125; //或者 arr := [2]int&#123;1,2&#125; //第三种 //var &lt;数组名称&gt; [&lt;数组长度&gt;]&lt;数组元素&gt; = [...]&lt;元素类型&gt;&#123;元素1,元素2,...&#125; var arr = [...]int&#123;1,2&#125; //或者 arr := [...]int&#123;1,2&#125; //第四种 //var &lt;数组名称&gt; [&lt;数组长度&gt;]&lt;数组元素&gt; = [...]&lt;元素类型&gt;&#123;索引1:元素1,索引2:元素2,...&#125;var arr = [...]int&#123;1:1,0:2&#125; //或者 arr := [...]int&#123;1:1,0:2&#125;","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"}]},{"title":"以太坊学习笔记（十二）","date":"2018-09-19T16:00:00.000Z","path":"2018/09/20/以太坊学习笔记（十二）/","text":"以太坊源代码共识算法共识算法使用Engine接口，分为两种实现方式： 基于运算能力的Ethash算法 基于“同行”认证的Clique算法 Engine接口的函数包括以下： VerifyHeader()，VerifyHeaders()，VerifyUncles()：验证区块的成员是否合理 Prepare()：在Header创建时调用，对Difficulty等属性赋值 Finalize()：在区块的数据成员都赋值完毕是，生成Root，TxHash，UncleHash，ReceiptHash等成员 Seal()：对执行过Finalize函数的区块进行授权，成功返回区块的所有成员，该区块就是完成区块，可以被广播也可以插入到区块链 VerifySeal()：用来确定区块是否已经Seal操作 Ethash共识算法Ethash称为PoW(Proof-of-Work) 基本原理公式为： $$$$ RAND(h, n) &lt;= M / d $$$$M表示一个极大的数，d表示Header成员Difficulty RAND()用来产生随机数，h是Header的哈希值，n表示Header成员Nonce 该公式表示在最大不超过M的范围内，找到一个随机数数，如果这个数符合条件(&lt;=M/d)，那么就认为Seal()成功 mine()函数在实现Seal()函数过程中，会以多线程的方式并行调用mine()函数，线程个数等于Ethash.threads 主要代码如下： 1234567891011121314151617181920212223242526func (ethash *Ethash) mine(block *Block, id int, seed uint64, abort chan struct&#123;&#125;, found chan *Block) &#123; var ( header = block.Header() hash = header.HashNoNonce().Bytes() target = new(big.Int).Div(maxUint256, header.Difficulty) number = header.Number.Uint64() dataset = ethash.dataset(number) nonce = seed ) for &#123; select &#123; case &lt;-abort: ...; return default: digest, result := hashimotoFull(dataset, hash, nonce) // compute the PoW value of this nonce if new(big.Int).SetBytes(result).Cmp(target) &lt;= 0 &#123; // x.Cmp(y) &lt;= 0 means x &lt;= y header = types.CopyHeader(header) header.Nonce = types.EncodeNonce(nonce) header.MixDigest = common.BytesToHash(digest) found&lt;- block.WithSeal(header) return &#125; &#125; nonce++ &#125;&#125; 函数定义了一组局部变量，然后是一个for循环，调用hashimotoFull()，当函数的返回值符合条件时，复制Header对象，Nonce、MixDigest赋值，返回授权过的区块 123456789101112131415161718func hashimotoFull(dataset []uint32, hash []byte, nonce uint64) ([]byte, []byte) &#123; lookup := func(index uint32) []uint32 &#123; offset := index * hashWords return dataset[offset : offset+hashWords] &#125; return hashimoto(hash, nonce, uint64(len(dataset))*4, lookup)&#125;func hashimotoLight（size uint64, cache []uint32, hash []byte, nonce uint64） ([]byte, []byte) &#123; lookup := func(index uint32) []uint32 &#123; rawData := generateDatasetItem(cache, index, keccak512) data := make([]uint32, len(rawData)/4) for i := 0; i &lt; len(data); i++ &#123; data[i] = binary.LittleEndian.Uint32(rawData[i*4:]) &#125; return data &#125; return hashimoto(hash, nonce, size, lookup)&#125; 以上两个函数类似，都返回hashimoto()，相比于Light函数，Full函数调用的@size参数更大，lookup也更大。Full函数是Seal()调用的，Light()是VerifySeal()准备的 hashimoto()函数12// consensus/ethash/algorithm.go func hashimoto(hash []byte, nonce uint64, size uint64, lookup(index uint32) []uint32) (digest []byte, result []byte) 传入的参数包括： hash 区块哈希值 nonce 区块nonce lookup() 非线性表查找的哈希函数 size 查找的非线性表格的容量 digest 32bytes的字节串 result 32bytes的字节串 经过一系列多次、多种的哈希运算，hashimoto()返回两个长度均为32的byte数组 digest[]和result[] Clique共识算法Clique算法又称Proof-of-Authortiy(PoA) Clique算法实现公式： $$ n = F(pr, h) $$ F()是椭圆曲线数字签名算法(ECDSA)，n是生成的数字签名，pr是公钥，h是被加密的内容 Clique.Seal()函数的基本逻辑就是：有一个Address类型地址用作数字签名的公钥，如果它是已认证的，则执行指定的数字签名算法 Clique的认证机制包含以下规则 所有的地址分为已认证和未认证的 已认证和未认证可以互相转换，必须通过投票机制完成 一张投票包括：投票方地址，被投票地址，和被投票地址的新认证状态 任意地址A只能给地址B投一张票 Clique算法中的投票系统的巧妙之处在于，每张投票并不是某个投票方主动“投”出来的，而是随机组合出来的 新区块的Coinbase是一个随机的被投票地址 首先从proposals中筛选出有效的不记名投票，获取有效的被投票地址列表，随机选取一个地址作为Coinbase。新区块的Coinbase会在后面的认证环节当作被投票地址 总结 Ethash算法(PoW)基于运算能力来筛选出挖掘区块的获胜者，运算过程中使用了大量、多次、多种的哈希函数，通过极高的计算资源消耗，来限制某些节点通过超常规的计算能力轻易形成“中心化”倾向 Clique算法(PoA)利用数字签名算法完成Seal操作，签名所用公钥必须是已认证的。所有认证地址基于特殊的投票地址进行动态管理，记名投票由不记名投票和投票方地址随机组合而成，杜绝重复的不记名投票，严格限制外部代码恶意操纵投票数据 以太坊还在区块结构中增加了叔区块(uncles)成员以加大计算资源的消耗，并通过在交易执行环节对叔区块作者(挖掘者)的奖励，以收益机制来调动网络中各节点运算资源分布更加均匀。","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"},{"name":"以太坊","slug":"以太坊","permalink":"https://joker208.github.io/tags/以太坊/"}]},{"title":"Golang学习笔记（五）","date":"2018-09-18T16:00:00.000Z","path":"2018/09/19/Golang学习笔记（五）/","text":"Go语言特性 可直接编译成机器码，直接生成可执行二进制文件 静态类型语言，可以在编译的时候检查出来隐藏的大多数问题 动态类型语言：是指在运行期间才去做数据类型检查的语言，说的是数据类型 动态语言：说的是运行是改变结构，说的是代码结构 静态类型语言：静态语言的数据类型是在编译期间（或运行之前）确定的，编写代码的时候要明确确定变量的数据类型 静态语言：与动态语言相对应的，运行时结构不可变的语言就是静态语言 大量的第三方包可以使用 语言层面支持并发 go hello（） 支持垃圾回收 语言简洁，关键字只有25个，支持继承、重载、对象 跨平台，引用plan9的代码，不依赖系统信息 Plan9是一个分布式操作系统，它能把网络上一切的资源当作文件来进行使用。Plan9中最本质的思想是“一切皆是文件” Go语言的优劣 Go语言适合做服务端程序，例如各种web程序，服务器软件，命令行工具 Go语言不适合开发有图形界面的应用程序，官方没有提供相关的图形库 不支持多态 多态：多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说：允许将子类类型的指针赋值给父类类型的指针（一个接口，多种方法）。C++ 支持两种多态性：编译时多态性，运行时多态性。a、编译时多态性（静态多态）：通过重载函数实现b、运行时多态性（动态多态）：通过虚函数实现。","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"}]},{"title":"以太坊学习笔记（十一）","date":"2018-09-16T16:00:00.000Z","path":"2018/09/17/以太坊学习笔记（十一）/","text":"以太坊源代码挖矿在以太坊中miner包负责提供新挖的区块 公共类Miner用于实现挖矿功能，里面包含一个worker类型的成员变量，woker里面有一组Agent接口类型对象 Work结构体用于携带数据 数据传输过程：worder把work对象发送给每个Agent，其中的Agent完成挖矿是，将一个经过授权的Block加上Work返回给worder 一个新区块被挖掘代码实现分为两步： 组装一个新区块，这个区块各个数据基本完整，并且所有交易执行完毕，所有收据都记录完毕 补全区块其它的成员属性，完成授权 miner包解析Miner类 New()：在对miner的成员变量初始化完成后，创建worker对象，创建完成后运行miner.Update()函数 Update()：Update监听有关Downloader的事件，当收到Downloader的StartEvent时，说明正在下载新区块，此时停止挖掘工作，继续监听；当收到DoneEvent或FailEvent时，说明下载完成或下载失败，则继续挖掘新区块，停止监听 Worker类 Update()：监听ChainHeadEvent，ChainSideEvent，TxPreEvent几个事件 ChainHeadEvent事件是区块链中加入了一个新的区块作为链头，worker会立刻开始准备挖掘 ChainSideEvent事件是区块链中加入一个新区块作为链头的旁支，worker会把区块加入possibleUncles[]，作为新区块可能的Uncle TxPreEvent事件是一个新的交易tx加入TxPool，worker把tx加入Work.txs数组 wait()：该函数会一直等待Agent发送回来新的Block和Work对象 commitNewWork()：完成待挖掘区块的组装 CpuAgent类 update()：一直监听相关channel，如果收到Work对象，启动mine()函数；如果收到停止消息，退出一切相关操作 mine()：调用Engine.Seal()函数，对区块进行授权，如果成功，将Block和Work一起发送给worker","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"},{"name":"以太坊","slug":"以太坊","permalink":"https://joker208.github.io/tags/以太坊/"}]},{"title":"以太坊学习笔记（十）","date":"2018-09-14T16:00:00.000Z","path":"2018/09/15/以太坊学习笔记（十）/","text":"以太坊源代码以太坊中所有的数据都是以键值对的形式存在，使用的底层数据库LevelDB 交易操作的记录以及相关的数据构成了区块 交易的结果以账户的状态存在 各个数据单元层次如下图： 各个数据单元使用Merkle-PatriciaTrie(MPT)数据结构组织管理数据 区块Block账户的活动都是在区块中存储，每个区块都有一个交易对象的列表 交易的结果由一个Receipt对象和一组Log对象记录 不同的区块通过ParentHash指针串联成单向链表 区块的结构分为Header和Body Header的成员变量： ParentHash：指向父区块的指针，每个区块有且只有一个父区块 Coinbase：区块的矿工地址 UncleHash：区块结构体成员uncles的RLP（Recursive Length Prefix，递归长度前缀编码）哈希值 Root：StateDB中的状态树的根节点的RLP哈希值 TxHash：Tx树的根节点的RLP哈希值 ReceiptHash：接收树的根节点的RLP哈希值 Bloom：过滤器，用来判断log对象是否存在 Difficulty：区块难度 Number：区块序号 Time：区块创建时间 GasLimit：区块所有Gas消耗上限 GasUsed：区块的操作执行实际消耗的Gas总和 Nonce：64位哈希数 Body的成员变量： td（totalDifficulty）整个区块链表所有的区块Difficulty的总和 Uncles 为了防止以太坊网络波动过大 block的唯一标识符就是Header成员的RLP哈希值 区块链操作 查找 区块链中存在成员currentBlock，指向当前最新的区块 插入和删除 区块链的header中存在ParentHash的向前指针，这个值不能随意修改，当需要插入时，从新的header开始回溯，保证所有的parent都写入数据库，一般插入和删除时同时出现的 Merkle-Patricia Trie(MPT)MPT是以太坊自定义的树形数据结构 MPT 的节点分为四种： fullNode：可以携带多个子节点的父节点 shortNode：仅有一个子节点的父节点 valueNode：MPT中的子节点 hashNode：fullNode或者shortNode的RLP哈希值","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"},{"name":"以太坊","slug":"以太坊","permalink":"https://joker208.github.io/tags/以太坊/"}]},{"title":"以太坊学习笔记（九）","date":"2018-09-13T16:00:00.000Z","path":"2018/09/14/以太坊学习笔记（九）/","text":"以太坊源码分析 main函数分析123456789101112func HandleAction(action interface&#123;&#125;, context *Context) (err error) &#123; if a, ok := action.(ActionFunc); ok &#123; return a(context) &#125; else if a, ok := action.(func(*Context) error); ok &#123; return a(context) &#125; else if a, ok := action.(func(*Context)); ok &#123; // deprecated function signature a(context) return nil &#125; else &#123; return errInvalidActionType &#125;&#125; 其中action类型为第二个分支，执行a(context)，这时会调用App.init()初始化的consoleCommand 分析consoleCommand函数1234567891011consoleCommand = cli.Command&#123; Action: utils.MigrateFlags(localConsole), Name: \"console\", Usage: \"Start an interactive JavaScript environment\", Flags: append(append(append(nodeFlags, rpcFlags...), consoleFlags...), whisperFlags...), Category: \"CONSOLE COMMANDS\", Description: `The Geth console is an interactive shell for the JavaScript runtime environmentwhich exposes a node admin interface as well as the Ðapp JavaScript API.See https://github.com/ethereum/go-ethereum/wiki/Javascipt-Console.`,&#125; consoleCommand中包含的Action会执行localConsole函数 分析localConsole函数1234567891011121314151617181920212223242526272829303132333435func localConsole(ctx *cli.Context) error &#123; // Create and start the node based on the CLI flags node := makeFullNode(ctx) startNode(ctx, node) defer node.Stop() // Attach to the newly started node and start the JavaScript console client, err := node.Attach() if err != nil &#123; utils.Fatalf(\"Failed to attach to the inproc geth: %v\", err) &#125; config := console.Config&#123; DataDir: utils.MakeDataDir(ctx), DocRoot: ctx.GlobalString(utils.JSpathFlag.Name), Client: client, Preload: utils.MakeConsolePreloads(ctx), &#125; console, err := console.New(config) if err != nil &#123; utils.Fatalf(\"Failed to start the JavaScript console: %v\", err) &#125; defer console.Stop(false) // If only a short execution was requested, evaluate and return if script := ctx.GlobalString(utils.ExecFlag.Name); script != \"\" &#123; console.Evaluate(script) return nil &#125; // Otherwise print the welcome screen and enter interactive mode console.Welcome() console.Interactive() return nil&#125; localConsole函数分为3块功能： 创建并启动一个节点，在结束时停止节点 启动一个js控制台并且与连接刚创建的节点 输出欢迎信息 分析makeFullNode函数123456789101112131415161718192021222324252627282930313233343536373839func makeFullNode(ctx *cli.Context) *node.Node &#123; stack, cfg := makeConfigNode(ctx) utils.RegisterEthService(stack, &amp;cfg.Eth) // Whisper must be explicitly enabled by specifying at least 1 whisper flag or in dev mode shhEnabled := enableWhisper(ctx) shhAutoEnabled := !ctx.GlobalIsSet(utils.WhisperEnabledFlag.Name) &amp;&amp; ctx.GlobalIsSet(utils.DevModeFlag.Name) if shhEnabled || shhAutoEnabled &#123; if ctx.GlobalIsSet(utils.WhisperMaxMessageSizeFlag.Name) &#123; cfg.Shh.MaxMessageSize = uint32(ctx.Int(utils.WhisperMaxMessageSizeFlag.Name)) &#125; if ctx.GlobalIsSet(utils.WhisperMinPOWFlag.Name) &#123; cfg.Shh.MinimumAcceptedPOW = ctx.Float64(utils.WhisperMinPOWFlag.Name) &#125; utils.RegisterShhService(stack, &amp;cfg.Shh) &#125; // Add the Ethereum Stats daemon if requested. if cfg.Ethstats.URL != \"\" &#123; utils.RegisterEthStatsService(stack, cfg.Ethstats.URL) &#125; // Add the release oracle service so it boots along with node. if err := stack.Register(func(ctx *node.ServiceContext) (node.Service, error) &#123; config := release.Config&#123; Oracle: relOracle, Major: uint32(params.VersionMajor), Minor: uint32(params.VersionMinor), Patch: uint32(params.VersionPatch), &#125; commit, _ := hex.DecodeString(gitCommit) copy(config.Commit[:], commit) return release.NewReleaseService(ctx, config) &#125;); err != nil &#123; utils.Fatalf(\"Failed to register the Geth release oracle service: %v\", err) &#125; return stack&#125; 首先使用makeConfigNode函数创建node，然后添加一个和节点同时启动的服务 分析makeConfigNode函数func makeConfigNode(ctx *cli.Context) (*node.Node, gethConfig) { // Load defaults. cfg := gethConfig{ Eth: eth.DefaultConfig, Shh: whisper.DefaultConfig, Node: defaultNodeConfig(), } // Load config file. if file := ctx.GlobalString(configFileFlag.Name); file != &quot;&quot; { if err := loadConfig(file, &amp;cfg); err != nil { utils.Fatalf(&quot;%v&quot;, err) } } // Apply flags. utils.SetNodeConfig(ctx, &amp;cfg.Node) stack, err := node.New(&amp;cfg.Node) if err != nil { utils.Fatalf(&quot;Failed to create the protocol stack: %v&quot;, err) } utils.SetEthConfig(ctx, stack, &amp;cfg.Eth) if ctx.GlobalIsSet(utils.EthStatsURLFlag.Name) { cfg.Ethstats.URL = ctx.GlobalString(utils.EthStatsURLFlag.Name) } utils.SetShhConfig(ctx, stack, &amp;cfg.Shh) return stack, cfg } 函数先初始化config并赋值，然后初始化一个node，node创建完成以后设置EhtConfig和ShhConfig 分析node.New函数- 123456789101112131415161718192021222324252627282930313233343536373839404142func New(conf *Config) (*Node, error) &#123; // Copy config and resolve the datadir so future changes to the current // working directory don't affect the node. confCopy := *conf conf = &amp;confCopy if conf.DataDir != \"\" &#123; absdatadir, err := filepath.Abs(conf.DataDir) if err != nil &#123; return nil, err &#125; conf.DataDir = absdatadir &#125; // Ensure that the instance name doesn't cause weird conflicts with // other files in the data directory. if strings.ContainsAny(conf.Name, `/\\`) &#123; return nil, errors.New(`Config.Name must not contain '/' or '\\'`) &#125; if conf.Name == datadirDefaultKeyStore &#123; return nil, errors.New(`Config.Name cannot be \"` + datadirDefaultKeyStore + `\"`) &#125; if strings.HasSuffix(conf.Name, \".ipc\") &#123; return nil, errors.New(`Config.Name cannot end in \".ipc\"`) &#125; // Ensure that the AccountManager method works before the node has started. // We rely on this in cmd/geth. am, ephemeralKeystore, err := makeAccountManager(conf) if err != nil &#123; return nil, err &#125; // Note: any interaction with Config that would create/touch files // in the data directory or instance directory is delayed until Start. return &amp;Node&#123; accman: am, ephemeralKeystore: ephemeralKeystore, config: conf, serviceFuncs: []ServiceConstructor&#123;&#125;, ipcEndpoint: conf.IPCEndpoint(), httpEndpoint: conf.HTTPEndpoint(), wsEndpoint: conf.WSEndpoint(), eventmux: new(event.TypeMux), &#125;, nil&#125; 首先将保存路径转换为绝对路径并进行合法性验证，在节点开始前执行AccountManager，最后一步才是真正的创建节点","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"},{"name":"以太坊","slug":"以太坊","permalink":"https://joker208.github.io/tags/以太坊/"}]},{"title":"以太坊学习笔记（八）","date":"2018-09-10T16:00:00.000Z","path":"2018/09/11/以太坊学习笔记（八）/","text":"以太坊源码分析以太坊环境搭建搭建go环境 编译源码 编译完成后会生成以下指令 abigen 源代码生成器，将智能合约转换为Go package，编译Solidity源文件 bootnod 用作轻量级的节点引导工具 evm 可以运行字节码的以太坊虚拟机，可以对evm操作码进行封装 geth 以太坊主要的执行客户端，多用途命令行工具 rlpdump 开发实用工具，可将二进制RLP（递归长度前缀）（以太坊协议网络以及共识使用的数据编码）转储存至用户友好的分层表示 puppeth 命令行执行页面的向导程序，用于创建新的以太坊网络 swarm swarm的守护程序和工具（swarm 是一个分布式存储平台和内容分发服务） gethgeth子命令分为以下几种 account：账户管理 attach：链接到js环境 bug：报告geth库的错误 console：开启一个js交互环境 copydb：将选中区块链的数据复制到本地 dump：删除指定区块 dumpconfig：显示配置值 export：导出区块链数据 import：导入区块链数据 init：初始化一个新的初始区块（创世区块） js：执行指定的js文件 license：展示许可信息 makecache：生成用于测试的ethash校验缓存（ethash是工作量证明算法） makedag：生成用于测试的ethash挖矿DAG（DAG是比特币扩容方案） monitor：监视节点权值 removedb：移除区块链以及状态数据库 version：显示版本号 wallet：管理以太坊钱包 分析main函数首先使用init初始化变量参数 mian方法 123456func main() &#123; if err := app.Run(os.Args); err != nil &#123; fmt.Fprintln(os.Stderr, err) os.Exit(1) &#125;&#125; 调用了app.Run函数 Run方法解析了输入的参数，并且将命令保存到context中，然后调用HandleAction来处理命令 123456789101112func HandleAction(action interface&#123;&#125;, context *Context) (err error) &#123; if a, ok := action.(ActionFunc); ok &#123; return a(context) &#125; else if a, ok := action.(func(*Context) error); ok &#123; return a(context) &#125; else if a, ok := action.(func(*Context)); ok &#123; // deprecated function signature a(context) return nil &#125; else &#123; return errInvalidActionType &#125;&#125;","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"},{"name":"以太坊","slug":"以太坊","permalink":"https://joker208.github.io/tags/以太坊/"}]},{"title":"以太坊学习笔记（七）","date":"2018-09-01T16:00:00.000Z","path":"2018/09/02/以太坊学习笔记（七）/","text":"代币ICOERC20 TokenERC20是一个以太坊代币标准，是创建代币时需要遵守的标准 接口123456789101112131415contract ERC20Interface &#123; string public constant name = \"Token Name\"; string public constant symbol = \"SYM\"; uint8 public constant decimals = 18; // 18 is the most common number of decimal places function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); &#125; 说明： name：代币的名字 symbol：代币单位 decimal：代币精确位数 totalSupply()：发行总量 balanceOf()：查看账户余额 allowance()：可以用来控制交易 transfer()：发送代币 approve()：允许使用用户花费的最高金额 transferFrom()：实现不同用户之间的交易 Transfer()：当token被转移时被触发 Approval()：当任何成功调用approve()时被触发 部署 安装配置MetaMask，选择测试网络Ropsten 打开Remix Solidity IDE，复制代码，并设置对应的选项 interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address =&gt; uint256) public balanceOf; // mapping (address =&gt; mapping (address =&gt; uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] &gt;= _value); require(balanceOf[_to] + _value &gt; balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value &lt;= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] &gt;= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] &gt;= _value); require(_value &lt;= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; Burn(_from, _value); return true; } } Metamask弹出确认框点击提交，复制合约地址 打开Metamask添加TOKEN，填入合约地址 代币交易 使用网页钱包，连接到MetaMask 添加代币，填入代币合约地址 进行代币转账交易，输入代币账户和数量以及对应的代币，点击创建交易 实现代币的管理者创建一个owned合约 contract owned { address public owner; function owned() { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } // 实现所有权转移 function transferOwnership(address newOwner) onlyOwner { owner = newOwner; } } 加入函数修改器onlyOwner contract MyToken is owned { function MyToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol, address centralMinter ) { if(centralMinter != 0 ) owner = centralMinter; } } 代币增发123456function mintToken(address target, uint256 mintedAmount) onlyOwner &#123; balanceOf[target] += mintedAmount; totalSupply += mintedAmount; Transfer(0, owner, mintedAmount); Transfer(owner, target, mintedAmount);&#125; 资产冻结在transfer函数中添加方法 require(!frozenAccount[msg.sender]); freezeAccount函数 mapping (address =&gt; bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); }","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"},{"name":"以太坊","slug":"以太坊","permalink":"https://joker208.github.io/tags/以太坊/"}]},{"title":"以太坊学习笔记（六）","date":"2018-08-31T16:00:00.000Z","path":"2018/09/01/以太坊学习笔记（六）/","text":"SoliditySolidity APIAPI主要是solidity中的特殊变量和函数，分为五类 区块和交易 错误处理 数字及加密功能 地址 合约 区块和交易 block.blockhash(blockNumber)：返回给定区块号的哈希值 block.coinbase(address)：当前块矿工的地址 block.difficulty 返回当前区块的难度值 block.gaslimit 返回当前区块的gaslimit block.number 返回当前区块的区块号 block.timestamp 当前区块的时间戳 msg.data 返回完整的调用数据 msg.gas 返回剩余的gas msg.sender 返回转账人的地址 msg.sig 返回调用数据的前四个字节 msg.value 返回消息附带的以太币数量 tx.gasprice 返回交易所需要的gas tx.origin 返回交易的发起人的地址 其中msg是全局变量，msg的值会受到外部函数影响 避免使用block.timestamp,now,block.blockhash生成随机数，因为这几个值可能会受到矿工影响 只能查看最近的256个区块，其它的将会返回0 错误处理Solidity通过撤消当前调用改变的状态来处理错误 Solidity保证每次调用都是事务性的 assert(bool)：判断内部错误 require(bool)：判断输入或者外部组件错误 revert()：标记错误并回退当前调用 数学及加密功能 addmod(uint x,unit y,unit k)：计算(x+y)%k mulmod(uint x,unit y,unit k)：计算（x y）%k keccak256()：使用以太坊Keccak-256计算HASH值 sha256()：使用以太坊SHA-256计算HASH值 ripemd160()：使用计算HASH值 地址 .balance()：Address的余额（单位：wei） .transfer()：发送指定数量的以太币到某个地址（失败抛出异常） .send()：发送指定数量的以太币到某个地址（失败返回false） .call()：发起底层的call .callcode()：发起底层的callcode调用 .delegatecall()：发起底层的delegatecall的调用 send() 执行时必须检查返回值保证交易成功 合约 this：表示当前合约，可以转换为Address selfdestruct()：销毁当前合约 suicide()：等同于selfdestruct() 函数修改器(Function Modifiers)函数修改器主要作为函数执行的先行方法，当不符合条件时抛出异常 函数修改器可以被继承 可以同时继承两个函数修改器 123456789101112131415161718contract owned &#123; function owned() &#123; owner = msg.sender; &#125; address owner; modifier onlyOwner &#123; if (msg.sender != owner) throw; _;//表示函数体的替换位置 &#125;&#125;contract mortal is owned &#123; function close() onlyOwner &#123; selfdestruct(owner); &#125;&#125;","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"},{"name":"以太坊","slug":"以太坊","permalink":"https://joker208.github.io/tags/以太坊/"},{"name":"Solidity","slug":"Solidity","permalink":"https://joker208.github.io/tags/Solidity/"}]},{"title":"以太坊学习笔记（五）","date":"2018-08-10T16:00:00.000Z","path":"2018/08/11/以太坊学习笔记（五）/","text":"Solidity视图函数（View Functions）状态变量不会被改变的函数，应该声明为视图函数，关键字为view 被认为是修改了状态的情况： 写入状态变量 触发events 创建合约 call调用附加以太币 调用没有view和pure的函数 对于不会改变状态的函数尽量要使用view view和pure都不是强制使用的 纯函数（View Functions）pure表示函数不读取状态变量也不修改状态变量 被认为是读取状态的情况： 读出状态变量 访问balance属性 访问block tx msg的成员（除msg.sig和msg.data外） 调用没有pure的函数 事件Event事件是以太坊EVM的日志基础设施，事件是一种记录功能，事件发生后记录在区块链上的是日志 定义事件 event EventName(address bidder, uint amount); 触发事件 emit EventName(msg.sender, msg.value); 工作量证明挖矿指交易完成后，确认交易并且把交易记录写入区块链从而获得一定的比特币奖励 工作量证明为了保证一段时间内只有一个人可以挖矿成功，需要提高挖矿难度 解决这些运算难题从而获得挖矿的权利就是工作量证明 拜占庭将军问题问题描述如何保证不可靠信道上的信息一致性 区块链解决方案区块链中使用“工作量证明”保证同一时间只有一个节点在广播，同时附带该节点的签名 这样在同一时间所有节点都会得到同样的信息 当有多条信息需要一致时，所有的节点都会检查是否是在上一条成功信息的基础上传达的，从而保证每个节点上的信息都是正确的","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"},{"name":"以太坊","slug":"以太坊","permalink":"https://joker208.github.io/tags/以太坊/"},{"name":"Solidity","slug":"Solidity","permalink":"https://joker208.github.io/tags/Solidity/"}]},{"title":"以太坊学习笔记（四）","date":"2018-07-14T16:00:00.000Z","path":"2018/07/15/以太坊学习笔记（四）/","text":"Solidity结构体（Structs）使用struct定义自定义类型（引用类型） 不能将struct自身作为struct的成员 struct的赋值实际是引用的复制，修改局部变量时会影响到原变量 映射（Mappings）映射不能使用的类型有： 映射 变长数组 合约 枚举 结构体 映射是一个哈希表，映射中不存储数据，映射没有长度概念 货币单位（Ether Units）数字常量加后缀（wei,finney,szabo,ether） 默认单位为wei 不同以太币单位转换： 1 ether == 10^3 finney 1 ether == 10^6 szabo 1 ether == 10^18 wei 时间单位（Time Units）时间单位有seconds, minutes, hours, days, weeks, years 默认单位为seconds 不同时间单位转换： 1 weeks = 7 days 1 years = 365 days Solidity API block.blockhash(uint blockNumber) 返回对应区块号的哈希值 block.coinbase 返回当前区块的矿工地址 block.difficulty 返回当前区块的难度值 block.gaslimit 返回当前区块的gaslimit block.number 返回当前区块的区块号 block.timestamp 当前区块的时间戳 msg.data 返回完整的调用数据 msg.gas 返回剩余的gas msg.sender 返回转账人的地址 msg.sig 返回调用数据的前四个字节 msg.value 返回消息附带的以太币数量 tx.gasprice 返回交易所需要的gas tx.origin 返回交易的发起人的地址","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"},{"name":"以太坊","slug":"以太坊","permalink":"https://joker208.github.io/tags/以太坊/"},{"name":"Solidity","slug":"Solidity","permalink":"https://joker208.github.io/tags/Solidity/"}]},{"title":"以太坊学习笔记（三）","date":"2018-07-13T16:00:00.000Z","path":"2018/07/14/以太坊学习笔记（三）/","text":"Solidity类型 值类型 布尔类型 整型：uint对应uint256 int对应int256 定长浮点型：ufixedMxN ufixedMxN（M表示占用位数，N便是小数位数） 定长字节数组：byte对应bytes1 bytes32 *变长字节数组：bytes string (不是值类型) 有理数和整型常量： (支持科学计数法,如2e2) 字符串常量：（支持转义字符） 十六进制常量：关键字hex+单或双引号字符串，如hex”000000ff” 枚举类型：枚举类型需要至少一名成员 函数类型 地址类型 地址常量 地址类型20字节（以太坊地址长度） 支持比较运算符 地址类型成员 balance属性：查询账户余额 transfer()函数：转账，失败报错，更加安全 send()函数：转账，失败返回false，用于失败时操作 call()函数：底层接口，向目标合约发送消息，返回bool值 可以加修饰器 gas()：使用gas量 value()：附带以太币 delegatecall()函数：代码执行时其它数据都是当前合约数据，没有设置参数的功能 地址常量十六进制常量 通过合法性检查 函数类型 public 所有可以访问 pricate 合约内可以访问 internal 当前合约和继承合约可以访问 external 合约以外可以访问 数据存储位置数据存储位置有三种： * memeory：内存中，暂时存储，合约运行时创建，gas消耗量小 * storage：区块链中，永久存储，在合约创建之前创建，gas消耗量大 * calldata：专门用来存储函数参数，暂时存储 强制数据位置 外部函数external function的参数强制存在calldata中 状态参数强制存在storage 默认数据位置 除外部函数外的其他函数参数默认存在memory中 复杂类型（引用类型）的变量默认存在storage中 数组可以声明定长数组也可以声明变长数组 定长和变长数组不能隐式转换 成员 length属性:变长数组不支持 push方法：变长数组添加新元素","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"},{"name":"以太坊","slug":"以太坊","permalink":"https://joker208.github.io/tags/以太坊/"},{"name":"Solidity","slug":"Solidity","permalink":"https://joker208.github.io/tags/Solidity/"}]},{"title":"以太坊学习笔记（二）","date":"2018-07-12T16:00:00.000Z","path":"2018/07/13/以太坊学习笔记（二）/","text":"以太坊代币定义以太坊代币是用以太坊智能合约编写的数字货币，可以通过新的智能合约创建新的代币 功能新的代币可以实现以下功能 新的代币名称、代币总量等参数 基本交易功能 实现合约管理者 黑白名单 代币增发 挖矿机制 新的代币与其他数字货币的兑换 gas的自动补充 常用组件 Geth：以太坊官方客户端，用go编写 Solidity：针对合约编写的高级语言 Truffle：开发以太坊Dapp的框架 Web3.js：用来做节点交互的js库 Remix：以太坊智能合约开发用的IDE Ganache：可视化私有链客户端 DApp实现（Pet-Shop）开发环境安装truffle npm install -g truffle truffle version 如果有出现 Truffle v4.1.12 (core: 4.1.12) Solidity v0.4.24 (solc-js) 说明truffle安装成功 下载代码创建一个新文件夹 执行以下代码 truffle unbox pet-shop 新建合约在contracts文件夹下新建Adoption.sol pragma solidity ^0.4.17; contract Adoption { address[16] public adopters; // 保存领养者的地址 // 领养宠物 function adopt(uint petId) public returns (uint) { require(petId &gt;= 0 &amp;&amp; petId &lt;= 15); // 确保id在数组长度内 adopters[petId] = msg.sender; // 保存调用这地址 return petId; } // 返回领养者 function getAdopters() public view returns (address[16]) { return adopters; } } 编译合约根目录下执行以下代码编译合约 truffle compile 部署脚本在migrations文件夹下创建2_deploy_contracts.js var Adoption = artifacts.require(&quot;Adoption&quot;); module.exports = function(deployer) { deployer.deploy(Adoption); }; 部署前使用Ganache开启一个私链，默认端口为7545 执行部署命令 truffle migrate Ganache中看到区块链状态发生变化，说明智能合约部署完成 测试test文件夹下新建TestAdoption.sol pragma solidity ^0.4.17; import &quot;truffle/Assert.sol&quot;; // 引入的断言 import &quot;truffle/DeployedAddresses.sol&quot;; // 用来获取被测试合约的地址 import &quot;../contracts/Adoption.sol&quot;; // 被测试合约 contract TestAdoption { Adoption adoption = Adoption(DeployedAddresses.Adoption()); // 领养测试用例 function testUserCanAdoptPet() public { uint returnedId = adoption.adopt(8); uint expected = 8; Assert.equal(returnedId, expected, &quot;Adoption of pet ID 8 should be recorded.&quot;); } // 宠物所有者测试用例 function testGetAdopterAddressByPetId() public { // 期望领养者的地址就是本合约地址，因为交易是由测试合约发起交易， address expected = this; address adopter = adoption.adopters(8); Assert.equal(adopter, expected, &quot;Owner of pet ID 8 should be recorded.&quot;); } // 测试所有领养者 function testGetAdopterAddressByPetIdInArray() public { // 领养者的地址就是本合约地址 address expected = this; address[16] memory adopters = adoption.getAdopters(); Assert.equal(adopters[8], expected, &quot;Owner of pet ID 8 should be recorded.&quot;); } } 执行测试命令 truffle test 初始化web3src/js文件夹下编辑app.js修改initWeb3() initWeb3: function() { // Is there an injected web3 instance? if (typeof web3 !== &apos;undefined&apos;) { App.web3Provider = web3.currentProvider; } else { // If no injected web3 instance is detected, fall back to Ganache App.web3Provider = new Web3.providers.HttpProvider(&apos;http://localhost:7545&apos;); } web3 = new Web3(App.web3Provider); return App.initContract(); } 实例化合约修改initContract() initContract: function() { // 加载Adoption.json，保存了Adoption的ABI（接口说明）信息及部署后的网络(地址)信息，它在编译合约的时候生成ABI，在部署的时候追加网络信息 $.getJSON(&apos;Adoption.json&apos;, function(data) { // 用Adoption.json数据创建一个可交互的TruffleContract合约实例。 var AdoptionArtifact = data; App.contracts.Adoption = TruffleContract(AdoptionArtifact); // Set the provider for our contract App.contracts.Adoption.setProvider(App.web3Provider); // Use our contract to retrieve and mark the adopted pets return App.markAdopted(); }); return App.bindEvents(); } 修改markAdopted() markAdopted: function(adopters, account) { var adoptionInstance; App.contracts.Adoption.deployed().then(function(instance) { adoptionInstance = instance; // 调用合约的getAdopters(), 用call读取信息不用消耗gas return adoptionInstance.getAdopters.call(); }).then(function(adopters) { for (i = 0; i &lt; adopters.length; i++) { if (adopters[i] !== &apos;0x0000000000000000000000000000000000000000&apos;) { $(&apos;.panel-pet&apos;).eq(i).find(&apos;button&apos;).text(&apos;Success&apos;).attr(&apos;disabled&apos;, true); } } }).catch(function(err) { console.log(err.message); }); } 修改handleAdopt() handleAdopt: function(event) { event.preventDefault(); var petId = parseInt($(event.target).data(&apos;id&apos;)); var adoptionInstance; // 获取用户账号 web3.eth.getAccounts(function(error, accounts) { if (error) { console.log(error); } var account = accounts[0]; App.contracts.Adoption.deployed().then(function(instance) { adoptionInstance = instance; // 发送交易领养宠物 return adoptionInstance.adopt(petId, {from: account}); }).then(function(result) { return App.markAdopted(); }).catch(function(err) { console.log(err.message); }); }); } MetaMask配置钱包点击Import Existing DEN candy maple cake sugar pudding cream honey rich smooth crumble sweet treat 并设置密码 连接网络选择Custom RPC，添加http://127.0.0.1:7545 启动服务1npm run dev","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"},{"name":"以太坊","slug":"以太坊","permalink":"https://joker208.github.io/tags/以太坊/"}]},{"title":"以太坊学习笔记（一）","date":"2018-07-11T16:00:00.000Z","path":"2018/07/12/以太坊学习笔记（一）/","text":"以太坊开发分布式APP（DApp）分布式app是指客户端为用户直接提供服务，服务端运行在以太坊网络上的智能合约 DApp客户端分布式应用的客户端多为简单易用的图形化界面而非命令行，它与传统的app的区别是与以太坊的区块链交互 DApp浏览器主要目的 提供到以太坊节点的连接，可以切换不同节点 提供一个账户帮助用户与服务端交互 Mist 以太坊官方DApp浏览器 Status 移动端DApp浏览器 MetaMask Google浏览器扩展 以太坊节点每个节点都包含所有区块链的内容，可以使用geth来运行全节点（geth是go语言编写的以太坊客户端） 以太坊代币以map键值对的形式存储在区块链的状态里，其中键是地址，值就是余额，代币经常用来鼓励用户之间交互，或者证明对资产的所有权 Truffle和Embark Truffle是使用以太坊Solidity语言开发的一套框架，集成客户端命令，提供项目构建机制，抽象合约接口，提供了控制台 Embark易于上手，提供了许多便捷的功能 Truffle 安装 $ npm install -g truffle Truffle客户端 建议在开发和正式发布时使用不同的客户端开发时推荐使用EthereumJS TestRPC正式发布时推荐使用Geth 创建工程 $ Truffle v3.4.11 - a development framework for Ethereum $ truffle init 生成的目录结构 contract/ 存放Truffle合约文件 migrations/ 存放脚本文件 test/ 存放测试文件 truffle.js Truffle的配置文件 truffle-config.js 同上面文件内容相同 编译合约 $ truffle compile Truffle会默认编译上一次被修改过的文件 移植 $ truffle migrate 移植主要是用来缓存发布任务，类似于客户端和区块链之间的缓存区 构建应用 $ truffle build ETHPMETHPM是一个智能合约的资源管理库，可以利用它连接到其它合约，同时可以与以上两种框架结合，是开发更加便利 网络Mainnet：以太坊主网？？ Ropsten ：以太坊使用工作量证明的主测试网络 Kovan：parity客户端组成的测试网络 Rinkeby:geth客户端组成的测试网络","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"},{"name":"以太坊","slug":"以太坊","permalink":"https://joker208.github.io/tags/以太坊/"}]},{"title":"区块链学习笔记（一）","date":"2018-07-10T16:00:00.000Z","path":"2018/07/11/区块链学习笔记（一）/","text":"区块链定义 区块链就是通过密码学的方式形成的一个由集体维护的分布式数据库。 特性 去中心化 安全性 去信任 区块结构 区块高度：区块ID 头哈希：该区块的唯一哈希值 父哈希：上一个区块的哈希值 时间戳 merkle根：由每笔交易的哈希值计算得出，确保每一笔交易真实唯一 难度：该区块的计算难度，根据现有算力自动调节 Nonce：只被使用一次的非重复随机值 区块体：一定时间生成的交易信息 区块链1.0-数字货币比特币交易 每一个地址都有对应的比特币个数，交易开始时由收款方创建一个新地址，付款方向这个地址发起付款，客户端会使用新地址的私钥对这个交易申请进行签名，任何人可以使用对应的公钥对交易申请进行验证。矿工将过去一段时间的交易数据打包，通过哈希算法基于前一个哈希值、新交易数据、随机数的组合找到一个符合规则的新的哈希值，这时可以认为新的区块被确认，交易生效，而矿工会得到一定报酬。 比特币网络 比特币网络是一种点对点的数字现金系统（P2P） p2p(Peer to Peer)对等网络，网络的参与者共享自己的一部分资源，这些资源在网络上可以直接被其它参与者访问使用。网络上所有的参与者既是提供者（Server），又是获取者（Client）。 网络节点全功能节点包括四个模块 钱包（Wallet）：支持比特币交易查询 矿工（Miner）：通过哈希运算的方式竞争获得新区块 完整区块链（full Block-chain database）：全节点，可以独立验证所有交易 网络路由节点（Network routing）：转发交易和区块信息，监听维护节点的链接 区块链2.0-可编程金融以太坊 智能合约：是运行在evm中的应用，通过接受交易请求生成新的交易，或者调用其它合约。智能合约的执行可能会更新以太坊网络上的账本状态 账户：以太坊账户分为合约账户(CA)和外部账户（EOA）。合约账户用来存储智能合约代码，外部账户是以太币拥有者的账户，用来调用合约账户 交易：以太坊中指不同账户间的消息数据，是执行操作的最小单位，可以是以太币也可以是执行参数，交易包括以下字段 to：目标地址 value：以太币数量 nonce：1.工作量证明 2.账户随机数 gasPrice：每一计算步骤需要支付矿工的费用 startgas：最大Gas值 signature：签名 以太币：以太坊的货币，用于购买燃料 燃料：执行合约指令会消耗燃料，燃料是交易执行指令的上限，当燃料用完指令没有执行完是，合约终止状态回滚","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"},{"name":"区块链","slug":"区块链","permalink":"https://joker208.github.io/tags/区块链/"}]},{"title":"区块链学习笔记（二）","date":"2018-07-10T16:00:00.000Z","path":"2018/07/11/区块链学习笔记（二）/","text":"区块链架构区块链技术主要包含四个方面： 点对点网络设计 加密技术应用 分布式算法 数据存储技术 架构层次 协议层：是整个区块链的核心，它包括了一个完整的网络币产品，功能主要是建立网络、交易通道、节点奖励，涉及到的技术主要有网络编程、分布式算法、加密签名、数据存储等 扩展层：是对协议层的网络币加以使用，主要分为法币与网络币的直接交易（各类交易所）和其他方向的扩展（智能合约）两类 应用层：是针对实际用户的层面，现在主要是各类轻钱包客户端，是未来发展的主要方向 以太坊和智能合约区块链的优点有 区块链把数据存到了整个区块链中，不需要专门的存储机制，并且提供奖励机制 区块链有共识机制，能够对交易快速验证和确认 区块链提供匿名机制 区块链可以实现资产转移，且比传统货币费用更低 区块链上存储的交易都是可信赖的 以太坊在区块链的基础上添加了智能合约，智能合约可以存储数据、封装代码、执行计算任务，我们可以运用合约实现自己的功能 以太坊账户以太坊中的状态是由账户和账户之间的交易信息构成的以太坊账户包含四部分： 随机数：确保每笔交易唯一 账户余额 合约代码 存储的数据 以太坊交易以太坊的交易与比特币交易的不同点： 以太坊的交易既可以是由外部实体创建也可以是合约创建，比特币的交易只能是从外部创建 以太坊的交易可以包含其他数据 以太坊的交易可以进行回应 EVM代码执行以太坊合约的代码使用低级字节码语言写成，代码由一系列的字节构成，每一个字节代表一种操作，操作可以访问三种存储空间： 堆栈 内存 合约存储当虚拟机运行时，它的完整状态可以由元组（block_state, transaction, message, code, memory, stack, pc, gas）定义。每轮执行时，通过调出代码的（pc）个字节，每个命令都有定义如何操作元组数据 应用以太坊有三大类应用 金融应用，为用户的资金提供参与合约的方法 半金融应用 非金融应用，例如在线投票、去中心化治理","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"},{"name":"区块链","slug":"区块链","permalink":"https://joker208.github.io/tags/区块链/"}]},{"title":"Golang学习笔记（四）","date":"2018-06-18T16:00:00.000Z","path":"2018/06/19/Golang学习笔记（四）/","text":"GO指南1fmt.Println(\"My favorite number is\", rand.Intn(10)) 例子上的代码运行出的结果是不会变化的并不能算真正的随机 需要添加随机种子 1rand.Seed(time.Now().UnixNano()) 首字母大写为共用方法，可以被外部调用首字母小写只能在包内调用 初始化变量时可以省略类型，从初始值中获得类型 ‘:=’结构不能用在函数外 byte 是 uint8 的别名rune 是 int32 的别名 类型转换数值转换 123var i int = 11var f float64 = float64(i)var u uint = uint(f) int 转 string 12var i int = 11var s string= strconv.Itoa(i) int64 转 string 12var i int64 = 11var s string= strconv.FormatInt(i,10) uint64 转 string 12var i uint64=11var s string=strconv.FormatUint(i,10) string 转 int 123var s string = \"11\"var i inti, err := strconv.Atoi(s) string 转 int64 123var s string = \"11\"var i int64i, err := strconv.ParseInt(s, 10, 64) float64 转 string 12var f float64 = 11.1var s string = strconv.FormatFloat(f, 'f', -1, 64) string 转 float64 123var s string = \"11.1\"var f float64f, err := strconv.ParseFloat(s, 64) switch中fallthrough会直接执行下一个case或default语句（无论条件是否满足）fallthrough必须是case中的最后一句 defer调用的函数会以栈的形式存储，调用时遵照后进先出的原则 123456func main() &#123; for i := 0; i &lt; 10; i++ &#123; defer fmt.Println(i) &#125; fmt.Println(\"done\")&#125; 输出 123456789101112API server listening at: 127.0.0.1:47919done9876543210 slice添加元素func append(s []T, vs …T) []T 第一个参数为要添加元素的slice第二个参数为要添加的元素 原理 append首先检查是否到达最大容量cap 没有的话就直接在后面添加元素 如果超过cap向内存申请一个长度是原来两倍的新数组 将原来的值都复制过去 slice指向新的数组并释放掉原来的数组 闭包闭包就是一个函数引用函数以外的变量 斐波那契闭包 123456789101112131415func fibonacci() func() int &#123; a, b := 0, 1 return func() int &#123; temp := a a, b = b, (a + b) return temp &#125;&#125;func main() &#123; f := fibonacci() for i := 0; i &lt; 10; i++ &#123; fmt.Println(f()) &#125;&#125; goroutine线程go f() 开启新的线程 channel管道创建 1234ch := make(chan int)ch &lt;- v //向管道传值v &lt;- ch //接收管道的值 一般情况下，只有传值或只有接收都会造成线程阻塞 ch := make(chan int,10)//缓冲管道 当管道有缓冲时，当缓冲区满的时候向管道传值才会阻塞当缓冲区为空的时候接收管道值才会阻塞 select可以使多个通信在同一个线程上等待 switch的case不需要break结尾switch的case不需要break结尾switch的case不需要break结尾","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"}]},{"title":"Golang学习笔记（三）","date":"2018-06-09T16:00:00.000Z","path":"2018/06/10/Golang学习笔记（三）/","text":"golang 并行 goroutines、信道和死锁（一）goroutines1234567891011func loop() &#123; for i := 0; i &lt; 10; i++ &#123; fmt.Printf(\"%d \", i) &#125;&#125;func main() &#123; go loop() loop()&#125; goroutine还没来得及跑loop的时候，主函数已经退出 这时需要一个类似join的东西来阻塞住主线。那就是信道 （二）信道信道是goroutine之间互相通讯的东西。类似我们Unix上的管道（可以在进程间传递消息）， 用来goroutine之间发消息和接收消息。其实，就是在做goroutine之间的内存共享。 使用make来建立一个信道: 1234567func main() &#123; var messages chan string = make(chan string) go func(message string) &#123; messages &lt;- message // 存消息 &#125;(\"Ping!\") fmt.Println(&lt;-messages) // 取消息&#125; 默认的，信道的存消息和取消息都是阻塞的 (叫做无缓冲的信道) 无缓冲的信道在取消息和存消息的时候都会挂起当前的goroutine，除非另一端已经准备好 123456789var ch chan int = make(chan int)func foo() &#123; ch &lt;- 0 // 向ch中加数据，如果没有其他goroutine来取走这个数据，那么挂起foo, 直到main函数把0这个数据拿走&#125;func main() &#123; go foo() &lt;- ch // 从ch取数据，如果ch中还没放数据，那就挂起main线，直到foo函数中放数据为止&#125; 如果不用信道来阻塞主线的话，主线就会过早跑完，loop线都没有机会执行 其实，无缓冲的信道永远不会存储数据，只负责数据的流通 从无缓冲信道取数据，必须要有数据流进来才可以，否则当前线阻塞 数据流入无缓冲信道, 如果没有其他goroutine来拿走这个数据，那么当前线阻塞 如果信道正有数据在流动，我们还要加入数据，或者信道干涩，我们一直向无数据流入的空信道取数据就会引起死锁 （三）死锁1234func main() &#123; ch := make(chan int) &lt;- ch // ??main goroutine, ??c??&#125; 只有一个goroutine, 所以当你向里面加数据或者存数据的话，都会锁死信道， 并且阻塞当前 goroutine, 也就是所有的goroutine(其实就main线一个)都在等待信道的开放(没人拿走数据信道是不会开放的)， 也就是死锁 几个死锁的例子1. 12345func main() &#123; ch := make(chan int) ch &lt;- 1 // 1流入信道，堵塞当前线, 没人取走数据信道不会打开 fmt.Println(\"This line code wont run\") //在此行执行之前Go就会报死锁&#125; 2. 123456789101112var ch1 chan int = make(chan int)var ch2 chan int = make(chan int)func say(s string) &#123; fmt.Println(s) ch1 &lt;- &lt;- ch2 // ch1 等待 ch2流出的数据&#125;func main() &#123; go say(\"hello\") &lt;- ch1 // 堵塞主线&#125; 3. 12345678c, quit := make(chan int), make(chan int)go func() &#123; c &lt;- 1 // c通道的数据没有被其他goroutine读取走，堵塞当前goroutine quit &lt;- 0 // quit始终没有办法写入数据&#125;()&lt;- quit // quit 等待数据的写 避免死锁的方法: 避免数据有存无取 或者有取无存 使用缓冲信道 缓冲信道在声明一个信道的时候，我们给make以第二个参数来指明它的容量(默认为0，即无缓冲): var ch chan int = make(chan int, 2) // 写入2个元素都不会阻塞当前goroutine, 存储个数达到2的时候会阻塞 缓冲信道是先进先出的，我们可以把缓冲信道看作为一个线程安全的队列： 12345678910func main() &#123; ch := make(chan int, 3) ch &lt;- 1 ch &lt;- 2 ch &lt;- 3 fmt.Println(&lt;-ch) // 1 fmt.Println(&lt;-ch) // 2 fmt.Println(&lt;-ch) // 3&#125; Go语言允许我们使用range来读取信道: 但是range可能会造成死锁，原因是range不等到信道关闭是不会结束读取的。也就是如果缓冲信道干涸了，那么range就会阻塞当前goroutine, 所以死锁 为了避免以上情况，有以下两种方式1. 12345678910ch := make(chan int, 3)ch &lt;- 1ch &lt;- 2ch &lt;- 3for v := range ch &#123; fmt.Println(v) if len(ch) &lt;= 0 &#123; // 如果现有数据量为0，跳出循环 break &#125;&#125; 2. 1234567891011ch := make(chan int, 3)ch &lt;- 1ch &lt;- 2ch &lt;- 3// 显式地关闭信道close(ch)for v := range ch &#123; fmt.Println(v)&#125; 并行并发与并行两个队列，一个Coffee机器，那是并发两个队列，两个Coffee机器，那是并行 为了达到真正的并行，我们需要告诉Go我们允许同时最多使用多个核，例如下面的方法 1. 123456789101112131415161718192021222324import ( \"fmt\" \"runtime\")var quit chan int = make(chan int)func loop() &#123; for i := 0; i &lt; 100; i++ &#123; fmt.Printf(\"%d \", i) &#125; quit &lt;- 0&#125;func main() &#123; runtime.GOMAXPROCS(2) // 最多使用2个核 go loop() go loop() for i := 0; i &lt; 2; i++ &#123; &lt;- quit &#125;&#125; 2. 1234567891011121314151617func loop() &#123; for i := 0; i &lt; 10; i++ &#123; runtime.Gosched() // 显式地让出CPU时间给其他goroutine fmt.Printf(\"%d \", i) &#125; quit &lt;- 0&#125;func main() &#123; go loop() go loop() for i := 0; i &lt; 2; i++ &#123; &lt;- quit &#125;&#125; 上面的两个例子都用到了runtime调节器 runtime调度器 Gosched 让出cpu NumCPU 返回当前系统的CPU核数量 GOMAXPROCS 设置最大的可同时使用的CPU核数 Goexit 退出当前goroutine(但是defer语句会照常执行)","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"}]},{"title":"Golang学习笔记（二）","date":"2018-06-08T16:00:00.000Z","path":"2018/06/09/Golang学习笔记（二）/","text":"golang 接口 反射 并发一、接口设计理念Go不是传统意义上的面向对象编程语言，它没有类及其继承的概念。接口是一种契约，实现类型必须满足它，它描述了类型的行为，规定类型可以做什么。接口彻底将类型能做什么，以及如何做分离开来，使得相同接口的变量在不同的时刻表现出不同的行为，这就是多态的本质 接口的特性是golang支持鸭子类型的基础，即“如果它走起来像鸭子，叫起来像鸭子（实现了接口要的方法），它就是一只鸭子（可以被赋值给接口的值）”。凭借接口机制和鸭子类型，golang提供了一种游离于类、继承、模板之外的更加灵活强大的选择。 注意的点 类型不需要显式地声明它实现了某个接口，接口被隐式地实现，多个类型可以实现同一个接口 一个类型可以实现多个接口 实现了某个接口的类型，可以有其它的方法（多对多） 接口方法中类型T和*T的区别(指针)指针是存储一个变量的内存地址的变量。 （不支持指针运算） 取地址符是 &amp;，放到一个变量前使用就会返回相应变量的内存地址解引用指针的意思是通过指针访问被指向的值。指针 a 的解引用表示为：*a。 不要传递指向数组的指针给函数，而是使用切片假设我们需要通过函数修改一个数组。一个办法是将数组的指针作为参数传递给函数。 123456789101112131415package mainimport ( \"fmt\")func modify(arr *[3]int) &#123; (*arr)[0] = 90&#125;func main() &#123; a := [3]int&#123;89, 90, 91&#125; modify(&amp;a) fmt.Println(a)&#125; 123456789101112131415package mainimport ( \"fmt\")func modify(arr *[3]int) &#123; arr[0] = 90 //a[x] 是 (*a)[x] 的简写，因此上面的程序中，(*arr)[0] 可以替换为 arr[0]。&#125;func main() &#123; a := [3]int&#123;89, 90, 91&#125; modify(&amp;a) fmt.Println(a)&#125; 123456789101112131415package mainimport ( \"fmt\")func modify(sls []int) &#123; sls[0] = 90&#125;func main() &#123; a := [3]int&#123;89, 90, 91&#125; modify(a[:]) //虽然可以通过传递数组指针给函数的方式来修改原始数组的值，但这在 Go 中不是惯用的方式，我们可以使用切片完成同样的事情。 fmt.Println(a)&#125; Go 语言规范定义了接口方法集的调用规则： 类型 T 的可调用方法集包含接受者为 T 或 T 的所有方法集类型 T 的可调用方法集包含接受者为 T 的所有方法类型 T 的可调用方法集不包含接受者为 *T 的方法 空接口什么方法都没定义的接口就是空接口。根据Golang的概念，空接口被任何类型隐式实现，所以空接口可以容纳任何类型。 二、反射反射是在golang程序运行时检查变量所具有类型的一种机制 在基本的层面上，反射只是一个检查存储在接口变量中的类型和值的算法。使用反射机制，首先需要导入reflect包，reflect包中有两个重要类型需要了解，reflect.Type和reflect.Value，这两个类型使得可以访问变量的内容。与此相关的，还有两个简单的函数，reflect.TypeOf和reflect.ValueOf，可以从接口值中分别获取reflect.Type和reflect.Value。 1234567891011121314import ( \"fmt\" \"reflect\")func main() &#123; var x float64 = 1.1 fmt.Println(\"reflect.Value:\", reflect.ValueOf(x)) fmt.Println(\"reflect.Type:\", reflect.TypeOf(x)) v := reflect.ValueOf(x) fmt.Println(\"reflect.Type:\",v.Type()) fmt.Println(\"actual value:\", v.Float()) fmt.Println(\"kind is float64?\", v.Kind() == reflect.Float64)&#125; golang采用静态类型机制，TypeOf返回静态类型 反射三法则 官方文档 http://blog.golang.org/laws-of-reflection 法则一：从接口值到反射对象的反射（Reflection goes from interface value toreflection object） 代表方法为reflect.ValueOf和reflect.TypeOffunc ValueOf(i interface{}) Valuefunc TypeOf(i interface{}) Type 法则二：从反射对象到接口值的反射（Reflection goes from reflection object to interface value） 从reflect.Value可以使用Interface方法还原接口值；可以高效地打包类型和值信息到接口表达中，并返回这个结果 方法声明： 1func (v Value) Interface() interface&#123;&#125; 通过反射对象 v 可以打印 float64 的表达值 12y :=v.Interface().(float64) // y 将为类型 float64。fmt.Println(y) 更为简洁的实现 1fmt.Println(v.Interface()) 法则三：为了修改反射对象，其值必须可设置（To modify a reflectionobject, the value must be settable） 反射对象可以通过SetFloat等方法设置值，通过CanSet判断可设置性。但是这里面有坑，有些值是不可设置的 1234567891011import ( \"fmt\" \"reflect\")func main() &#123; var x float64 = 1.1 v := reflect.ValueOf(x) fmt.Println(\"settability of v:\",v.CanSet()) v.SetFloat(1.2)//错误&#125; V := reflect.ValueOf(x)，这个函数是值传递，即传递了一个x的副本到函数中，而非x本身，值传递的参数是不能被真正修改的 借助Elem方法，通过指针来修改指针指向的具体值。 123func (v Value)Elem() Value//Elem returns the value that the interface v contains or that the pointer vpoints to. //It panics if v's Kind is not Interface or Ptr. It returns the zeroValue if v is nil. 12345678func main() &#123; var x float64 = 1.1 p := reflect.ValueOf(&amp;x) fmt.Println(\"type of p:\",p.Type()) v := p.Elem() fmt.Println(\"type of v:\",v.Type()) fmt.Println(\"settability of v:\",v.CanSet())&#125; 虽然p是不可修改的，但是v可以修改。这种方法思路上类似引用传参，传入地址，修改地址所指向的具体值","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"}]},{"title":"Golang学习笔记（一）","date":"2018-06-06T16:00:00.000Z","path":"2018/06/07/Golang学习笔记（一）/","text":"研究方向golang区块链以太坊源码以太坊智能合约代币合约共识机制 https://github.com/ethereum/go-ethereum 以太坊 https://github.com/abiosoft/ishell https://github.com/urfave/cli go tool pprof性能监控 分为两方面 1.net/http/pprof 做WEB服务器的性能监控检查服务器状态func main() { go func() { http.ListenAndServe(“localhost:6060”, nil) }() 2.runtime/pprof 做应用程序性能监控 CPU消耗分析func main() { f, err := os.OpenFile(“./tmp/cpu.prof”, os.O_RDWR|os.O_CREATE, 0644) if err != nil { log.Fatal(err) } defer f.Close() pprof.StartCPUProfile(f) defer pprof.StopCPUProfile() 导出prof文件使用 go tool pprof (应用程序) （应用程序的prof文件） 方式来对这个 prof 文件进行分析。 $ go tool pprof HuaRongDao ./tmp/cpu.profEntering interactive mode (type “help” for commands) 官方文档 https://blog.golang.org/profiling-go-programs net/http/pprof和runtime/pprof指的并不是分析WEB服务器性能监控和应用程序性能监控 这两个监控的是一个东西 内容都是一样的只不过是net/http/pprof把监控的内容以WEB的形式展示出来并不是说net/http/pprof是用来监控WEB服务器的性能的跟WEB服务器没有关系 net/http/pprof 只是把 runtime/pprof进行封装了一下实际上调用的还是 runtime/pprof","tags":[{"name":"Golang","slug":"Golang","permalink":"https://joker208.github.io/tags/Golang/"}]},{"title":"C#导出Excel的方法总结","date":"2017-04-11T16:00:00.000Z","path":"2017/04/12/C#导出Excel的方法总结/","text":"最近做了一个有关后台数据的导出功能 趁着这个机会把收集到的有关导出Excel的各种方法总结一下 Npoi导出Excel简介：NPOI 是 POI 项目的 .NET 版本POI是一个开源的Java读写Excel、WORD等微软OLE2组件文档的项目 主要优点：可以实现Excel的导入导出，而且不需要本机上装Office 需要的引用可以在VS的NuGet上直接下载，现在用的版本是2.3.0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758using System;using System.Collections.Generic;using System.Data;using System.IO;using System.Text;using System.Web;using NPOI.SS.UserModel;using NPOI.HSSF.UserModel;/* * / &lt;summary&gt; * / NpoiforExcel 的摘要说明 * / &lt;/summary&gt; */ public class NpoiforExcel &#123; public NpoiforExcel( DataTable dt, string fileName ) &#123; /* 生成Excel */ IWorkbook book = BuildWorkbook( dt ); /* web 下载 */ if ( fileName == &quot;&quot; ) fileName = string.Format( &quot;&#123;0:yyyyMMddHHmmssffff&#125;&quot;, DateTime.Now ); fileName = fileName.Trim(); string ext = Path.GetExtension( fileName ); if ( ext.ToLower() == &quot;.xls&quot; || ext.ToLower() == &quot;.xlsx&quot; ) fileName = fileName.Replace( ext, string.Empty ); HttpResponse httpResponse = HttpContext.Current.Response; httpResponse.Clear(); httpResponse.Buffer = true; httpResponse.Charset = Encoding.UTF8.BodyName; httpResponse.AppendHeader( &quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + fileName + &quot;.xls&quot; ); httpResponse.ContentEncoding = Encoding.UTF8; httpResponse.ContentType = &quot;application/vnd.ms-excel; charset=UTF-8&quot;; book.Write( httpResponse.OutputStream ); httpResponse.End(); &#125; public static HSSFWorkbook BuildWorkbook( DataTable dt ) &#123; HSSFWorkbook book = new HSSFWorkbook(); ISheet sheet = book.CreateSheet( &quot;Sheet1&quot; ); /* Data Rows */ for ( int i = 0; i &lt; dt.Rows.Count; i++ ) &#123; IRow drow = sheet.CreateRow( i ); for ( int j = 0; j &lt; dt.Columns.Count; j++ ) &#123; ICell cell = drow.CreateCell( j, CellType.String ); cell.SetCellValue( dt.Rows[i][j].ToString() ); &#125; &#125; /* 自动列宽 */ for ( int i = 0; i &lt;= dt.Columns.Count; i++ ) sheet.AutoSizeColumn( i, true ); return(book); &#125;&#125; Html导出Excel首先感谢果哥，这个方法从果哥偷学来的︿(￣︶￣)︿ 主要思路是将DataTable数据转换为html格式，然后直接设置为Excel的文件格式下载 下载下来的文件打开会有安全提示，可以忽略 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960using System;using System.Collections.Generic;using System.Web;/* * / &lt;summary&gt; * / htmltoExcel 的摘要说明 * / &lt;/summary&gt; */public class htmltoExcel&#123; public htmltoExcel() &#123; /* * * TODO: 在此处添加构造函数逻辑 * */ &#125; /* * / &lt;summary&gt; * / DataTable 输出成Excel * / &lt;/summary&gt; * / &lt;param name=&quot;dtData&quot;&gt;&lt;/param&gt; * / &lt;param name=&quot;FileName&quot;&gt;&lt;/param&gt; */ public htmltoExcel( System.Data.DataTable dtData, String FileName ) &#123; System.Web.UI.WebControls.GridView dgExport = null; /* 当前对话 */ System.Web.HttpContext curContext = System.Web.HttpContext.Current; /* IO导出并返回excel文件 */ System.IO.StringWriter strWriter = null; System.Web.UI.HtmlTextWriter htmlWriter = null; if ( dtData != null ) &#123; /* 设置编码和附件格式 */ System.Web.HttpUtility.UrlEncode( FileName, System.Text.Encoding.UTF8 ); curContext.Response.AddHeader( &quot;content-disposition&quot;, &quot;attachment;filename=&quot; + System.Web.HttpUtility.UrlEncode( FileName, System.Text.Encoding.UTF8 ) + &quot;.xls&quot; ); curContext.Response.ContentType = &quot;application nd.ms-excel&quot;; curContext.Response.ContentEncoding = System.Text.Encoding.GetEncoding( &quot;UTF-8&quot; ); curContext.Response.Charset = &quot;UTF-8&quot;; /* 导出Excel文件 */ strWriter = new System.IO.StringWriter(); htmlWriter = new System.Web.UI.HtmlTextWriter( strWriter ); /* 要重新定义一个无分页的GridView */ dgExport = new System.Web.UI.WebControls.GridView(); dgExport.DataSource = dtData.DefaultView; dgExport.AllowPaging = false; dgExport.DataBind(); /*下载到客户端 */ dgExport.RenderControl( htmlWriter ); curContext.Response.Write( &quot;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=Content-Type content=\\&quot;text/html; charset=utf-8\\&quot;&gt;&quot; ); curContext.Response.Write( strWriter.ToString() ); curContext.Response.Write( &quot;&lt;/body&gt;&lt;/html&gt;&quot; ); curContext.Response.End(); &#125; &#125;&#125; Xml导出Excel这个方法从大表哥那儿搞来的，表示感谢︿(￣︶￣)︿ 这个导出思路和上面的方法类似，先拼出XML格式，再设置为Excel格式导出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184using System;using System.Collections.Generic;using System.Data;using System.Text;using System.Web;public class ExportOrder&#123; private DataTable datasource; public ExportOrder( DataTable data, string title ) &#123; System.Web.HttpContext curContext = System.Web.HttpContext.Current; if ( data != null ) &#123; datasource = data; /* 设置编码和附件格式 */ System.Web.HttpUtility.UrlEncode( title, System.Text.Encoding.UTF8 ); curContext.Response.AddHeader( &quot;content-disposition&quot;, &quot;attachment;filename=&quot; + System.Web.HttpUtility.UrlEncode( title, System.Text.Encoding.UTF8 ) + &quot;.xls&quot; ); curContext.Response.ContentType = &quot;application nd.ms-excel&quot;; curContext.Response.ContentEncoding = System.Text.Encoding.GetEncoding( &quot;UTF-8&quot; ); curContext.Response.Charset = &quot;UTF-8&quot;; /*下载到客户端 */ curContext.Response.Write( GetExcelString().ToString() ); curContext.Response.End(); &#125; &#125; private StringBuilder GetExcelString() &#123; StringBuilder xmlString = new StringBuilder(); AddHeadFile( xmlString ); AddContentFile( xmlString, datasource ); AddEndFile( xmlString ); return(xmlString); &#125; /* * / &lt;summary&gt; * /写Excel头 * / &lt;/summary&gt; * / &lt;param name=&quot;OutFileContent&quot;&gt;&lt;/param&gt; * / &lt;returns&gt;&lt;/returns&gt; */ private StringBuilder AddHeadFile( StringBuilder OutFileContent ) &#123; OutFileContent.Append( &quot;&lt;?xml version=\\&quot;1.0\\&quot;?&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;?mso-application progid=\\&quot;Excel.Sheet\\&quot;?&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Workbook xmlns=\\&quot;urn:schemas-microsoft-com:office:spreadsheet\\&quot;\\r\\n&quot; ); OutFileContent.Append( &quot; xmlns:o=\\&quot;urn:schemas-microsoft-com:office:office\\&quot;\\r\\n&quot; ); OutFileContent.Append( &quot; xmlns:x=\\&quot;urn:schemas-microsoft-com:office:excel\\&quot;\\r\\n&quot; ); OutFileContent.Append( &quot; xmlns:ss=\\&quot;urn:schemas-microsoft-com:office:spreadsheet\\&quot;\\r\\n&quot; ); OutFileContent.Append( &quot; xmlns:html=\\&quot;http://www.w3.org/TR/REC-html40\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;DocumentProperties xmlns=\\&quot;urn:schemas-microsoft-com:office:office\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Author&gt;panss&lt;/Author&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;LastAuthor&gt;Оґ¶ЁТе&lt;/LastAuthor&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Created&gt;2004-12-31T03:40:31Z&lt;/Created&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Company&gt;Prcedu&lt;/Company&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Version&gt;12.00&lt;/Version&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;/DocumentProperties&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;OfficeDocumentSettings xmlns=\\&quot;urn:schemas-microsoft-com:office:office\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;DownloadComponents/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;LocationOfComponents HRef=\\&quot;file:///F:\\\\Tools\\\\OfficeXP\\\\OfficeXP\\\\\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;/OfficeDocumentSettings&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;ExcelWorkbook xmlns=\\&quot;urn:schemas-microsoft-com:office:excel\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;WindowHeight&gt;9000&lt;/WindowHeight&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;WindowWidth&gt;10620&lt;/WindowWidth&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;WindowTopX&gt;480&lt;/WindowTopX&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;WindowTopY&gt;45&lt;/WindowTopY&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;ProtectStructure&gt;False&lt;/ProtectStructure&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;ProtectWindows&gt;False&lt;/ProtectWindows&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;/ExcelWorkbook&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Styles&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Style ss:ID=\\&quot;Default\\&quot; ss:Name=\\&quot;Normal\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Alignment ss:Vertical=\\&quot;Center\\&quot; /&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Borders/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Font ss:FontName=\\&quot;ЛОМе\\&quot; x:CharSet=\\&quot;134\\&quot; ss:Size=\\&quot;12\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Interior/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;NumberFormat/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Protection/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;/Style&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Style ss:ID=\\&quot;s62\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Alignment ss:Vertical=\\&quot;Center\\&quot; ss:Horizontal=\\&quot;Center\\&quot; ss:WrapText=\\&quot;1\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Font ss:FontName=\\&quot;ЛОМе\\&quot; x:CharSet=\\&quot;134\\&quot; ss:Size=\\&quot;9\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;/Style&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Style ss:ID=\\&quot;s74\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Alignment ss:Horizontal=\\&quot;Center\\&quot; ss:Vertical=\\&quot;Center\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Borders&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Border ss:Position=\\&quot;Bottom\\&quot; ss:LineStyle=\\&quot;Continuous\\&quot; ss:Weight=\\&quot;1\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Border ss:Position=\\&quot;Left\\&quot; ss:LineStyle=\\&quot;Continuous\\&quot; ss:Weight=\\&quot;1\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Border ss:Position=\\&quot;Right\\&quot; ss:LineStyle=\\&quot;Continuous\\&quot; ss:Weight=\\&quot;1\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Border ss:Position=\\&quot;Top\\&quot; ss:LineStyle=\\&quot;Continuous\\&quot; ss:Weight=\\&quot;1\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;/Borders&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Font ss:FontName=\\&quot;ЛОМе\\&quot; x:CharSet=\\&quot;134\\&quot; ss:Size=\\&quot;12\\&quot; ss:Bold=\\&quot;1\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Interior ss:Color=\\&quot;#BFBFBF\\&quot; ss:Pattern=\\&quot;Solid\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;/Style&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;/Styles&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Worksheet ss:Name=\\&quot;Sheet1\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Table ss:ExpandedColumnCount=\\&quot;255\\&quot; x:FullColumns=\\&quot;1\\&quot; \\r\\n&quot; ); OutFileContent.Append( &quot;x:FullRows=\\&quot;1\\&quot; ss:StyleID=\\&quot;s62\\&quot; ss:DefaultColumnWidth=\\&quot;75\\&quot; ss:DefaultRowHeight=\\&quot;20.25\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Column ss:StyleID=\\&quot;s62\\&quot; ss:AutoFitWidth=\\&quot;0\\&quot; ss:Width=\\&quot;112.5\\&quot;/&gt;\\r\\n&quot; ); return(OutFileContent); &#125; /* * / &lt;summary&gt; * / &lt;summary&gt; * / 写表格尾部 * / &lt;/summary&gt; * / &lt;param name=&quot;OutFileContent&quot;&gt;&lt;/param&gt; * / &lt;returns&gt;&lt;/returns&gt; */ private StringBuilder AddEndFile( StringBuilder OutFileContent ) &#123; OutFileContent.Append( &quot;&lt;/Table&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;WorksheetOptions xmlns=\\&quot;urn:schemas-microsoft-com:office:excel\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Unsynced/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Print&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;ValidPrinterInfo/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;PaperSizeIndex&gt;9&lt;/PaperSizeIndex&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;HorizontalResolution&gt;600&lt;/HorizontalResolution&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;VerticalResolution&gt;0&lt;/VerticalResolution&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;/Print&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Selected/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Panes&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Pane&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;Number&gt;3&lt;/Number&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;RangeSelection&gt;R1:R65536&lt;/RangeSelection&gt;\\r\\n&quot; ); OutFileContent.Append( &quot; &lt;/Pane&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;/Panes&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;ProtectObjects&gt;False&lt;/ProtectObjects&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;ProtectScenarios&gt;False&lt;/ProtectScenarios&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;/WorksheetOptions&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;/Worksheet&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Worksheet ss:Name=\\&quot;Sheet2\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Table ss:ExpandedColumnCount=\\&quot;1\\&quot; ss:ExpandedRowCount=\\&quot;1\\&quot; x:FullColumns=\\&quot;1\\&quot;\\r\\n&quot; ); OutFileContent.Append( &quot;x:FullRows=\\&quot;1\\&quot; ss:DefaultColumnWidth=\\&quot;54\\&quot; ss:DefaultRowHeight=\\&quot;14.25\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Row ss:AutoFitHeight=\\&quot;0\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;/Table&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;WorksheetOptions xmlns=\\&quot;urn:schemas-microsoft-com:office:excel\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Unsynced/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;ProtectObjects&gt;False&lt;/ProtectObjects&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;ProtectScenarios&gt;False&lt;/ProtectScenarios&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;/WorksheetOptions&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;/Worksheet&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Worksheet ss:Name=\\&quot;Sheet3\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Table ss:ExpandedColumnCount=\\&quot;1\\&quot; ss:ExpandedRowCount=\\&quot;1\\&quot; x:FullColumns=\\&quot;1\\&quot;\\r\\n&quot; ); OutFileContent.Append( &quot;x:FullRows=\\&quot;1\\&quot; ss:DefaultColumnWidth=\\&quot;54\\&quot; ss:DefaultRowHeight=\\&quot;14.25\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Row ss:AutoFitHeight=\\&quot;0\\&quot;/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;/Table&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;WorksheetOptions xmlns=\\&quot;urn:schemas-microsoft-com:office:excel\\&quot;&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;Unsynced/&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;ProtectObjects&gt;False&lt;/ProtectObjects&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;ProtectScenarios&gt;False&lt;/ProtectScenarios&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;/WorksheetOptions&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;/Worksheet&gt;\\r\\n&quot; ); OutFileContent.Append( &quot;&lt;/Workbook&gt;\\r\\n&quot; ); return(OutFileContent); &#125; private StringBuilder AddContentFile( StringBuilder OutFileContent, DataTable ds ) &#123; /* 写列头 */ OutFileContent.Append( &quot;&lt;Row ss:AutoFitHeight=\\&quot;0\\&quot;&gt;&quot; ); for ( int i = 0; i &lt; ds.Columns.Count; i++ ) &#123; OutFileContent.Append( &quot;&lt;Cell&gt;&lt;Data ss:Type=\\&quot;String\\&quot;&gt;&quot; + ds.Columns[i].ColumnName + &quot;&lt;/Data&gt;&lt;/Cell&gt;&quot; ); &#125; OutFileContent.Append( &quot;&lt;/Row&gt;&quot; ); /* 写内容 */ foreach ( DataRow row in ds.Rows ) &#123; OutFileContent.Append( &quot;&lt;Row ss:AutoFitHeight=\\&quot;0\\&quot;&gt;&quot; ); for ( int i = 0; i &lt; ds.Columns.Count; i++ ) &#123; OutFileContent.Append( &quot;&lt;Cell&gt;&lt;Data ss:Type=\\&quot;String\\&quot;&gt;&quot; + row[i].ToString() + &quot;&lt;/Data&gt;&lt;/Cell&gt;&quot; ); &#125; OutFileContent.Append( &quot;&lt;/Row&gt;&quot; ); &#125; return(OutFileContent); &#125;&#125; 另外还知道的两个方法openxml和EPPLUS","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://joker208.github.io/tags/设计模式/"}]},{"title":"设计模式初探之单例模式","date":"2017-03-16T06:02:01.000Z","path":"2017/03/16/设计模式初探之单例模式/","text":"单例模式 定义 保证一个类仅有一个实例，并提供一个访问它的全局访问点 目的 单例模式的目的就是要控制特定的类只产生一个对象，当然也允许在一定情况下灵活的改变对象的个数 特点 单例类只能有一个实例 单例类必须自己创建自己的唯一实例 单例类必须给所有其它对象提供这一实例 应用 每台计算机可以有若干个打印机，但只能有一个Printer Spooler，避免两个打印作业同时输出到打印机 一个具有自动编号主键的表可以有多个用户同时使用，但数据库中只能有一个地方分配下一个主键编号，否则会出现主键重复 下面的是C#中单例模式的三种写法 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Singleton1&#123; private static Singleton1 _instance = null; private Singleton1() &#123; &#125; public static Singleton1 CreateInstance() &#123; if ( _instance == null ) &#123; _instance = new Singleton1(); &#125; return(_instance); &#125;&#125;public class Singleton2&#123; private volatile static Singleton2 _instance = null; private static readonly object lockHelper = new object(); private Singleton2() &#123; &#125; public static Singleton2 CreateInstance() &#123; if ( _instance == null ) &#123; lock ( lockHelper ) &#123; if ( _instance == null ) _instance = new Singleton2(); &#125; &#125; return(_instance); &#125;&#125;sealed class Singleton3&#123; private Singleton3() &#123; &#125; public static readonly Singleton3 instance = new Singleton3();&#125; 其中第三种实现方法为C#中独有的 使得代码减少了许多，同时也解决了线程问题带来的性能上损失 它的工作原理又是什么呢？ Singleton类被声明为sealed，以此保证它自己不会被继承其次没有了Instance的方法，将原来_instance成员变量变成public readonly，并在声明时被初始化通过这些改变，我们确实得到了Singleton的模式，原因是在JIT的处理过程中如果类中的static属性被任何方法使用时，.NET Framework将对这个属性进行初始化于是在初始化Instance属性的同时Singleton类实例得以创建和装载而私有的构造函数和readonly(只读)保证了Singleton不会被再次实例化这正是Singleton设计模式的意图 不过这也带来了一些问题，比如无法继承，实例在程序一运行就被初始化，无法实现延迟初始化等 单利模式就先介绍到这里，以后还会继续补充，希望大家多提意见ヽ(￣ω￣(￣ω￣〃)ゝ 文章参考 《深入浅出设计模式》 从c#的singleton设计模式 c#设计模式-单例模式","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://joker208.github.io/tags/设计模式/"}]},{"title":".NET验证码","date":"2017-03-01T07:56:27.000Z","path":"2017/03/01/net验证码/","text":"网上的验证码总是不太好用 最近公司做的一个网站被用作短信轰炸 需要加上图片验证码 分享一下.NET验证码的Demo 也算做个备份，(๑•̀ㅂ•́)و✧ validatecode.aspx1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;%@ WebHandler Language=&quot;C#&quot; Class=&quot;validatecode&quot; %&gt;using System;using System.Web;using System.Drawing;public class validatecode : IHttpHandler, System.Web.SessionState.IRequiresSessionState&#123; public string charSet = &quot;0,1,2,3,4,5,6,8,9,A,B,C,D,E,F,G,H,J,K,M,N,P,R,S,U,W,X,Y&quot;; public void ProcessRequest(HttpContext context) &#123; string validateCode = CreateRandomCode(4); context.Session[&quot;ValidateCode&quot;] = validateCode; context.Response.SetCookie(new HttpCookie(&quot;ValidateCode&quot;, validateCode)); CreateImage(validateCode, context); &#125; public bool IsReusable &#123; get &#123; return false; &#125; &#125; /// &lt;summary&gt; /// 生成验证码 /// &lt;param name=&quot;n&quot;&gt;位数&lt;/param&gt; /// &lt;returns&gt;验证码字符串&lt;/returns&gt; private string CreateRandomCode(int n) &#123; string[] CharArray = charSet.Split(&apos;,&apos;); string randomCode = &quot;&quot;; int temp = -1; Random rand = new Random(); for (int i = 0; i &lt; n; i++) &#123; if (temp != -1) &#123; rand = new Random(i * temp * ((int)DateTime.Now.Ticks)); &#125; int t = rand.Next(CharArray.Length - 1); if (temp == t) &#123; return CreateRandomCode(n); &#125; temp = t; randomCode += CharArray[t]; &#125; return randomCode; &#125; private void CreateImage(string checkCode, HttpContext context) &#123; int iwidth = (int)(checkCode.Length * 13); System.Drawing.Bitmap image = new System.Drawing.Bitmap(iwidth, 23); Graphics g = Graphics.FromImage(image); Font f = new System.Drawing.Font(&quot;Arial&quot;, 12, (System.Drawing.FontStyle.Italic | System.Drawing.FontStyle.Bold)); // 前景色 Brush b = new System.Drawing.SolidBrush(Color.Black); // 背景色 g.Clear(Color.White); // 填充文字 g.DrawString(checkCode, f, b, 0, 1); // 随机线条 Pen linePen = new Pen(Color.Gray, 0); Random rand = new Random(); for (int i = 0; i &lt; 5; i++) &#123; int x1 = rand.Next(image.Width); int y1 = rand.Next(image.Height); int x2 = rand.Next(image.Width); int y2 = rand.Next(image.Height); g.DrawLine(linePen, x1, y1, x2, y2); &#125; // 随机点 for (int i = 0; i &lt; 30; i++) &#123; int x = rand.Next(image.Width); int y = rand.Next(image.Height); image.SetPixel(x, y, Color.Gray); &#125; // 边框 g.DrawRectangle(new Pen(Color.Gray), 0, 0, image.Width - 1, image.Height - 1); // 输出图片 System.IO.MemoryStream ms = new System.IO.MemoryStream(); image.Save(ms, System.Drawing.Imaging.ImageFormat.Jpeg); context.Response.ClearContent(); context.Response.ContentType = &quot;image/Jpeg&quot;; context.Response.BinaryWrite(ms.ToArray()); g.Dispose(); image.Dispose(); &#125;&#125; index.aspx123456789101112131415161718192021222324&lt;span&gt;验证码：&lt;/span&gt;&lt;input type=&quot;text&quot; id=&quot;input&quot; /&gt;&lt;a href=&quot;javascript:;&quot;&gt; &lt;img src=&quot;validatecode.ashx&quot; id=&quot;codeImg&quot; onclick=&quot;this.src=&apos;validatecode.ashx?time=&apos;+new Date().getTime()&quot;&gt;&lt;/a&gt;&lt;a class=&quot;submit&quot;&gt;提交&lt;/a&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(&quot;.submit&quot;).click(function()&#123; if ($(&quot;#input&quot;).val().toUpperCase().trim() != GetCookie(&quot;ValidateCode&quot;)) &#123; $(&quot;#codeImg&quot;).attr(&quot;src&quot;, &quot;validatecode.ashx?time=&quot; + new Date().getTime()); alert(&quot;验证码错误&quot;); return; &#125; else &#123; alert(&quot;验证码正确&quot;); return; &#125; &#125;) function GetCookie(sMainName) &#123; var re = new RegExp((sMainName + &quot;=([^;$]*)&quot;), &quot;i&quot;); return re.test(unescape(document.cookie)) ? RegExp[&quot;$1&quot;] : &quot;&quot;; &#125;&lt;/script&gt;","tags":[{"name":".NET","slug":"NET","permalink":"https://joker208.github.io/tags/NET/"},{"name":"验证码","slug":"验证码","permalink":"https://joker208.github.io/tags/验证码/"}]},{"title":"设计模式初探","date":"2017-02-21T10:03:54.000Z","path":"2017/02/21/设计模式初探/","text":"前言刚到公司时 我就向我们的主管果哥问过一个问题 从我这样的初级开发到您这样的开发大牛都需要学习些什么？ 是需要知道比如说clr这些底层的东西吗？ 果哥说，你先去看看设计模式吧 于是果断开始研究“设计模式” 先从基本的概念说起~ 模式“设计模式”的概念是从“模式”这个词引用过来的 “模式”一次最早应用于建筑学 Christopher Alexander，哈佛大学建筑学博士他和他的团队用20年的时间对住宅和周边环境进行研究发现人们对舒适住宅和城市环境存在一些共同的认同规律并把这些认同规律归纳为253个模式 模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案 设计模式GoF(Gang of Four)(Erich Gamma、Richard Helm、Ralph Johnson、John Vlissides)将模式的概念引入软件工程领域，标志着软件模式的诞生。 设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结使用设计模式是为了可重用代码、让代码共容易被他人理解并且保证代码可靠性","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://joker208.github.io/tags/设计模式/"}]},{"title":"设计模式初探之工厂模式","date":"2017-02-21T10:03:54.000Z","path":"2017/02/21/设计模式初探之工厂模式/","text":"设计模式是很抽象的东西 是各位编程届前辈不断实践总结，不断探索出来的 是规则 是经验 太抽象的东西往往不容易理解 那么就用简单的事例来把抽象的东西具体化 故事要从很久很久以前说起 (￣o￣) . z Z 话说有一个暴发户他家有三辆汽车——Benz 奔驰、 Bmw 宝马、 Audi 奥迪还雇了司机为他开车不过，暴发户坐车时总是怪怪的上 Benz 车后跟司机说“开奔驰车！”坐上 Bmw 后他说“开宝马车！ ”坐上 Audi 说“开奥迪车！ ”你一定说：这人有病！直接说开车不就行了？！而当把这个暴发户的行为放到我们程序设计中来时会发现这是一个普遍存在的现象 用代码表现出来就是这样色儿地 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* 抽象产品角色 */public interface Car &#123; void drive();&#125;/* 具体产品角色 */public class Benz : Car &#123; public void drive() &#123; Console.WriteLine( &quot;Driving Benz&quot; ); &#125;&#125;public class Bmw : Car &#123; public void drive() &#123; Console.WriteLine( &quot;Driving Bmw&quot; ); &#125;&#125;public class Audi : Car &#123; public void drive() &#123; Console.WriteLine( &quot;Driving Audi&quot; ); &#125;&#125;/* 工厂类角色 */public class Driver &#123; public static Car driverCar( String s ) &#123; if ( s == &quot;Benz&quot; ) return(new Benz() ); else if ( s == &quot;Bmw&quot; ) return(new Bmw() ); else if ( s == &quot;Audi&quot; ) return(new Audi() ); else throw new Exception(); &#125;&#125;class Program&#123; static void Main( string[] args ) &#123; try &#123; /* 告诉司机今天坐奔驰 */ Car car = Driver.driverCar( &quot;Benz&quot; ); /*下命令：开车 */ car.drive(); &#125; catch ( Exception e ) &#123; Console.WriteLine( e ); &#125; finally &#123; Console.ReadKey(); &#125; &#125;&#125; 工厂模式工厂模式主要是为创建对象提供过渡接口 以便将创建对象的具体过程屏蔽隔离起来 达到提高灵活性的目的 工厂模式可分为三种分别是 简单工厂模式 工厂方法模式 抽象工厂模式 简单工厂模式 定义 简单工厂模式又称静态工厂方法模式 定义一个用于创建对象的接口 组成 工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑 抽象产品角色：它一般是具体产品继承的父类或者实现的接口 具体产品角色：工厂类所创建的对象就是此角色的实例 缺陷分析 对产品部分来说，它是符合开闭原则的 但是工厂部分好像不太理想，因为每增加一辆车，都要在工厂类中增加相应的业务逻辑或者判断逻辑，这显然是违背开闭原则的 可想而知对于新产品的加入，工厂类是很被动的 工厂方法模式我们来继续讲故事 暴发户生意越做越大，自己的爱车也越来越多。这可苦了那位司机师傅了，什么车它都要记得，维护，都要经过他来使用 于是暴发户同情他说：看你跟我这么多年的份上，以后你不用这么辛苦了，我给你分配几个人手，你只管管好他们就行了！ 于是，工厂方法模式的管理出现了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* 抽象产品角色 */public interface Car&#123; void drive();&#125;/* 具体产品角色 */public class Benz : Car&#123; public void drive() &#123; Console.WriteLine( &quot;Driving Benz&quot; ); &#125;&#125;public class Bmw : Car&#123; public void drive() &#123; Console.WriteLine( &quot;Driving Bmw&quot; ); &#125;&#125;public class Audi : Car&#123; public void drive() &#123; Console.WriteLine( &quot;Driving Audi&quot; ); &#125;&#125;/* 抽象工厂角色 */public interface Driver &#123; Car driverCar();&#125;public class BenzDriver : Driver &#123; public Car driverCar() &#123; return(new Benz() ); &#125;&#125;public class BmwDriver : Driver &#123; public Car driverCar() &#123; return(new Bmw() ); &#125;&#125;public class AudiDriver : Driver &#123; public Car driverCar() &#123; return(new Audi() ); &#125;&#125;class Program&#123; static void Main( string[] args ) &#123; try &#123; Driver driver = new BenzDriver(); /* 告诉司机坐奔驰 */ Car car = driver.driverCar(); /*下命令 开车 */ car.drive(); &#125; catch ( Exception e ) &#123; Console.WriteLine( e ); &#125; finally &#123; Console.ReadKey(); &#125; &#125;&#125; 目的 工厂方法模式去掉了简单工厂模式中工厂方法的静态属性，使得它可以被子类继承 这样在简单工厂模式里集中在工厂方法上的压力可以由工厂方法模式里不同的工厂子类来分担 组成 抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关 具体工厂角色：它含有和具体业务逻辑有关的代码，由应用程序调用以创建对应的具体产品的对象 抽象产品角色：它是具体产品继承的父类或者是实现的接口 具体产品角色：具体工厂角色所创建的对象就是此角色的实例 适用范围 当客户程序不需要知道要使用对象的创建过程 客户程序使用的对象存在变动的可能，或者根本就不知道使用哪一个具体的对象 抽象工厂模式 目的 给客户端提供一个接口，可以创建多个产品族中的产品对象，而且使用抽象工厂模式还要满足一下条件： 1) 系统中有多个产品族，而系统一次只可能消费其中一族产品 2) 同属于同一个产品族的产品以其使用 组成 抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关 具体工厂角色：它含有和具体业务逻辑有关的代码，由应用程序调用以创建对应的具体产品的对象 抽象产品角色：它是具体产品继承的父类或者是实现的接口 具体产品角色：具体工厂角色所创建的对象就是此角色的实例 工厂模式区别简单工厂模式： 用来生产同一等级结构中的任意产品（对于增加新的产品，无能为力） 工厂方法模式：用来生产同一等级结构中的固定产品（支持增加任意产品） 抽象工厂模式 ：用来生产不同产品族的全部产品（对于增加新的产品，无能为力；支持增加产品族） 参考文章 《深入浅出设计模式》","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://joker208.github.io/tags/设计模式/"}]},{"title":"你见过最不求上进的人是什么样子？","date":"2017-02-20T14:51:02.000Z","path":"2017/02/20/你见过最不求上进的人是什么样子？/","text":"今天在知乎看到@布衣卿关于这个问题的回答 我想拿过来放在首页，时时惊醒 共勉我见过的最不求上进的人，既不是学霸又不全算学渣。 他们课听的迷迷糊糊，作业做一些抄一些。 想逃课又心存顾忌，行为也不公开对抗规范纪律。 为现状焦虑，又没有毅力践行决心去改变自己。 三分钟热度，时常憎恶自己的不争气，坚持最多的事情就是坚持不下去。 对感情抱有渴望，又疲于用心追寻与经营。 对曾经的珍视点到即止，直到渐渐松手，淡漠又疏离。 尚未拥有百毒不侵的内心，却提前丧失了热泪盈眶的能力。 偶尔闲暇时间想约人一起，更多时候无人可约就一个人且趴且趟窝上一天。 本想在有限的生命里体验很多种生活，却只会把同样的日子机械重复很多年。 刷着知乎想窥见别人的生活寻求激励，关闭客户端还是该干嘛干嘛去。 终日混迹社交网络，脸色蜡黄地对着手机和电脑的冷光屏，可以说上几句话的人却寥寥无几。 不曾经历过真正沧桑，却还失守了最后一点少年意气。 他们以最普通的身份埋没在人群中，却过着最最煎熬的日子。 文章来源： 你见过最不求上进的人是什么样子？ - 回答作者: 布衣卿","tags":[{"name":"鸡汤","slug":"鸡汤","permalink":"https://joker208.github.io/tags/鸡汤/"}]},{"title":"Hashtable实用案例","date":"2017-02-16T08:46:33.000Z","path":"2017/02/16/Hashtable实用案例/","text":"今天在翻看以前的项目的时候发现了项目中对Hashtable的使用 借这个机会巩固一下Hashtable的知识 Hashtable是非泛型的集合，所以在检索和存储值类型时通常会发生装箱与拆箱的操作 当把某个元素添加到 Hashtable 时，将根据键的哈希代码将该元素放入存储桶中，由于是散列算法所以会出现一个哈希函数能够为两个不同的键生成相同的哈希代码，该键的后续查找将使用键的哈希代码只在一个特定存储桶中搜索，这将大大减少为查找一个元素所需的键比较的次数 Hashtable 的加载因子确定元素与Hashtable 可拥有的元素数的最大比率。加载因子越小，平均查找速度越快，但消耗的内存也增加。默认的加载因子 0.72通常提供速度和大小之间的最佳平衡。当创建 Hashtable 时，也可以指定其他加载因子 元素总量/ Hashtable 可拥有的元素数=加载因子 当向 Hashtable 添加元素时，Hashtable 的实际加载因子将增加。当实际加载因子达到指定的加载因子时，Hashtable 中存储桶的数目自动增加到大于当前 Hashtable 存储桶数两倍的最小素数 虽然Hash具有O(1)的数据检索效率，但它空间开销却通常很大，是以空间换取时间。所以Hashtable适用于读取操作频繁，写入操作很少的操作类型 主要记录一下使用的场景以及方法，为以后作参照 根据其查找效率高的特点用作比较去重 1234567891011121314DataSet ds = app.Ds;Hashtable htData = new Hashtable();foreach (DataRow row in ds.Tables[0].Rows)&#123; string title = row[&quot;Title&quot;].ToString(); if (htData.Contains(title)) &#123; row.Delete(); &#125; else &#123; htData.Add(title, &quot;&quot;); &#125;&#125; 文章参考 Hashtable_百度百科 hashtable详细介绍 C#中HashTable的用法","tags":[{"name":"Hashtable","slug":"Hashtable","permalink":"https://joker208.github.io/tags/Hashtable/"}]},{"title":"jQuery实现简单分页","date":"2017-02-16T07:17:54.000Z","path":"2017/02/16/jQuery实现简单分页/","text":"今天做的一个首页下方的列表需要加一个分页功能 不需要特别多功能，只要有页数就行，网上的分页插件功能太多反倒累赘 于是就自己写了一个简单的分页控件 随便练习一下jQuery 贴代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&lt;li&gt;4&lt;/li&gt;&lt;li&gt;5&lt;/li&gt;&lt;li&gt;6&lt;/li&gt;&lt;li&gt;7&lt;/li&gt;&lt;li&gt;8&lt;/li&gt;&lt;li&gt;9&lt;/li&gt;&lt;li&gt;10&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;fanye&quot;&gt;&lt;a class=&quot;up&quot; href=&quot;#&quot;&gt;upup&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a class=&quot;down&quot; href=&quot;#&quot;&gt;downdown&lt;/a&gt;&lt;/div&gt;&lt;script src=&quot;http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&quot;ul li&quot;).hide(); $(&quot;ul li:lt(4)&quot;).show(); var nowPage=1;//当前页 var countRecord=$(&quot;ul li&quot;).length;//总记录数 if(countRecord&lt;5) &#123; $(&quot;.fanye a&quot;).hide(); &#125; var countPage=Math.ceil(countRecord/4); if(nowPage==1)&#123;$(&quot;.up&quot;).attr(&quot;style&quot;,&quot;visibility:hidden;&quot;);&#125; $(&quot;.fanye a&quot;).click(function()&#123; var classValue=$(this).attr(&quot;class&quot;); if(&quot;up&quot;==classValue)&#123; if(nowPage&gt;1)&#123; nowPage--; &#125; &#125;else if(&quot;down&quot;==classValue)&#123; if(nowPage&lt;countPage)&#123; nowPage++; &#125; &#125; if(nowPage==1)&#123;$(&quot;.up&quot;).attr(&quot;style&quot;,&quot;visibility:hidden;&quot;);&#125;else&#123;$(&quot;.up&quot;).attr(&quot;style&quot;,&quot;visibility:visible;&quot;);&#125; if(nowPage==countPage)&#123;$(&quot;.down&quot;).attr(&quot;style&quot;,&quot;visibility:hidden;&quot;);&#125;else&#123;$(&quot;.down&quot;).attr(&quot;style&quot;,&quot;visibility:visible;&quot;);&#125; startIndex=(nowPage-1)*4+1;//获取每页开始记录数 endIndex=nowPage*4;//获取每页结束记录数 $(&quot;ul li:gt(&quot;+(startIndex-1)+&quot;)&quot;).show(); $(&quot;ul li:lt(&quot;+(endIndex-1)+&quot;)&quot;).show(); //隐藏操作 //设置隐藏超出页数之外的数据 $(&quot;ul li:lt(&quot;+(startIndex-1)+&quot;)&quot;).css(&quot;display&quot;,&quot;none&quot;); $(&quot;ul li:gt(&quot;+(endIndex-1)+&quot;)&quot;).css(&quot;display&quot;,&quot;none&quot;); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"前端","slug":"前端","permalink":"https://joker208.github.io/tags/前端/"},{"name":"jQuery","slug":"jQuery","permalink":"https://joker208.github.io/tags/jQuery/"},{"name":"分页","slug":"分页","permalink":"https://joker208.github.io/tags/分页/"}]},{"title":".NET发送邮件","date":"2017-02-15T09:36:00.000Z","path":"2017/02/15/dot NET发送邮件/","text":"分享一个.NET后台发送邮件的方法 Demo如下 这个Demo的使用情景是 网站用户修改密码时的绑定邮箱验证 123456789101112131415161718192021222324252627/// &lt;summary&gt;/// 发送邮件/// &lt;/summary&gt;/// &lt;param name=&quot;Email&quot;&gt;用户邮箱地址&lt;/param&gt;/// &lt;param name=&quot;RanDom&quot;&gt;随机验证码&lt;/param&gt;/// &lt;param name=&quot;Name&quot;&gt;用户名&lt;/param&gt;public static void SendEmail(string Email, string RanDom, string Name)&#123; MailMessage mail = new MailMessage(); mail.To.Add(new MailAddress(Email)); mail.Subject = &quot;邮件标题&quot;; mail.SubjectEncoding = System.Text.Encoding.UTF8; mail.Body = &quot;尊敬的用户:&quot; + Name + &quot;。修改密码给你发的验证码是：&quot; + RanDom + &quot;.该验证码有效时间为30分钟，请注意自己的帐号安全，不要外泄密码！！&quot;; mail.BodyEncoding = System.Text.Encoding.UTF8; mail.IsBodyHtml = true; mail.Priority = MailPriority.High; SmtpClient smtpclient = new SmtpClient(); smtpclient.UseDefaultCredentials = true; string EmailClass = Email.Substring(Email.LastIndexOf(&apos;@&apos;)); smtpclient.Host = &quot;smtp&quot; + EmailClass; mail.From = new MailAddress(&quot;发送邮件的邮箱地址&quot;); smtpclient.Credentials = new System.Net.NetworkCredential(&quot;发送邮件的邮箱地址&quot;, &quot;密码&quot;); smtpclient.Send(mail);&#125;","tags":[{"name":".NET","slug":"NET","permalink":"https://joker208.github.io/tags/NET/"},{"name":"邮件","slug":"邮件","permalink":"https://joker208.github.io/tags/邮件/"}]},{"title":"CarouFredSel插件实现图片轮播","date":"2017-02-15T08:17:48.000Z","path":"2017/02/15/CarouFredSel插件实现鼠标移入停止/","text":"公司做北大的一个网站 里面有一个轮播效果 使用了CarouFredSel插件来实现 借这个机会好好来研究一下这个插件 先附上Demo 1234567891011121314151617&lt;ul id=&quot;time_ul&quot;&gt; &lt;li class=&quot;time_li&quot; style=&quot;height:398px;width:400px;&quot;&gt; &lt;div class=&quot;zhanlan_a&quot;&gt; &lt;img class=&quot;zh_pic&quot; src=&quot;../upload/images/&lt;%=pic %&gt;&quot;&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;time_li&quot; style=&quot;height:398px;width:400px;&quot;&gt; &lt;div class=&quot;zhanlan_a&quot;&gt; &lt;img class=&quot;zh_pic&quot; src=&quot;../upload/images/&lt;%=pic %&gt;&quot;&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;time_li&quot; style=&quot;height:398px;width:400px;&quot;&gt; &lt;div class=&quot;zhanlan_a&quot;&gt; &lt;img class=&quot;zh_pic&quot; src=&quot;../upload/images/&lt;%=pic %&gt;&quot;&gt; &lt;/div&gt; &lt;/li&gt;&lt;/ul&gt; 1234567891011121314151617&lt;script type=&quot;text/javascript&quot;&gt;$(&apos;#time_ul&apos;).carouFredSel(&#123; auto:true, direction: &apos;up&apos;, items: &#123; visible: 1, height: 398 &#125;, scroll: &#123; items:1, duration: 2000, timeoutDuration: 2500, pauseOnHover: true &#125;, pagination: &apos;#paginations&apos; &#125;);&lt;/script&gt; CarouFredSel的一些重要参数说明circular true 循环模式，true为无限循环，false为单轮循环。 infinite true 是否启用循环，默认起用。当circular设置为false的时候，再把infinite设置为false，就可以关闭循环 direction “left” 滚动方向，可选值：”right”, “left”, “up” , “down” width null 内容的宽度，如果为null，宽度自动计算 height null 内容的高度，如果为null，高度自动计算 padding 0 内容区域的padding items 5 显示个数。默认显示5个 scroll 默认等于显示的个数 一次滚动个数 auto true 是否自动播放。设置成false，不自动播放 prev null 指定某一元素控制内容向前 next null 指定某一元素控制内容向后 (“▔□▔)/(“▔□▔)/(“▔□▔)/ 另外，还学了一招–去除轮播效果 $(&apos;#time_ul&apos;).trigger(&apos;destroy&apos;);","tags":[{"name":"前端","slug":"前端","permalink":"https://joker208.github.io/tags/前端/"},{"name":"CarouFredSel","slug":"CarouFredSel","permalink":"https://joker208.github.io/tags/CarouFredSel/"}]},{"title":"图片外加a标签导致图片无法显示完整","date":"2017-02-15T07:19:05.000Z","path":"2017/02/15/前端小技巧/","text":"在公司主要做网站后端开发 不可避免的会用到前端的东西 正巧公司制作里有位大腿 没事多抱抱（@￣︶￣@） 最近就遇到问题了 问题描述： 当给图片添加链接的时候，我会用一个a标签来包裹img标签 但是这样会导致图片无法完全显示 &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;&quot;&gt;&lt;/a&gt; 解决方法： 123&lt;a style=&quot;display:block;width:100%;height:100%;&quot; href=&quot;#&quot;&gt;&lt;img src=&quot;&quot;&gt;&lt;/a&gt; 开发这一行注重经验，多积累，多整理，争取早日变成大腿","tags":[{"name":"前端","slug":"前端","permalink":"https://joker208.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"https://joker208.github.io/tags/css/"}]},{"title":"Python学习笔记（一）","date":"2016-12-16T07:08:21.000Z","path":"2016/12/16/Python学习笔记（一）/","text":"数据结构 list tuple dict set list 定义 用中括号定义 可以是空的 可以存在不同数据类型 访问 index索引值（注意不要越界） 索引值可为负数（倒数） 添加元素 append()添加到尾部 insert(value,index)添加到指定位置 删除元素 pop()删除尾部元素 pop(index) 可以替换元素 L[index]=value Tuple 定义 用小括号定义 可以是空 可以存在不同数据类型 不能重新赋值替换 创建单元素时要注意t=(1,)防止小括号单值歧义 tuple的不可变指的是指针指向位置的不可变，当包含list时，list中的元素可以改变 Dict 定义 用花括号定义 格式为Key-Value键值对，类似于HashMap 添加 可以直接通过键值对方式添加dict中的元素 访问 Key键(不可重复)访问( 字符串、整型、浮点型和元组tuple都可以作为dict的key ) 判断是否存在用 in 特点 1.查找速度快，以空间换时间 2.无序 合并 1234567891011121314&gt;&gt;&gt; d1 = &#123;&apos;mike&apos;:12, &apos;jack&apos;:19&#125;&gt;&gt;&gt; d2 = &#123;&apos;jone&apos;:22, &apos;ivy&apos;:17&#125;&gt;&gt;&gt; dMerge = dict(d1.items() + d2.items())&gt;&gt;&gt; print dMerge&#123;&apos;mike&apos;: 12, &apos;jack&apos;: 19, &apos;jone&apos;: 22, &apos;ivy&apos;: 17&#125;&gt;&gt;&gt; dMerge2 = dict(d1, **d2)&gt;&gt;&gt; print dMerge2&#123;&apos;mike&apos;: 12, &apos;jack&apos;: 19, &apos;jone&apos;: 22, &apos;ivy&apos;: 17&#125;&gt;&gt;&gt; dMerge3 = dict(d1)&gt;&gt;&gt; dMerge3.update(d2)&gt;&gt;&gt; print dMerge&#123;&apos;mike&apos;: 12, &apos;jack&apos;: 19, &apos;jone&apos;: 22, &apos;ivy&apos;: 17&#125; set 定义 set([]) 没有value值的dict 元素无序且不可重复 访问 只能查看某个元素是否在这个集合里面(in) 大小写敏感 操作 add() remove() 多用于判断一个元素是否在一些不同的条件内符合","tags":[{"name":"Python","slug":"Python","permalink":"https://joker208.github.io/tags/Python/"}]},{"title":"js天气插件","date":"2016-10-28T08:50:35.000Z","path":"2016/10/28/js天气插件/","text":"曾子曰：“吾日三省吾身——为人谋而不忠乎？与朋友交而不信乎？传不习乎？” 自从博客创建起来以后就没有再更新过 想来也是十分惭愧 工作这么长时间积攒了不少值得记录的东西 心里也一直想着要坚持更新才行 看来还是是懒 选择来到大城市就是为了能一直鞭策自己不断进步 但是一稳定下来就不想努力了 以后还是要日省吾身，保持一颗拼搏的心。 进入正题 前段时间一个网站项目里要加入天气插件 由于是定制化的页面 网上现有的插件都没法直接用 于是找了一个ajax直接获取天气数据的方法 前端代码 12&lt;div id=&quot;location&quot;&gt;&lt;/div&gt;&lt;div id=&quot;weather&quot;&gt;&lt;/div&gt; js代码 12345678910111213141516var cityUrl = &apos;http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=js&apos;;//获取ip所在地区$.getScript(cityUrl, function (script, textStatus, jqXHR) &#123;var citytq = remote_ip_info.city;// 获取城市var url = &quot;http://php.weather.sina.com.cn/iframe/index/w_cl.php?code=js&amp;city=&quot; + citytq + &quot;&amp;day=0&amp;dfc=3&quot;;//sina提供的天气接口$.ajax(&#123; url: url, dataType: &quot;script&quot;, scriptCharset: &quot;gbk&quot;, success: function (data) &#123; var _w = window.SWther.w[citytq][0]; var tq = _w.s1 + &quot; &quot; + _w.t1 + &quot;℃～&quot; + _w.t2 + &quot;℃ &quot;; $(&apos;#location&apos;).html(citytq + &apos;地区：&apos;); $(&apos;#weather&apos;).html(tq); &#125; &#125;); &#125;); 说明 在上段代码中的url里，将变量citytq赋值为北京：var url = &quot;http://php.weather.sina.com.cn/iframe/index/w_cl.php?code=js&amp;city=北京&amp;day=0&amp;dfc=3&quot;; 可获得如下数据：(function(){var w=[];w[&#39;北京&#39;]=[{s1:&#39;晴&#39;,s2:&#39;晴&#39;,f1:&#39;qing&#39;,f2:&#39;qing&#39;,t1:&#39;13&#39;,t2:&#39;2&#39;,p1:&#39;3-4&#39;,p2:&#39;≤3&#39;,d1:&#39;北风&#39;,d2:&#39;无持续风向&#39;}];var add={now:&#39;2016-10-28 20:21:07&#39;,time:&#39;1477657267&#39;,update:&#39;北京时间10月28日07:58更新&#39;,error:&#39;0&#39;,total:&#39;1&#39;};window.SWther={w:w,add:add};})();//0","tags":[{"name":"js","slug":"js","permalink":"https://joker208.github.io/tags/js/"},{"name":"天气插件","slug":"天气插件","permalink":"https://joker208.github.io/tags/天气插件/"}]},{"title":"绝命毒师影评","date":"2016-08-15T06:25:08.000Z","path":"2016/08/15/绝命毒师影评/","text":"今天终于把绝命毒师看完了 从第一季到第五季整个影片基调压抑的让人透不过气 作为一个中年化学教师 老白 兢兢业业，唯唯诺诺，一事无成，身患绝症 为了家人，为了儿子，走上制毒之路，险象环生 却被周围人唾弃 他一直在备受煎熬 当影片最后，当baby blue歌声响起 当老白倒下，顿时有一种解脱的轻松 甚至不由自主的热泪盈眶 碌碌无为五十年 在生命的最后时间 能够发现自己最热爱的东西 能够成就一番事业 并且依然深爱着自己的家人 最终死在自己心爱的实验室里 就像老白说的那样”I was alive” 值了","tags":[{"name":"影评","slug":"影评","permalink":"https://joker208.github.io/tags/影评/"}]},{"title":"网页一键分享功能","date":"2016-08-02T07:44:17.000Z","path":"2016/08/02/网页一键分享功能/","text":"公司用的一般都是现成的分享插件 推荐给大家JiaThis 现有插件的缺点很明显，样式已经固定，不能满足定制化网站的需求 下面用js来实现网页的一键分享功能 123&lt;a href=&quot;javascript:void(0)&quot; onClick=&quot;Share.sinaWeiBo(&apos;测试测试测试分享到微博,地址&apos;,&apos;http://www.baidu.com&apos;,&apos;http://09.imgmini.eastday.com/mobile/20160712/20160712191443_b7a55523e3bfc750a28992a67b664332_1.jpeg&apos;);&quot; title=&quot;分享到新浪微博&quot;&gt;一键转发新浪微博&lt;/a&gt;&lt;a href=&quot;javascript:void(0)&quot; onClick=&quot;Share.qqWeiBo(&apos;测试测试测试分享到腾讯微博&apos;,&apos;http://www.baidu.com&apos;,&apos;http://www.yn.xinhuanet.com/ent/2006-11/10/xin_351103101047078339115.jpg&apos;);&quot; class=&quot;tmblog q&quot; title=&quot;分享到腾讯微博&quot;&gt;一键转发腾讯微博&lt;/a&gt;&lt;a href=&quot;javascript:void(0)&quot; onClick=&quot;Share.qqZone(&apos;测试测试测试分享到QQ空间,地址&apos;,&apos;http://www.baidu.com&apos;,&apos;http://www.yn.xinhuanet.com/ent/2006-11/10/xin_351103101047078339115.jpg&apos;);&quot; class=&quot;tmblog q&quot; title=&quot;分享到腾讯微博&quot;&gt;一键转发QQ空间&lt;/a&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;script type=&quot;text/javascript&quot;&gt; /**分享到新浪微博，腾讯微博，QQ空间，微信朋友圈 */var Share =&#123; //新浪微博 sinaWeiBo:function(title,url,pic)&#123; var _w = 72 , _h = 16; var param = &#123; url:url, type:&apos;3&apos;, count:&apos;1&apos;, /**是否显示分享数，1显示(可选)*/ appkey:&apos;&apos;, /**您申请的应用appkey,显示分享来源(可选)*/ title:title, /**分享的文字内容(可选，默认为所在页面的title)*/ pic:pic, /**分享图片的路径(可选)*/ ralateUid:&apos;&apos;, /**关联用户的UID，分享微博会@该用户(可选)*/ rnd:new Date().valueOf() &#125; var temp = []; for( var p in param )&#123; temp.push(p + &apos;=&apos; + encodeURIComponent( param[p] || &apos;&apos; ) ) &#125; var target_url = &quot;http://service.weibo.com/share/share.php?&quot;+temp.join(&apos;&amp;&apos;); window.open(target_url,&apos;sinaweibo&apos;,&apos;height=430, width=400&apos;); &#125;, //qq微博 qqWeiBo:function(title,url,pic)&#123; var _t = encodeURI(title); var _url = encodeURIComponent(url); var _appkey = encodeURI(&apos;appkey&apos;);//你从腾讯获得的appkey var _pic = encodeURI(pic);//（例如：var _pic=&apos;图片url1|图片url2|图片url3....） var _site = &apos;http://rt.xoyo.com&apos;;//你的网站地址 var _u = &apos;http://v.t.qq.com/share/share.php?url=&apos;+_url+&apos;&amp;appkey=&apos;+_appkey+&apos;&amp;site=&apos;+_site+&apos;&amp;pic=&apos;+_pic+&apos;&amp;title=&apos;+_t; window.open( _u,&apos;&apos;, &apos;width=700, height=680, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, location=yes, resizable=no, status=no&apos; ); &#125;, //qq空间 qqZone:function(title,url,pic)&#123; var p = &#123; url:url, showcount:&apos;0&apos;,/*是否显示分享总数,显示：&apos;1&apos;，不显示：&apos;0&apos; */ desc:&apos;&apos;,/*默认分享理由(可选)*/ summary:&apos;&apos;,/*分享摘要(可选)*/ title:title,/*分享标题(可选)*/ site:&apos;&apos;,/*分享来源 如：腾讯网(可选)*/ pics:pic, /*分享图片的路径(可选)*/ style:&apos;203&apos;, width:22, height:22 &#125;; var s = []; for(var i in p)&#123; s.push(i + &apos;=&apos; + encodeURIComponent(p[i]||&apos;&apos;)); &#125; var shareURL = &apos;http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?&apos;+s.join(&apos;&amp;&apos;); window.open(shareURL,&apos;newwindow&apos;,&apos;height=400,width=400,top=100,left=100&apos;); &#125;,&#125;;&lt;/script&gt; 另微信没有专门的分享接口 一般的解决方案是把要分享的页面做成二维码 通过微信扫一扫打开 在微信右上角有分享的功能","tags":[{"name":"js","slug":"js","permalink":"https://joker208.github.io/tags/js/"},{"name":"一键分享","slug":"一键分享","permalink":"https://joker208.github.io/tags/一键分享/"}]},{"title":"hexo常用命令","date":"2016-06-10T09:07:55.000Z","path":"2016/06/10/hexo常用命令/","text":"安装bashnpm install hexo -g #安装npm update hexo -g #升级hexo init #初始化 简写hexo n “我的博客” == hexo new “我的博客” #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate –watch #监视文件变动 完成后部署两个命令的作用是相同的hexo generate –deployhexo deploy –generate hexo deploy -ghexo server -g 草稿hexo publish [layout] 模版hexo new “postName” #新建文章hexo new page “pageName” #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHub hexo new [layout] hexo new photo “My Gallery”hexo new “Hello World” –lang tw 模版（Scaffold）hexo new photo “My Gallery” 设置文章摘要以上是文章摘要 以下是余下全文 写作hexo new page hexo new post 推送到服务器上hexo n #写文章hexo g #生成hexo d #部署 #可与hexo g合并为 hexo d -g 安装RSS插件npm install hexo-generator-feed –save 开启RSS功能编辑hexo/_config.yml，添加如下代码： rss: /atom.xml #rss地址 默认即可","tags":[{"name":"hexo","slug":"hexo","permalink":"https://joker208.github.io/tags/hexo/"}]},{"title":"HEXO+githubpage搭建博客","date":"2016-06-07T06:26:54.000Z","path":"2016/06/07/HEXO-githubpage搭建博客/","text":"一、前言一千个人眼中有一千个哈姆雷特虽然网上已经不乏相关的教程，我还是把我的搭建步骤和大家分享，我的电脑是windows系统，有问题的话可以留言，我们一起来讨论哈~ 二、准备工作搭建博客首先要了解一下几个基本概念（其实我也没有看完） Git GitHub Pages Hexo Markdown 然后需要下载几个安装包，有些安装包需要翻墙不好下载，直接用我的百度云分享 Node.js（node-v6.9.5-x64.msi） Git（Git-2.11.1-64-bit.exe） 最后，记得在Github上注册个帐号ok，准备工作就做好了 三、搭建博客第一步，把上面提到的两个安装包先给安装了 第二步，将你的Github帐号与你的电脑绑定 先检查你的电脑里有没有SSH keys在电脑的桌面上点鼠标右键，选择Git Bash Here，就会出来黑框框，键入下面代码1$ ls -al ~/.ssh 默认情况下，public keys的文件名是以下的格式之一：id_dsa.pub、id_ecdsa.pub、id_ed25519.pub、id_rsa.pub如果没有SSH key，则生成新的SSH key1$ ssh-keygen -t rsa -C \"your_email@example.com\" 这里的邮箱是你申请Github帐号时的邮箱成功后会在C:\\Users\\用户名\\ .ssh路径下生成两个文件id_rsa 以及id_rsa.pub之后在github添加SSH Key,在任意界面右上角，点击你的头像，选择Settings-&gt; SSH keys-&gt;New SSH key将id_rsa.pub里面的内容全部复制到Key框里面 ok，绑定成功~ 第三步，搭建本地博客在本地新建一个文件夹，比如Blog，文件右键，选择Git Bash Here输入指令安装hexo1$ npm install -g hexo 稍等片刻。。。安装完成后，输入以下指令1$ hexo init 该命令会在目标文件夹内建立网站所需要的所有文件接下来是安装依赖包1$ npm install 部署形成文件1$ hexo generate 再接下来运行server 跑起hexo服务1$ hexo server 这样博客在本地已经搭建好了，我们可以打开浏览器，输入http://localhost:4000/便可看到默认的博客了 鼓掌（/≧▽≦/），等等，其实还有第四步 第四步，博客上线 登录Github，点击”New repository”，新建一个版本库输入仓库名：你的Github名称.github.io然后点击Create repository这里的Repository name一定要用的github的用户名，不然显示不出来，因为githubPage只能你的用户名接下来，点击右边的“Setting”菜单进入设置,点击”Launch automatic page generator”进入之后点击底部的”Continue to layouts”之后选择一个随意模版，点击”Publish page”,发布github默认生成的一个静态站点ok，线上的工作完成，接下来修改一下本地文件 打开本地博客根目录下的配置文件_config.yml编辑最后面的deploy属性，加入代码123type: gitrepository: git@github.com:username/username.github.io.gitbranch: master 这里列举配置文件_config.yml的部分关键配置，可自行修改123456789101112131415161718192021222324252627# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: #网站的标题subtitle: #副标题description: #描述author: #作者信息avatar: #头像，图片位置在相应主题目录下的imageslanguage: zh-Hans #中文简体email: timezone:# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: #配置主题stylus: compress: true #自适应布局# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git #部署环境，基于hexo+githubpage,所以这里使用git。注意：不同版本的hexo，type有可能不同，3.x以后应使用git,具体参看官方文档 repository: git@github.com:username/username.github.io.git #git仓库地址，替换成你的username即可，其他保持不变，后面会提到如何创建git仓库 branch: master 安装hexo-deployer-git插件1npm install hexo-deployer-git --save 部署你本地的主题到github上123hexo cleanhexo generator #简写 hexo ghexo deploy #简写 hexo d 最后，就可以在线上查看搭建好的博客了https://username.github.io 这次，博客真的就搭建完成了，干杯!~( ゜▽゜)つロ 对了，附送我用的主题以及知乎上的主题收集 hexo-theme-yilia 有哪些好看的 Hexo 主题？-知乎 文章参考 http://crazymilk.github.io/ http://blog.csdn.net/wx_jin/article/details/51027783 补充：HEXO里面一定要注意空格，配置文件_config.yml中的属性一定要在冒号后面空一格，不然会报错。","tags":[{"name":"github","slug":"github","permalink":"https://joker208.github.io/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"https://joker208.github.io/tags/hexo/"}]}]