<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joker208的博客</title>
  <subtitle>有梦想的咸鱼</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jiaotingyu.me/"/>
  <updated>2020-05-19T08:40:18.712Z</updated>
  <id>http://jiaotingyu.me/</id>
  
  <author>
    <name>Joker208</name>
    <email>772090298@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Golang Docker host</title>
    <link href="http://jiaotingyu.me/2020/05/16/Golang%20docker%20host/"/>
    <id>http://jiaotingyu.me/2020/05/16/Golang docker host/</id>
    <published>2020-05-15T16:00:00.000Z</published>
    <updated>2020-05-19T08:40:18.712Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h3><p>在docker的alpine容器中使用httpclient向另一个容器发起http请求</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">response, err := httpClient.Do(request)</div></pre></td></tr></table></figure>
<p>程序应该会使用/etc/hosts中配置的IP，但实际使并没有，导致没有返回结果</p>
<p>经查证发现程序使用了从dns server中查询到的ip</p>
<a id="more"></a>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h3><p>进入容器添加nsswitch.conf文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;hosts: files dns&quot; &gt; /etc/nsswitch.conf</div></pre></td></tr></table></figure>
<p>问题原因</p>
<p>golang程序解析域名时默认使用/etc/nsswitch.conf文件中的解析顺序，如果nsswitch.conf文件不存在，则优先使用dns服务器解析域名</p>
<p>golang程序解析域名时按照etc/nsswitch.conf文件中的顺序解析，如果nsswitch.conf不存在，则优先使用dns解析域名</p>
<blockquote>
<p><strong>参考资料</strong></p>
<p><a href="https://github.com/golang/go/issues/22846" target="_blank" rel="external">https://github.com/golang/go/issues/22846</a></p>
<p><a href="https://www.lijiaocn.com/问题/2017/11/09/problem-docker-not-use-hosts-file.html" target="_blank" rel="external">https://www.lijiaocn.com/%E9%97%AE%E9%A2%98/2017/11/09/problem-docker-not-use-hosts-file.html</a></p>
<p><a href="https://blog.csdn.net/u010278923/article/details/79179779" target="_blank" rel="external">https://blog.csdn.net/u010278923/article/details/79179779</a></p>
<p><a href="https://blog.csdn.net/huangruifeng/article/details/96594065" target="_blank" rel="external">https://blog.csdn.net/huangruifeng/article/details/96594065</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;在docker的alpine容器中使用httpclient向另一个容器发起http请求&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;response, err := httpClient.Do(request)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;程序应该会使用/etc/hosts中配置的IP，但实际使并没有，导致没有返回结果&lt;/p&gt;
&lt;p&gt;经查证发现程序使用了从dns server中查询到的ip&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://jiaotingyu.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Golang" scheme="http://jiaotingyu.me/tags/Golang/"/>
    
      <category term="Docker" scheme="http://jiaotingyu.me/tags/Docker/"/>
    
      <category term="host" scheme="http://jiaotingyu.me/tags/host/"/>
    
  </entry>
  
  <entry>
    <title>gorm save update区别</title>
    <link href="http://jiaotingyu.me/2020/03/23/gorm%20save%20update%E5%8C%BA%E5%88%AB/"/>
    <id>http://jiaotingyu.me/2020/03/23/gorm save update区别/</id>
    <published>2020-03-22T16:00:00.000Z</published>
    <updated>2020-05-19T08:37:42.391Z</updated>
    
    <content type="html"><![CDATA[<p>在程序里使用gorm的update更新数据的时候，发现有部分数据没有修改成功。</p>
<p>当使用<strong>Updates</strong>更新结构体的时候，当结构体的值是””或者0，false等，这些值会被忽略掉。</p>
<p>如果需要更新全部字段建议使用<strong>Save</strong>方法。</p>
<a id="more"></a>
<p>下面是官方的说明文档：</p>
<p><strong>Update Changed Fields</strong></p>
<p>If you only want to update changed Fields, you could use <strong>Update</strong>, <strong>Updates</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Update single attribute if it is changed </span></div><div class="line">db.Model(&amp;user).Update(<span class="string">"name"</span>, <span class="string">"hello"</span>) </div><div class="line"><span class="comment">//// UPDATE users SET name='hello', updated_at='2013-11-17 21:34:10' WHERE id=111; </span></div><div class="line"></div><div class="line"><span class="comment">// Update single attribute with combined conditions </span></div><div class="line">db.Model(&amp;user).Where(<span class="string">"active = ?"</span>, <span class="literal">true</span>).Update(<span class="string">"name"</span>, <span class="string">"hello"</span>) </div><div class="line"><span class="comment">//// UPDATE users SET name='hello', updated_at='2013-11-17 21:34:10' WHERE id=111 AND active=true; </span></div><div class="line"></div><div class="line"><span class="comment">// Update multiple attributes with `map`, will only update those changed fields</span></div><div class="line">db.Model(&amp;user).Updates(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">"name"</span>: <span class="string">"hello"</span>, <span class="string">"age"</span>: <span class="number">18</span>, <span class="string">"actived"</span>: <span class="literal">false</span>&#125;) </div><div class="line"><span class="comment">//// UPDATE users SET name='hello', age=18, actived=false, updated_at='2013-11-17 21:34:10' WHERE id=111; </span></div><div class="line"></div><div class="line"><span class="comment">// Update multiple attributes with `struct`, will only update those changed &amp; non blank fields </span></div><div class="line">db.Model(&amp;user).Updates(User&#123;Name: <span class="string">"hello"</span>, Age: <span class="number">18</span>&#125;) </div><div class="line"><span class="comment">//// UPDATE users SET name='hello', age=18, updated_at = '2013-11-17 21:34:10' WHERE id = 111; </span></div><div class="line"></div><div class="line"><span class="comment">// WARNING when update with struct, GORM will only update those fields that with non blank value </span></div><div class="line"><span class="comment">// For below Update, nothing will be updated as "", 0, false are blank values of their types </span></div><div class="line">db.Model(&amp;user).Updates(User&#123;Name: <span class="string">""</span>, Age: <span class="number">0</span>, Actived: <span class="literal">false</span>&#125;)</div></pre></td></tr></table></figure>
<p><u><strong>// WARNING when update with struct, GORM will only update those fields that with non blank value</strong></u></p>
<p><u><strong>// For below Update, nothing will be updated as “”, 0, false are blank values of their types</strong></u></p>
<p>当用结构体更新的时候，当结构体的值是””或者0，false等，这些值会被忽略掉。</p>
<p>如果需要更新全部字段建议使用save方法</p>
<p><strong>Update All Fields</strong></p>
<p><strong>Save</strong> will include all fields when perform the Updating SQL, even it is not changed</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">db.First(&amp;user) </div><div class="line">user.Name = <span class="string">"jinzhu 2"</span> </div><div class="line">user.Age = <span class="number">100</span> </div><div class="line">db.Save(&amp;user) </div><div class="line"><span class="comment">//// UPDATE users SET name='jinzhu 2', age=100, birthday='2016-01-01', updated_at = '2013-11-17 21:34:10' WHERE id=11</span></div></pre></td></tr></table></figure>
<blockquote>
<p><strong>参考资料</strong></p>
<p>官方文档：<a href="http://gorm.io/docs/update.html" target="_blank" rel="external">http://gorm.io/docs/update.html</a></p>
<p><a href="https://www.jianshu.com/p/e8502adac645" target="_blank" rel="external">https://www.jianshu.com/p/e8502adac645</a></p>
<p><a href="https://www.cnblogs.com/oxspirt/p/11240527.html" target="_blank" rel="external">https://www.cnblogs.com/oxspirt/p/11240527.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在程序里使用gorm的update更新数据的时候，发现有部分数据没有修改成功。&lt;/p&gt;
&lt;p&gt;当使用&lt;strong&gt;Updates&lt;/strong&gt;更新结构体的时候，当结构体的值是””或者0，false等，这些值会被忽略掉。&lt;/p&gt;
&lt;p&gt;如果需要更新全部字段建议使用&lt;strong&gt;Save&lt;/strong&gt;方法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://jiaotingyu.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Golang" scheme="http://jiaotingyu.me/tags/Golang/"/>
    
      <category term="gorm" scheme="http://jiaotingyu.me/tags/gorm/"/>
    
  </entry>
  
  <entry>
    <title>ERROR 2059(HY000) Authentication plugin &#39;caching_sha2_password&#39; cannot be loaded</title>
    <link href="http://jiaotingyu.me/2020/03/18/ERROR%202059/"/>
    <id>http://jiaotingyu.me/2020/03/18/ERROR 2059/</id>
    <published>2020-03-17T16:00:00.000Z</published>
    <updated>2020-05-19T08:47:40.784Z</updated>
    
    <content type="html"><![CDATA[<p>出现这个原因是mysql8 之前的版本中加密规则是mysql_native_password，而在mysql8之后,加密规则是caching_sha2_password，解决问题方法有两种，一种是升级navicat驱动，一种是把mysql用户登录密码加密规则还原成mysql_native_password。</p>
<a id="more"></a>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>连接Docker启动的mysql出现：<strong>ERROR 2059 (HY000): Authentication plugin ‘caching_sha2_password’ cannot be loaded</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">C:\mysqldata&gt;mysql -h 127.0.0.1 -P 13306 -uroot -p</div><div class="line">Enter password: ****</div><div class="line"></div><div class="line">ERROR 2059 (HY000): Authentication plugin &apos;caching_sha2_password&apos; cannot be loaded: ÕÒ²»µ½Ö¸¶¨µÄÄ£¿é¡£</div></pre></td></tr></table></figure>
<p>解决也很简单</p>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><ol>
<li>进入mysql容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker exec -it mysql01 /bin/bash</div></pre></td></tr></table></figure>
<ol>
<li>进入mysql</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -uroot -pxxx</div></pre></td></tr></table></figure>
<ol>
<li>修改密码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;xxxx&apos;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;出现这个原因是mysql8 之前的版本中加密规则是mysql_native_password，而在mysql8之后,加密规则是caching_sha2_password，解决问题方法有两种，一种是升级navicat驱动，一种是把mysql用户登录密码加密规则还原成mysql_native_password。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://jiaotingyu.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MySQL" scheme="http://jiaotingyu.me/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>openvpn配置</title>
    <link href="http://jiaotingyu.me/2020/03/16/openvpn%E9%85%8D%E7%BD%AE/"/>
    <id>http://jiaotingyu.me/2020/03/16/openvpn配置/</id>
    <published>2020-03-15T16:00:00.000Z</published>
    <updated>2020-05-19T08:19:14.440Z</updated>
    
    <content type="html"><![CDATA[<p>搭建好服务器以后需要经常维护，有时候服务器很难远程访问到，可以搭建openVPN代理，这样维护服务器就很方便了，这里介绍一下openVPN客户端的安装方法。</p>
<a id="more"></a>
<h3 id="Windows平台"><a href="#Windows平台" class="headerlink" title="Windows平台"></a><strong>Windows平台</strong></h3><p><strong>下载客户端</strong></p>
<ul>
<li><a href="https://openvpn.net/community-downloads/" target="_blank" rel="external">官方下载地址页面</a></li>
</ul>
<p><strong>客户端选择</strong></p>
<p>官网提供两种Windows的客户端，根据自己的Windows版本安装即可</p>
<p><a href="https://swupdate.openvpn.org/community/releases/openvpn-install-2.4.8-I602-Win7.exe" target="_blank" rel="external">openvpn-install-2.4.8-I602-Win7.exe</a></p>
<p><a href="https://swupdate.openvpn.org/community/releases/openvpn-install-2.4.8-I602-Win10.exe" target="_blank" rel="external">openvpn-install-2.4.8-I602-Win10.exe</a></p>
<p><strong>安装OpenVPN</strong></p>
<ul>
<li>双击下载好的exe文件</li>
<li>一路下一步直至安装完成</li>
</ul>
<p><strong>获取OpenVPN配置文件</strong></p>
<ul>
<li>OpenVPN的客户端配置文件为*.ovpn</li>
<li><p>在使用证书认证的情况下，在ovpn文件同一个目录下面会有</p>
</li>
<li><ul>
<li>*.crt</li>
<li>*.key</li>
<li>ca.crt</li>
<li>再开启了tls-auth时还会有ta.key文件</li>
</ul>
</li>
<li><p>证书文件可以内嵌到ovpn文件中，因此有时候会只有一个ovpn文件</p>
</li>
</ul>
<p><strong>配置文件使用方式</strong></p>
<p><strong>直接双击ovpn文件</strong></p>
<p>Windows版OpenVPN客户端安装完成之后，会自动关联ovpn文件，双击即可打开OpenVPN</p>
<p><strong>复制到配置目录</strong></p>
<p>OpenVPN默认会从这两个目录找配置文件，可以存在多个不同的ovpn配置</p>
<ul>
<li>C:\Program Files\OpenVPN\config</li>
<li>C:\User\用户名\OpenVPN\config（通过双击ovpn的方式会把ovpn拷贝到这个目录）</li>
</ul>
<p><strong>连接OpenVPN服务器</strong></p>
<ul>
<li>双击桌面的OpenVPN GUI图标</li>
<li>在任务栏右下角通知栏中找到OpenVPN的图标，右键</li>
<li>点击连接，在有多个ovpn配置时，可以根据名字选择不同的ovpn配置，然后点击连接</li>
<li>连接过程会出现很多日志，连接成功后，右下角会提示连接成功</li>
</ul>
<p><strong>开机自启动</strong></p>
<ul>
<li>把 <strong>ovpn</strong> 配置文件放在 <strong>C:\Program Files\OpenVPN\config</strong></li>
<li>运行 <strong>services.msc</strong></li>
<li>找到 <strong>OpenVPNService</strong> ，点击 <strong>右键</strong> ，选择 <strong>属性</strong></li>
<li>把启动类型改为 <strong>自动</strong> ，点击 <strong>启动</strong> ，点击 <strong>确定</strong></li>
</ul>
<p><strong>Linux平台</strong></p>
<p>这里以CentOS-7.7为例，YUM源自带了OpenVPN-2.4.8</p>
<p><strong>安装客户端</strong></p>
<p>yum install -y openvpn</p>
<p><strong>获取配置文件</strong></p>
<ul>
<li>CentOS-7.7安装OpenVPN之后系统服务会识别*.conf的文件</li>
<li>配置文件跟Windows平台只有扩展名的区别，可以直接把Windows平台的ovpn文件改名为conf文件</li>
</ul>
<p><strong>复制到配置目录</strong></p>
<p>CentOS-7.7安装OpenVPN之后会在/etc/openvpn下创建client和server目录</p>
<p><strong>启动OpenVPN客户端服务</strong></p>
<p>以配置文件abc.conf为例</p>
<p>systemctl start openvpn-client@abc.service</p>
<p><strong>开机自启动</strong></p>
<p>systemctl enable openvpn-client@abc.service</p>
<h3 id="MacOS平台"><a href="#MacOS平台" class="headerlink" title="MacOS平台"></a><strong>MacOS平台</strong></h3><p><strong>系统要求</strong></p>
<ul>
<li>OS X 10.8 Mountain Lion</li>
<li>OS X 10.9 Mavericks</li>
<li>OS X 10.10 Yosemite</li>
<li>OS X 10.11 El Capitan</li>
<li>macOS 10.12 Sierra</li>
<li>macOS 10.13 High Sierra</li>
<li>macOS 10.14 Mojave</li>
</ul>
<p><strong>下载客户端</strong></p>
<p><a href="https://openvpn.net/vpn-server-resources/connecting-to-access-server-with-macos/" target="_blank" rel="external">官网下载页面</a></p>
<p>里面有几个客户端可以选择</p>
<ul>
<li><a href="https://openvpn.net/downloads/openvpn-connect-v2-macos.dmg" target="_blank" rel="external">OpenVPN Connect Client for macOS version 2.7.1.100</a></li>
<li><a href="https://openvpn.net/downloads/openvpn-connect-v3-macos.dmg" target="_blank" rel="external">OpenVPN Connect for macOS version 3.1.0 (885) beta</a></li>
<li><a href="https://tunnelblick.net/downloads.html" target="_blank" rel="external">Tunnelblick</a></li>
</ul>
<p>以上下载到的都是dmg文件，直接安装</p>
<blockquote>
<p><strong>文章参考</strong></p>
<p><a href="https://luanlengli.github.io/2019/11/25/OpenVPN客户端-Windows-Linux-MacOS-连接OpenVPN服务器.html" target="_blank" rel="external">OpenVPN客户端(Windows/Linux/MacOS)连接OpenVPN服务器</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搭建好服务器以后需要经常维护，有时候服务器很难远程访问到，可以搭建openVPN代理，这样维护服务器就很方便了，这里介绍一下openVPN客户端的安装方法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://jiaotingyu.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://jiaotingyu.me/tags/Linux/"/>
    
      <category term="openVPN" scheme="http://jiaotingyu.me/tags/openVPN/"/>
    
  </entry>
  
  <entry>
    <title>ssh登陆忽略known_hosts文件</title>
    <link href="http://jiaotingyu.me/2020/03/05/ssh%E7%99%BB%E9%99%86%E5%BF%BD%E7%95%A5known_hosts%E6%96%87%E4%BB%B6/"/>
    <id>http://jiaotingyu.me/2020/03/05/ssh登陆忽略known_hosts文件/</id>
    <published>2020-03-04T16:00:00.000Z</published>
    <updated>2020-05-19T08:11:44.299Z</updated>
    
    <content type="html"><![CDATA[<p>在平时工作中，需要SSH登陆到别的Linux主机上去，但有时候SSH登陆会被禁止</p>
<a id="more"></a>
<p>并弹出如下类似提示：</p>
<p>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that the RSA host key has just been changed.The fingerprint for the RSA key sent by the remote host is36:68:a6:e6:43:34:6b:82:d7:f4:df:1f:c2:e7:37:cc.Please contact your system administrator.Add correct host key in /u/xlian008/.ssh/known_hosts to get rid of this message.Offending key in /u/xlian008/.ssh/known_hosts:2RSA host key for 135.1.35.130 has changed and you have requested strict checking.Host key verification failed.</p>
<p>比较奇怪，于是研究了一下。 ssh会把你每个你访问过计算机的公钥(public key)都记录在~/.ssh/known_hosts。当下次访问相同计算机时，OpenSSH会核对公钥。如果公钥不同，OpenSSH会发出警告， 避免你受到DNS Hijack之类的攻击。我在上面列出的情况，就是这种情况。</p>
<p>原因：一台主机上有多个Linux系统，会经常切换，那么这些系统使用同一ip，登录过一次后就会把ssh信息记录在本地的~/.ssh/known_hsots文件中，切换该系统后再用ssh访问这台主机就会出现冲突警告，需要手动删除修改known_hsots里面的内容。</p>
<p>有以下两个解决方案：</p>
<ol>
<li><p>手动删除修改known_hsots里面的内容；</p>
</li>
<li><p>修改配置文件“~/.ssh/config”，加上这两行，重启服务器。</p>
<p>StrictHostKeyChecking no</p>
<p>UserKnownHostsFile /dev/null</p>
</li>
</ol>
<p>优缺点：</p>
<ol>
<li><p>需要每次手动删除文件内容，一些自动化脚本的无法运行（在SSH登陆时失败），但是安全性高；</p>
</li>
<li><p>SSH登陆时会忽略known_hsots的访问，但是安全性低；</p>
</li>
</ol>
<blockquote>
<p><strong>文章参考</strong></p>
<p><a href="https://blog.csdn.net/yasaken/article/details/7348441" target="_blank" rel="external">https://blog.csdn.net/yasaken/article/details/7348441</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在平时工作中，需要SSH登陆到别的Linux主机上去，但有时候SSH登陆会被禁止&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://jiaotingyu.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://jiaotingyu.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>crontab用法总结</title>
    <link href="http://jiaotingyu.me/2020/02/03/crontab%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://jiaotingyu.me/2020/02/03/crontab用法总结/</id>
    <published>2020-02-03T06:25:08.000Z</published>
    <updated>2020-05-19T08:02:06.229Z</updated>
    
    <content type="html"><![CDATA[<p>搭建好服务器以后，经常需要开启一些定时任务，例如定时校对时间</p>
<p>借着这个机会总结一下crontab定时任务的用法</p>
<a id="more"></a>
<h3 id="crond介绍"><a href="#crond介绍" class="headerlink" title="crond介绍"></a>crond介绍</h3><p>crond 和crontab是不可分割的。crontab是一个命令，常见于Unix和类Unix的操作系统之中，用于设置周期性被执行的指令。该命令从标准输入设备读取指令，并将其存放于“crontab”文件中，以供之后读取和执行。该词来源于希腊语chronos(χρόνος)，原意是时间。</p>
<p>而crond正是它的守护进程。cron服务是一个定时执行的服务，可以通过crontab 命令添加或者编辑需要定时执行的任务。</p>
<p><strong>安装 并设置开机自启</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">yum install crontabs </div><div class="line">systemctl enable crond </div><div class="line">systemctl start crond </div><div class="line">systemctl stop crond</div></pre></td></tr></table></figure>
<p><strong>设置定时任务</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/crontab</div></pre></td></tr></table></figure>
<p>打开后显示</p>
<blockquote>
<p>SHELL=/bin/bash</p>
<p>PATH=/sbin:/bin:/usr/sbin:/usr/bin</p>
<p>MAILTO=root</p>
<p># For details see man 4 crontabs</p>
<p># Example of job definition:</p>
<p># .—————- minute (0 - 59)   表示分钟1～59 每分钟用<em>或者 </em>/1表示</p>
<p># |  .————- hour (0 - 23)  表示小时1～23（0表示0点）</p>
<p># |  |  .———- day of month (1 - 31)  表示日期1～31</p>
<p># |  |  |  .——- month (1 - 12) OR jan,feb,mar,apr …  月份1～12(可以使用英文简写)</p>
<p># |  |  |  |  .—- day of week (0 - 6) (Sunday=0 or 7)OR sun,mon,tue,wed,thu,fri,sat星期0～6(0或7表示星期天)(可以使用英文简写)</p>
<p># |  |  |  |  |</p>
<p># <em>  </em>  <em>  </em>  * user-name  command to be executed  表示运行的命令</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#加载任务,使之生效 </div><div class="line">crontab /etc/crontab</div></pre></td></tr></table></figure>
<p>crontab /etc/crontab 加载任务的原理可以理解为</p>
<p><u>把/etc/crontab文件里面的内容复制到crontab的执行列表里，执行列表里的内容可能和/etc/crontab文件的内容一样，但是这两个东西正常情况下不会互相影响，只有在执行crontab /etc/crontab时才会把内容复制过去</u></p>
<p>crontab的执行列表中的内容可以使用以下语句直接操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#查看任务 </div><div class="line">crontab -l </div><div class="line">#编辑crontab </div><div class="line">crontab -e </div><div class="line">#删除（不会删除/etc/crontab内容，只删除当前已加载的任务） </div><div class="line">crontab -r </div><div class="line">#添加（不会添加/etc/crontab内容，直接添加任务）</div><div class="line">crontab -e</div></pre></td></tr></table></figure>
<p><strong>crond三种设置方式</strong></p>
<ul>
<li><p>第一种</p>
<p>在/etc/crontab下设置，指定用户名的</p>
</li>
</ul>
<ol>
<li>vim命令进入/etc/crontab</li>
<li>在最后一行加上执行的命令（需要指定用户名）</li>
<li>crontab /etc/crontab或者重启crontab，使配置生效</li>
</ol>
<ul>
<li><p>第二种</p>
<p>直接用crontab -e，不需要指定用户，如果是root权限，默认是root定时的</p>
</li>
</ul>
<ol>
<li>crontab -e进入</li>
<li>直接输入执行的命令 （可以不指定用户）</li>
<li>保存退出（配置已经生效）</li>
</ol>
<ul>
<li><p>第三种</p>
<p>直接写入/var/spool/cron/root</p>
</li>
</ul>
<ol>
<li>vi /var/spool/cron/root</li>
<li>保存退出（配置已经生效）</li>
</ol>
<p><strong>设置时间格式举例</strong></p>
<p>发现网上有很多错误的写法</p>
<p>错误说法：</p>
<p>每一小时重启apache</p>
<p>* <em>/1 </em> <em> </em> /usr/local/etc/rc.d/lighttpd restart</p>
<p>正确说法：</p>
<p>每一小时重启apache(错误的)</p>
<p>*代表每分钟就执行一次，语句的意思为每小时的每分钟都在执行重启apache</p>
<p>* <em>/1 </em> <em> </em> /usr/local/etc/rc.d/lighttpd restart</p>
<p>其实，下面的两种写法效果相同</p>
<p>* <em>/1 </em> <em> </em> /usr/local/etc/rc.d/lighttpd restart <em> </em> <em> </em> * /usr/local/etc/rc.d/lighttpd restart</p>
<p>另外，注意区分每小时执行任务的写法</p>
<p>0 <em> </em> <em> </em>  # 错误 <em>/60 </em> <em> </em> * # 正确</p>
<p>第一个写法是在每小时的0分执行，与任务的开始时间无关</p>
<p>第二个写法是从执行任务的时间点开始，每隔一小时执行一次</p>
<p>其他用法</p>
<p>#每天，每30分钟执行一次 mycommand命令 <em>/30 </em> <em> </em> root /usr/local/mycommand.sh  #每天凌晨三点，执行命令脚本，PS:这里由于第一个的分钟没有设置，那么就会每天凌晨3点的每分钟都执行一次命令 <em> 3 </em> <em> </em> root /usr/local/mycommand.sh #这样就是每天凌晨三点整执行一次命令脚本 0 3 <em> </em> <em> root /usr/local/mycommand.sh #每天11点到13点之间，每10分钟执行一次命令脚本 </em>/10 11-13 <em> </em> <em> root /usr/local/mycommand.sh  #每小时的10-30分钟，每分钟执行一次命令脚本，共执行20次 10-30 </em> <em> </em> <em> root /usr/local/mycommand.sh #每小时的10,30分钟，分别执行一次命令脚本，共执行2次 10,30 </em> <em> </em> <em> </em> root /usr/local/mycommand.sh </p>
<p><strong>附上crontab测试方法</strong></p>
<p>思路：将当前时间输入到日志中</p>
<p>DATEVAR=date <em> </em> <em> </em> * root /bin/echo $($DATEVAR) &gt;&gt; /tmp/crontab.log</p>
<blockquote>
<p><strong>文章参考</strong></p>
<p><a href="https://www.cnblogs.com/emanlee/p/10293762.html" target="_blank" rel="external">https://www.cnblogs.com/emanlee/p/10293762.html</a></p>
<p><a href="https://www.jb51.net/article/117241.htm" target="_blank" rel="external">https://www.jb51.net/article/117241.htm</a></p>
<p><a href="https://www.cnblogs.com/p0st/p/9482167.html" target="_blank" rel="external">https://www.cnblogs.com/p0st/p/9482167.html</a></p>
<p><a href="https://blog.csdn.net/liu0808/article/details/80668705" target="_blank" rel="external">https://blog.csdn.net/liu0808/article/details/80668705</a></p>
<p><a href="https://www.cnblogs.com/p0st/p/9482167.html" target="_blank" rel="external">https://www.cnblogs.com/p0st/p/9482167.html</a></p>
<p><a href="http://www.voidcn.com/article/p-epupsmuh-bty.html" target="_blank" rel="external">http://www.voidcn.com/article/p-epupsmuh-bty.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搭建好服务器以后，经常需要开启一些定时任务，例如定时校对时间&lt;/p&gt;
&lt;p&gt;借着这个机会总结一下crontab定时任务的用法&lt;/p&gt;
    
    </summary>
    
      <category term="运维" scheme="http://jiaotingyu.me/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="crontab" scheme="http://jiaotingyu.me/tags/crontab/"/>
    
      <category term="Linux" scheme="http://jiaotingyu.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Docker访问宿主机端口</title>
    <link href="http://jiaotingyu.me/2019/12/19/Docker%E8%AE%BF%E9%97%AE%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%AB%AF%E5%8F%A3/"/>
    <id>http://jiaotingyu.me/2019/12/19/Docker访问宿主机端口/</id>
    <published>2019-12-19T06:25:08.000Z</published>
    <updated>2020-05-19T04:45:18.305Z</updated>
    
    <content type="html"><![CDATA[<p>Docker容器有的时候需要访问宿主机的服务，但是127.0.0.1并不是宿主机而是Docker自己的服务，可以用下面的语句查询宿主机的ip：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ip addr show docker0 | grep -Po &apos;inet \K[\d.]+&apos;</div></pre></td></tr></table></figure>
<p>得到的ip地址为<strong>172.17.42.1</strong></p>
<p>经过测试发现这个地址是固定的，每一个Docker容器都是这个ip</p>
<a id="more"></a>
<p>以下为stackoverflow原文的问题和解答：</p>
<p>I have a docker container running jenkins. As part of the build process, I need to access a web server that is run locally on the host machine. Is there a way the host web server (which can be configured to run on a port) can be exposed to the jenkins container?</p>
<p>EDIT: I’m running docker natively on a Linux machine.</p>
<p>UPDATE:</p>
<p>In addition to @larsks answer below, to get the IP address of the Host IP from the host machine, I do the following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ip addr show docker0 | grep -Po &apos;inet \K[\d.]+&apos;</div></pre></td></tr></table></figure>
<p><strong>172.17.42.1</strong></p>
<p>When running Docker natively on Linux, you can access host services using the IP address of the docker0 interface. From inside the container, this will be your default route.</p>
<p>For example, on my system:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ ip addr show docker0 </div><div class="line"></div><div class="line">7: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default    </div><div class="line"></div><div class="line">link/ether 00:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff    </div><div class="line"></div><div class="line">inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0       </div><div class="line"></div><div class="line">valid_lft forever preferred_lft forever   </div><div class="line"></div><div class="line">inet6 fe80::f4d2:49ff:fedd:28a0/64 scope link        </div><div class="line"></div><div class="line">valid_lft forever preferred_lft forever</div></pre></td></tr></table></figure>
<p>And inside a container:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># ip route show </div><div class="line">default via 172.17.0.1 dev eth0  </div><div class="line">172.17.0.0/16 dev eth0  src 172.17.0.4</div></pre></td></tr></table></figure>
<p>It’s fairly easy to extract this IP address using a simple shell script:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh </div><div class="line">hostip=$(ip route show | awk &apos;/default/ &#123;print $3&#125;&apos;) </div><div class="line">echo $hostip</div></pre></td></tr></table></figure>
<p>You may need to modify the iptables rules on your host to permit connections from Docker containers. Something like this will do the trick:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\# iptables -A INPUT -i docker0 -j ACCEPT</div></pre></td></tr></table></figure>
<p>This would permit access to any ports on the host from Docker containers. Note that:</p>
<ul>
<li>iptables rules are ordered, and this rule may or may not do the right thing depending on what other rules come before it.</li>
<li>you will only be able to access host services that are either (a) listening on INADDR_ANY (aka 0.0.0.0) or that are explicitly listening on the docker0 interface.</li>
</ul>
<blockquote>
<p>文章参考</p>
<p> <a href="https://stackoverflow.com/questions/31324981/how-to-access-host-port-from-docker-container" target="_blank" rel="external">https://stackoverflow.com/questions/31324981/how-to-access-host-port-from-docker-container</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker容器有的时候需要访问宿主机的服务，但是127.0.0.1并不是宿主机而是Docker自己的服务，可以用下面的语句查询宿主机的ip：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ip addr show docker0 | grep -Po &amp;apos;inet \K[\d.]+&amp;apos;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;得到的ip地址为&lt;strong&gt;172.17.42.1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过测试发现这个地址是固定的，每一个Docker容器都是这个ip&lt;/p&gt;
    
    </summary>
    
      <category term="运维" scheme="http://jiaotingyu.me/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="docker" scheme="http://jiaotingyu.me/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>服务器全局代理</title>
    <link href="http://jiaotingyu.me/2019/08/15/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86/"/>
    <id>http://jiaotingyu.me/2019/08/15/服务器全局代理/</id>
    <published>2019-08-15T06:25:08.000Z</published>
    <updated>2020-05-19T04:01:06.694Z</updated>
    
    <content type="html"><![CDATA[<p>为了给服务器更新一些应用</p>
<p>需要给服务器科学上网并开启全局代理</p>
 <a id="more"></a>
<h4 id="ss客户端安装"><a href="#ss客户端安装" class="headerlink" title="ss客户端安装"></a>ss客户端安装</h4><p> pip install shadowsocks</p>
<p>sudo vi /etc/shadowsocks.json</p>
<p>{</p>
<p>​    “server”:”103.16.229.46”,</p>
<p>​    “server_port”:5432,</p>
<p>​    “local_address”: “127.0.0.1”,</p>
<p>​    “local_port”:1080,</p>
<p>​    “password”:”biubiubiu~”,</p>
<p>​    “timeout”:300,</p>
<p>​    “method”:”aes-256-cfb”</p>
<p>}</p>
<p>客戶端启动或者停止ss服务。 </p>
<p>sslocal -c /etc/shadowsocks.json -d start</p>
<p>sslocal -c /etc/shadowsocks.json -d stop</p>
<h4 id="privoxy安装"><a href="#privoxy安装" class="headerlink" title="privoxy安装"></a>privoxy安装</h4><p>wget <a href="https://nchc.dl.sourceforge.net/project/ijbswa/Sources/3.0.26%20%28stable%29/privoxy-3.0.26-stable-src.tar.gz" target="_blank" rel="external">https://nchc.dl.sourceforge.net/project/ijbswa/Sources/3.0.26%20%28stable%29/privoxy-3.0.26-stable-src.tar.gz</a></p>
<p>tar xf privoxy-3.0.26-stable-src.tar.gz</p>
<p>cd privoxy-3.0.26-stable</p>
<p>useradd privoxy</p>
<p>autoheader &amp;&amp; autoconf</p>
<p>./configure</p>
<p>make &amp;&amp; make install</p>
<p>sudo vim /usr/local/etc/privoxy/config</p>
<p>修改</p>
<p>listen-address 127.0.0.1:8118</p>
<p>forward-socks5t / 127.0.0.1:1080 .</p>
<p>sudo vim /etc/profile</p>
<p>添加以下几行：</p>
<p>export http_proxy=<a href="http://127.0.0.1:8118" target="_blank" rel="external">http://127.0.0.1:8118</a></p>
<p>export ftp_proxy=<a href="http://127.0.0.1:8118" target="_blank" rel="external">http://127.0.0.1:8118</a></p>
<p>source /etc/profile</p>
<p>service privoxy start</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>curl <a href="http://httpbin.org/ip" target="_blank" rel="external">http://httpbin.org/ip</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了给服务器更新一些应用&lt;/p&gt;
&lt;p&gt;需要给服务器科学上网并开启全局代理&lt;/p&gt;
    
    </summary>
    
      <category term="运维" scheme="http://jiaotingyu.me/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="ss" scheme="http://jiaotingyu.me/tags/ss/"/>
    
      <category term="代理" scheme="http://jiaotingyu.me/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>马来西亚旅游攻略</title>
    <link href="http://jiaotingyu.me/2019/07/08/%E9%A9%AC%E6%9D%A5%E8%A5%BF%E4%BA%9A%E6%97%85%E8%A1%8C%E6%94%BB%E7%95%A5/"/>
    <id>http://jiaotingyu.me/2019/07/08/马来西亚旅行攻略/</id>
    <published>2019-07-08T07:08:21.000Z</published>
    <updated>2020-05-19T08:02:45.298Z</updated>
    
    <content type="html"><![CDATA[<h2 id="马来西亚双人旅行"><a href="#马来西亚双人旅行" class="headerlink" title="马来西亚双人旅行"></a><strong>马来西亚双人旅行</strong></h2><p>注意事项：</p>
<ol>
<li>插头不同</li>
<li>没有时差</li>
<li>货币兑换：1MYR=1.7RMB</li>
<li>地铁乘坐价格，交通价格</li>
<li>亚行飞机开的很足，坐飞机需要带衣服</li>
<li>签证/机票预定</li>
<li>提前准备电话卡</li>
<li><p>潜水提前准备（水母服、脚蹼等）</p>
<a id="more"></a>
</li>
</ol>
<p><strong>整体行程概览：</strong></p>
<p>9/30-10/1 广州-&gt;吉隆坡  飞机</p>
<p>10/2   吉隆坡-&gt;斗湖 飞机</p>
<p>10/2   斗 湖-&gt;仙本那 坐车（机场打车，25MYR/人）</p>
<p>10/6-10/7 吉隆坡-&gt;广州</p>
<p>价格：¥2100*2=¥4200（往返）</p>
<p><strong>吉隆坡：**</strong>费用总计：¥1000**</p>
<ol>
<li><strong>双子塔</strong>： 用时1-3小时</li>
</ol>
<p><strong>交通</strong>：前往国家石油公司双子塔，可乘Putra线轻轨直达底层；或乘LRT到KLCC站，出站便可到达KLCC商场内</p>
<p><strong>门票：</strong> MYR 80 = ¥140 *2=¥280</p>
<p><strong>开放时间：</strong>09:00-21:00,停止入场时间:20:30</p>
<p><strong>历史</strong>：建成于1997年，是一座超经典现代的建筑物，也是目前全世界最高的两座相连建筑物。这座美轮美奂的特出建筑物的建筑理念是由伊斯兰5大支柱思想所激发而来的，共88层楼高。双峰塔内设有国油交响乐厅，是马来西亚交响乐队及国油表演艺术团例常练习及表演的场所。登上双塔大楼，整个吉隆坡市秀丽风光尽收眼底，尤其是在晚上灯光璀璨的时候，景色尤为壮美。</p>
<p><strong>安排：</strong>看看吉隆坡景色，逛逛街。午餐就在这儿吃啦</p>
<ol>
<li><strong>国家清真寺</strong>：用时1-3小时（男士、女士需穿长衣）</li>
</ol>
<p><strong>交通</strong>：国家清真寺位于吉隆坡的Jl Perdana街，吉隆坡老火车站边上，可步行前往</p>
<p><strong>门票</strong>：免费（tips: 在正门入口处作访客登记）</p>
<p><strong>开放时间</strong>：周一-周四：09:00-12:00；周五：17:30-18:30；周六-周日：15:00-16:00</p>
<p><strong>历史</strong>：建于1974年，可容纳8000人同时祈祷，最令人瞩目之处则在于其层叠的伞状屋顶。回教堂的主要圆顶处有18颗星，代表马来13州属及回教的5大支柱。令人惊叹的是其多褶伞形屋顶，73公尺高尖塔更直指蓝天，精致巍然。寺内经堂、走廊、图书室等的装潢与麦加的三大清真寺相仿。每逢星期五主麻日，虔诚的教徒们便涌向这里做祈祷。</p>
<p><strong>安排：</strong>感受宗教文化，体会当地宗教特色</p>
<ol>
<li><strong>独立广场：</strong>用时1小时以下</li>
</ol>
<p><strong>交通</strong>：独立广场位于苏丹阿都沙末大厦对面，可乘坐LRT黄线到Masjid Jamek站，再向西步行约10-15分钟即达。</p>
<p><strong>门票</strong>：免费</p>
<p><strong>开放时间</strong>：全天</p>
<p><strong>历史：</strong>独立广场坐落于苏丹阿都沙末大厦对面，绿草如茵的广场极具历史价值。为纪念马来西亚脱离英国统治独立而建，每年会在此举办国庆活动。广场对面是城市长廊，门口的“I LOVE KL”是其标志性logo。周边有圣玛丽教堂、历史博物馆、雪兰莪俱乐部等很多混合各国特色的老式建筑。</p>
<p><strong>安排：</strong>随便走走</p>
<ol>
<li><strong>中央市场</strong></li>
</ol>
<p><strong>交通</strong>：乘坐LRT黄线到Pasar Seni站，再往北步行约10分钟；或乘坐LRT黄线（或红线）到Masjid Jamek站，再往南步行约10分钟</p>
<p><strong>无门票</strong></p>
<p><strong>开放时间</strong>：早上10点至晚上10点</p>
<p><strong>历史：</strong>过去是吉隆坡主要“湿市场”，现在这个露天集式的艺术及手工艺品中心，则汇集了本地艺术家与工匠的杰作；既可即时让画家给你画张肖像画，也可慢慢欣赏和挑选纪念品，更可到传统药材店搜罗珍贵的药品。</p>
<p><strong>安排</strong>：到处看看逛逛，买点特色商品。吃晚餐</p>
<ol>
<li><strong>住宿（双子塔对面民宿，无边泳池）</strong></li>
</ol>
<p><strong>价格：</strong>¥500</p>
<p><strong>安排</strong>：晚上看精力，有时间的话，就去无边泳池玩，没时间的话第二天早上去，在无边泳池照日出</p>
<p><strong>10/2吉隆坡-&gt;斗湖-&gt;仙本那 费用总计：¥2000</strong></p>
<p><strong>路程：</strong>吉隆坡-&gt;斗湖 飞机两小时；斗湖-&gt;仙本那 汽车1-2小时</p>
<p><strong>价格：</strong>机票往返：¥800*2=¥1600</p>
<p><strong>车费：</strong>单程¥45*2=¥90；</p>
<p><strong>仙本那</strong></p>
<p><strong>10/2-10/3</strong>镇上呆一天，逛逛 住宿：¥300</p>
<p><strong>10/3-10/5</strong>仙本那水屋，潜水 住宿：¥4500（使用信用卡有1%手续费）</p>
<p><strong>10/5</strong> 回吉隆坡 车费：¥100</p>
<p><strong>10/6-10/7</strong> 回广州</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;马来西亚双人旅行&quot;&gt;&lt;a href=&quot;#马来西亚双人旅行&quot; class=&quot;headerlink&quot; title=&quot;马来西亚双人旅行&quot;&gt;&lt;/a&gt;&lt;strong&gt;马来西亚双人旅行&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;插头不同&lt;/li&gt;
&lt;li&gt;没有时差&lt;/li&gt;
&lt;li&gt;货币兑换：1MYR=1.7RMB&lt;/li&gt;
&lt;li&gt;地铁乘坐价格，交通价格&lt;/li&gt;
&lt;li&gt;亚行飞机开的很足，坐飞机需要带衣服&lt;/li&gt;
&lt;li&gt;签证/机票预定&lt;/li&gt;
&lt;li&gt;提前准备电话卡&lt;/li&gt;
&lt;li&gt;&lt;p&gt;潜水提前准备（水母服、脚蹼等）&lt;/p&gt;
    
    </summary>
    
      <category term="旅游" scheme="http://jiaotingyu.me/categories/%E6%97%85%E6%B8%B8/"/>
    
    
      <category term="马来西亚🇲🇾" scheme="http://jiaotingyu.me/tags/%E9%A9%AC%E6%9D%A5%E8%A5%BF%E4%BA%9A%F0%9F%87%B2%F0%9F%87%BE/"/>
    
  </entry>
  
  <entry>
    <title>以太坊学习笔记（十六）</title>
    <link href="http://jiaotingyu.me/2018/09/26/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/"/>
    <id>http://jiaotingyu.me/2018/09/26/以太坊学习笔记（十六）/</id>
    <published>2018-09-25T16:00:00.000Z</published>
    <updated>2020-05-18T15:27:56.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="以太坊源码分析"><a href="#以太坊源码分析" class="headerlink" title="以太坊源码分析"></a>以太坊源码分析</h2><h3 id="以太坊共识算法分为两类"><a href="#以太坊共识算法分为两类" class="headerlink" title="以太坊共识算法分为两类"></a>以太坊共识算法分为两类</h3><ul>
<li><p><strong>Ethash算法</strong></p>
</li>
<li><p><strong>Clique算法</strong></p>
<a id="more"></a>
</li>
</ul>
<h3 id="Ethash"><a href="#Ethash" class="headerlink" title="Ethash"></a>Ethash</h3><p>Ethash算法也叫做挖矿算法，是以太坊基于POW工作量证明的共识引擎</p>
<p>Ethash算法过程：</p>
<ul>
<li><p>通过扫描块头为每个区块计算出一个seed</p>
</li>
<li><p>根据seed计算一个16MB的伪随机缓存cache，供轻客户端缓存</p>
</li>
<li><p>从缓存cache中生成一个数据集，完整的客户端存储这个数据集</p>
</li>
</ul>
<p>Ethash算法在以太坊中使用Seal方法实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Seal(chain ChainReader, block *types.Block, stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) (*types.Block, error)<span class="comment">//该方法通过输入一个包含本地矿工挖出的最高区块在主干上生成一个新块</span></div></pre></td></tr></table></figure>
<p>该方法包含的参数有ChainReader Block stop</p>
<ul>
<li><p>ChainReader</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义了一些方法，用于在区块头验证以及叔块验证期间，访问本地区块链。</span></div><div class="line"><span class="keyword">type</span> ChainReader <span class="keyword">interface</span> &#123;</div><div class="line">    <span class="comment">// 获取区块链的链配置</span></div><div class="line">    Config() *params.ChainConfig</div><div class="line"></div><div class="line">    <span class="comment">// 从本地链获取当前块头</span></div><div class="line">    CurrentHeader() *types.Header</div><div class="line"></div><div class="line">    <span class="comment">// 通过hash和number从主链中获取一个区块头</span></div><div class="line">    GetHeader(hash common.Hash, number <span class="keyword">uint64</span>) *types.Header</div><div class="line"></div><div class="line">    <span class="comment">// 通过number从主链中获取一个区块头</span></div><div class="line">    GetHeaderByNumber(number <span class="keyword">uint64</span>) *types.Header</div><div class="line"></div><div class="line">    <span class="comment">// 通过hash从主链中获取一个区块头</span></div><div class="line">    GetHeaderByHash(hash common.Hash) *types.Header</div><div class="line"></div><div class="line">    <span class="comment">// 通过hash和number从主链中获取一个区块</span></div><div class="line">    GetBlock(hash common.Hash, number <span class="keyword">uint64</span>) *types.Block</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  ChainReader主要作用是获取header</p>
</li>
<li><p>Block</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Block代表以太坊区块链中的一个完整的区块</span></div><div class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</div><div class="line">    header       *Header <span class="comment">// 区块包括头</span></div><div class="line">    uncles       []*Header <span class="comment">// 叔块</span></div><div class="line">    transactions Transactions <span class="comment">// 交易集合</span></div><div class="line"></div><div class="line">    <span class="comment">// caches缓存</span></div><div class="line">    hash atomic.Value</div><div class="line">    size atomic.Value</div><div class="line"></div><div class="line">    <span class="comment">// Td用于core包存储所有的链上的难度</span></div><div class="line">    td *big.Int</div><div class="line"></div><div class="line">    <span class="comment">// 这些字段用于eth包来跟踪inter-peer内部端点区块的接替</span></div><div class="line">    ReceivedAt   time.Time</div><div class="line">    ReceivedFrom <span class="keyword">interface</span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  Block就是一个完整的区块，包括header uncles transaction等重要信息</p>
</li>
<li><p>stop</p>
<p>  stop是一个空结构体作为信号源</p>
</li>
</ul>
<pre><code>Seal方法的完整代码
</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span> <span class="title">Seal</span><span class="params">(chain consensus.ChainReader, block *types.Block, stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="params">(*types.Block, error)</span></span> &#123;</div><div class="line">    <span class="comment">// fake模式立即返回0 nonce</span></div><div class="line">    <span class="keyword">if</span> ethash.fakeMode &#123;</div><div class="line">        header := block.Header()</div><div class="line">        header.Nonce, header.MixDigest = types.BlockNonce&#123;&#125;, common.Hash&#123;&#125;</div><div class="line">        <span class="keyword">return</span> block.WithSeal(header), <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 共享pow的话，则转到它的共享对象执行Seal操作</span></div><div class="line">    <span class="keyword">if</span> ethash.shared != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> ethash.shared.Seal(chain, block, stop)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 创建一个runner以及它指挥的多重搜索线程</span></div><div class="line">    abort := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</div><div class="line">    found := <span class="built_in">make</span>(<span class="keyword">chan</span> *types.Block)</div><div class="line"></div><div class="line">    ethash.lock.Lock() <span class="comment">// 线程上锁，保证内存的缓存（包含挖矿字段）安全</span></div><div class="line">    threads := ethash.threads <span class="comment">// 挖矿的线程s</span></div><div class="line">    <span class="keyword">if</span> ethash.rand == <span class="literal">nil</span> &#123;<span class="comment">// rand为空，则为ethash的字段rand赋值</span></div><div class="line">        <span class="comment">// 获得种子</span></div><div class="line">        seed, err := crand.Int(crand.Reader, big.NewInt(math.MaxInt64))</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;<span class="comment">// 执行失败，有报错</span></div><div class="line">            ethash.lock.Unlock() <span class="comment">// 先解锁</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err <span class="comment">// 程序中止，直接返回空块和报错信息</span></div><div class="line">        &#125;</div><div class="line">        ethash.rand = rand.New(rand.NewSource(seed.Int64())) <span class="comment">// 执行成功，拿到合法种子seed，通过其获得rand对象，赋值。</span></div><div class="line">    &#125;</div><div class="line">    ethash.lock.Unlock() <span class="comment">// 解锁</span></div><div class="line">    <span class="keyword">if</span> threads == <span class="number">0</span> &#123;<span class="comment">// 挖矿线程编号为0，则通过方法返回当前物理上可用CPU编号</span></div><div class="line">        threads = runtime.NumCPU()</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> threads &lt; <span class="number">0</span> &#123; <span class="comment">// 非法结果</span></div><div class="line">        threads = <span class="number">0</span> <span class="comment">// 置为0，允许在本地或远程没有额外逻辑的情况下，取消本地挖矿操作</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> pend sync.WaitGroup <span class="comment">// 创建一个倒计时锁对象，go语法参照 http://www.cnblogs.com/Evsward/p/goPipeline.html#sync.waitgroup</span></div><div class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; threads; i++ &#123;</div><div class="line">        pend.Add(<span class="number">1</span>)</div><div class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>, nonce <span class="keyword">uint64</span>)</span></span> &#123;<span class="comment">// 核心代码通过闭包多线程技术来执行。</span></div><div class="line">            <span class="keyword">defer</span> pend.Done()</div><div class="line">            ethash.mine(block, id, nonce, abort, found) <span class="comment">// Seal核心工作</span></div><div class="line">        &#125;(i, <span class="keyword">uint64</span>(ethash.rand.Int63()))<span class="comment">//闭包第二个参数表达式uint64(ethash.rand.Int63())通过上面准备好的rand函数随机数结果作为nonce实参传入方法体</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 直到seal操作被中止或者找到了一个nonce值，否则一直等</span></div><div class="line">    <span class="keyword">var</span> result *types.Block <span class="comment">// 定义一个区块对象result，用于接收操作结果并作为返回值返回上一层</span></div><div class="line">    <span class="keyword">select</span> &#123; <span class="comment">// go语法参照 http://www.cnblogs.com/Evsward/p/go.html#select</span></div><div class="line">    <span class="keyword">case</span> &lt;-stop:</div><div class="line">        <span class="comment">// 外部意外中止，停止所有挖矿线程</span></div><div class="line">        <span class="built_in">close</span>(abort)</div><div class="line">    <span class="keyword">case</span> result = &lt;-found:</div><div class="line">        <span class="comment">// 其中一个线程挖到正确块，中止其他所有线程</span></div><div class="line">        <span class="built_in">close</span>(abort)</div><div class="line">    <span class="keyword">case</span> &lt;-ethash.update:</div><div class="line">        <span class="comment">// ethash对象发生改变，停止当前所有操作，重启当前方法</span></div><div class="line">        <span class="built_in">close</span>(abort)</div><div class="line">        pend.Wait()</div><div class="line">        <span class="keyword">return</span> ethash.Seal(chain, block, stop)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 等待所有矿工停止或者返回一个区块</span></div><div class="line">    pend.Wait()</div><div class="line">    <span class="keyword">return</span> result, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在seal中首先进行了状态校验并进行对应的流程梳理，其中最重要的是mine方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// mine函数是真正的pow矿工，用来搜索一个nonce值，nonce值开始于seed值，seed值是能最终产生正确的可匹配可验证的区块难度</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span> <span class="title">mine</span><span class="params">(block *types.Block, id <span class="keyword">int</span>, seed <span class="keyword">uint64</span>, abort <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, found <span class="keyword">chan</span> *types.Block)</span></span> &#123;</div><div class="line">    <span class="comment">// 从区块头中提取出一些数据，放在一个全局变量域中</span></div><div class="line">    <span class="keyword">var</span> (</div><div class="line">        header = block.Header()</div><div class="line">        hash   = header.HashNoNonce().Bytes()</div><div class="line">        target = <span class="built_in">new</span>(big.Int).Div(maxUint256, header.Difficulty) <span class="comment">// 用来验证的target</span></div><div class="line"></div><div class="line">        number  = header.Number.Uint64()</div><div class="line">        dataset = ethash.dataset(number)</div><div class="line">    )</div><div class="line">    <span class="comment">// 开始生成随机nonce值知道我们中止或者成功找到了一个合适的值</span></div><div class="line">    <span class="keyword">var</span> (</div><div class="line">        attempts = <span class="keyword">int64</span>(<span class="number">0</span>) <span class="comment">// 初始化一个尝试次数的变量，下面会利用该变量耍一些花枪</span></div><div class="line">        nonce    = seed <span class="comment">// 初始化为seed值，后面每次尝试以后会累加</span></div><div class="line">    )</div><div class="line">    logger := log.New(<span class="string">"miner"</span>, id)</div><div class="line">    logger.Trace(<span class="string">"Started ethash search for new nonces"</span>, <span class="string">"seed"</span>, seed)</div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">        <span class="keyword">select</span> &#123;</div><div class="line">        <span class="keyword">case</span> &lt;-abort: <span class="comment">// 中止命令</span></div><div class="line">            <span class="comment">// 挖矿中止，更新状态，中止当前操作，返回空</span></div><div class="line">            logger.Trace(<span class="string">"Ethash nonce search aborted"</span>, <span class="string">"attempts"</span>, nonce-seed)</div><div class="line">            ethash.hashrate.Mark(attempts)</div><div class="line">            <span class="keyword">return</span></div><div class="line"></div><div class="line">        <span class="keyword">default</span>: <span class="comment">// 默认执行</span></div><div class="line">            <span class="comment">// 我们没必要在每一次尝试nonce值的时候更新hash率，可以在尝试了2的X次方nonce值以后再更新即可</span></div><div class="line">            attempts++ <span class="comment">// 通过次数attemp来控制</span></div><div class="line">            <span class="keyword">if</span> (attempts % (<span class="number">1</span> &lt;&lt; <span class="number">15</span>)) == <span class="number">0</span> &#123;<span class="comment">// 这里是定的2的15次方</span></div><div class="line">                ethash.hashrate.Mark(attempts) <span class="comment">// 满足条件了以后，要更新ethash的hash率字段的状态值</span></div><div class="line">                attempts = <span class="number">0</span> <span class="comment">// 重置尝试次数</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 为这个nonce值计算pow值</span></div><div class="line">            digest, result := hashimotoFull(dataset, hash, nonce) <span class="comment">// 调用的hashimotoFull函数在本包的算法库中</span></div><div class="line">            <span class="keyword">if</span> <span class="built_in">new</span>(big.Int).SetBytes(result).Cmp(target) &lt;= <span class="number">0</span> &#123; <span class="comment">// 验证标准</span></div><div class="line">                <span class="comment">// 找到正确nonce值，创建一个基于它的新的区块头</span></div><div class="line">                header = types.CopyHeader(header)</div><div class="line">                header.Nonce = types.EncodeNonce(nonce) <span class="comment">// 将输入的整型值转换为一个区块nonce值</span></div><div class="line">                header.MixDigest = common.BytesToHash(digest) <span class="comment">// 将字节数组转换为Hash对象【Hash是32位的根据任意输入数据的Keccak256哈希算法的返回值】</span></div><div class="line"></div><div class="line">                <span class="comment">// 封装返回一个区块</span></div><div class="line">                <span class="keyword">select</span> &#123;</div><div class="line">                <span class="keyword">case</span> found &lt;- block.WithSeal(header):</div><div class="line">                    logger.Trace(<span class="string">"Ethash nonce found and reported"</span>, <span class="string">"attempts"</span>, nonce-seed, <span class="string">"nonce"</span>, nonce)</div><div class="line">                <span class="keyword">case</span> &lt;-abort:</div><div class="line">                    logger.Trace(<span class="string">"Ethash nonce found but discarded"</span>, <span class="string">"attempts"</span>, nonce-seed, <span class="string">"nonce"</span>, nonce)</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span></div><div class="line">            &#125;</div><div class="line">            nonce++ <span class="comment">// 累加nonce</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>mine方法主要就是对nonce的操作，以及对区块头的重建操作</p>
<h3 id="Clique"><a href="#Clique" class="headerlink" title="Clique"></a>Clique</h3><p>Clique是以太坊基于权利证明的POA共识算法</p>
<p>Clique通过函数Ethereum.StartMining进行初始化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Ethereum)</span> <span class="title">StartMining</span><span class="params">(local <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">    eb, err := s.Etherbase()<span class="comment">//用户地址</span></div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        log.Error(<span class="string">"Cannot start mining without etherbase"</span>, <span class="string">"err"</span>, err)</div><div class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"etherbase missing: %v"</span>, err)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> clique, ok := s.engine.(*clique.Clique); ok &#123;</div><div class="line">        <span class="comment">//如果是clique共识算法</span></div><div class="line">        wallet, err := s.accountManager.Find(accounts.Account&#123;Address: eb&#125;)    <span class="comment">// 根据用它胡地址获取wallet对象</span></div><div class="line">        <span class="keyword">if</span> wallet == <span class="literal">nil</span> || err != <span class="literal">nil</span> &#123;</div><div class="line">            log.Error(<span class="string">"Etherbase account unavailable locally"</span>, <span class="string">"err"</span>, err)</div><div class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"signer missing: %v"</span>, err)</div><div class="line">        &#125;</div><div class="line">        clique.Authorize(eb, wallet.SignHash) <span class="comment">// 注入签名者以及wallet对象获取签名方法</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> local &#123;</div><div class="line">        <span class="comment">// 如果本地CPU已开始挖矿，我们可以禁用引入的交易拒绝机制来加速同步时间。CPU挖矿在主网是荒诞的，所以没有人能碰到这个路径，然而一旦CPU挖矿同步标志完成以后，将保证私网工作也在一个独立矿工结点。</span></div><div class="line">        atomic.StoreUint32(&amp;s.protocolManager.acceptTxs, <span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">go</span> s.miner.Start(eb)</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Clique算法在以太坊中也是通过seal来实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//通过本地签名认证创建已密封的区块</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Clique)</span> <span class="title">Seal</span><span class="params">(chain consensus.ChainReader, block *types.Block, stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="params">(*types.Block, error)</span></span> &#123;</div><div class="line">        header := block.Header()</div><div class="line">    <span class="comment">// 不密封创世块</span></div><div class="line">    number := header.Number.Uint64()</div><div class="line">    <span class="keyword">if</span> number == <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errUnknownBlock</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 不支持0-period的链，不支持空块密封，没有奖励但是能够密封</span></div><div class="line">    <span class="keyword">if</span> c.config.Period == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(block.Transactions()) == <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errWaitTransactions</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 在整个密封区块的过程中不要持有signer签名者字段</span></div><div class="line">    c.lock.RLock()</div><div class="line">    signer, signFn := c.signer, c.signFn <span class="comment">//获取签名者和签名方法</span></div><div class="line">    c.lock.RUnlock()</div><div class="line"></div><div class="line">    snap, err := c.snapshot(chain, number<span class="number">-1</span>, header.ParentHash, <span class="literal">nil</span>) <span class="comment">//调用获取快照</span></div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">    &#125;</div><div class="line"><span class="comment">//检查我们是否被授权去签名一个区块</span></div><div class="line">    <span class="keyword">if</span> _, authorized := snap.Signers[signer]; !authorized &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errUnauthorized</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果我们是在‘最近签名者’中则等待下一个区块</span></div><div class="line">    <span class="keyword">for</span> seen, recent := <span class="keyword">range</span> snap.Recents &#123;</div><div class="line">        <span class="keyword">if</span> recent == signer &#123;</div><div class="line">            <span class="comment">// 当前签名者在‘最近签名者’中，如果当前区块没有剔除他的话只能等待（这里涉及到机会均等）</span></div><div class="line">            <span class="keyword">if</span> limit := <span class="keyword">uint64</span>(<span class="built_in">len</span>(snap.Signers)/<span class="number">2</span> + <span class="number">1</span>); number &lt; limit || seen &gt; number-limit &#123;</div><div class="line">                log.Info(<span class="string">"Signed recently, must wait for others"</span>)</div><div class="line">                &lt;-stop</div><div class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 协议已经允许我们来签名这个区块，等待我们的时间</span></div><div class="line">    delay := time.Unix(header.Time.Int64(), <span class="number">0</span>).Sub(time.Now()) <span class="comment">// nolint: gosimple</span></div><div class="line">    <span class="keyword">if</span> header.Difficulty.Cmp(diffNoTurn) == <span class="number">0</span> &#123;</div><div class="line">        <span class="comment">// 这不是我们的轮次来签名，延迟一点，随机延迟，这样对于每一个签名者来说来允许并发签名</span></div><div class="line">        wiggle := time.Duration(<span class="built_in">len</span>(snap.Signers)/<span class="number">2</span>+<span class="number">1</span>) * wiggleTime</div><div class="line">        delay += time.Duration(rand.Int63n(<span class="keyword">int64</span>(wiggle)))</div><div class="line"></div><div class="line">        log.Trace(<span class="string">"Out-of-turn signing requested"</span>, <span class="string">"wiggle"</span>, common.PrettyDuration(wiggle))</div><div class="line">    &#125;</div><div class="line">    log.Trace(<span class="string">"Waiting for slot to sign and propagate"</span>, <span class="string">"delay"</span>, common.PrettyDuration(delay))</div><div class="line"></div><div class="line">    <span class="keyword">select</span> &#123;</div><div class="line">    <span class="keyword">case</span> &lt;-stop:</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line">    <span class="keyword">case</span> &lt;-time.After(delay):</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 通过signFn签名函数开始签名</span></div><div class="line">    sighash, err := signFn(accounts.Account&#123;Address: signer&#125;, sigHash(header).Bytes())</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//将签名结果替换保存在区块头的Extra字段中</span></div><div class="line">    <span class="built_in">copy</span>(header.Extra[<span class="built_in">len</span>(header.Extra)-extraSeal:], sighash)</div><div class="line">    <span class="comment">//通过区块头重新组装生成一个区块</span></div><div class="line">    <span class="keyword">return</span> block.WithSeal(header), <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意以下几点：</strong></p>
<ul>
<li>signer不在snapshot的signer中不允许签名</li>
<li>signer不是本区块的签名者需要延时随机一段时候后再签名，是本区块的签名者则直接签名</li>
<li>签名存放在Extra的extraSeal的65个字节中</li>
<li>为了保证机会均等，clique中规定每一个认证节点在连续SIGNER_LIMIT个区块中，最多只能签发一个区块，每一轮中，最多只有SIGNER_COUNT - SIGNER_LIMIT个认证节点可以参与区块签发</li>
<li>为了保证计算难度相同，每个节点在签发时都会判断本节点是不是本轮的inturn节点，若是inturn节点，则该节点产生的区块难度为2，否则为1</li>
</ul>
<h3 id="文章来源"><a href="#文章来源" class="headerlink" title="文章来源"></a>文章来源</h3><blockquote>
<p><a href="https://blog.csdn.net/sportshark/article/details/51905955" target="_blank" rel="external">https://blog.csdn.net/sportshark/article/details/51905955</a></p>
<p><a href="https://blog.csdn.net/sportshark/article/details/51905965" target="_blank" rel="external">https://blog.csdn.net/sportshark/article/details/51905965</a></p>
<p><a href="https://blog.csdn.net/itcastcpp/article/details/80304343" target="_blank" rel="external">https://blog.csdn.net/itcastcpp/article/details/80304343</a></p>
<p><a href="https://www.cnblogs.com/Evsward/p/ethash.html" target="_blank" rel="external">https://www.cnblogs.com/Evsward/p/ethash.html</a></p>
<p><a href="https://www.cnblogs.com/Evsward/p/miner.html" target="_blank" rel="external">https://www.cnblogs.com/Evsward/p/miner.html</a></p>
<p><a href="https://blog.csdn.net/ddffr/article/details/78773961" target="_blank" rel="external">https://blog.csdn.net/ddffr/article/details/78773961</a></p>
<p><a href="https://ethfans.org/posts/Clique-Consensus-Algorithm" target="_blank" rel="external">https://ethfans.org/posts/Clique-Consensus-Algorithm</a></p>
<p><a href="https://segmentfault.com/a/1190000014544347" target="_blank" rel="external">https://segmentfault.com/a/1190000014544347</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;以太坊源码分析&quot;&gt;&lt;a href=&quot;#以太坊源码分析&quot; class=&quot;headerlink&quot; title=&quot;以太坊源码分析&quot;&gt;&lt;/a&gt;以太坊源码分析&lt;/h2&gt;&lt;h3 id=&quot;以太坊共识算法分为两类&quot;&gt;&lt;a href=&quot;#以太坊共识算法分为两类&quot; class=&quot;headerlink&quot; title=&quot;以太坊共识算法分为两类&quot;&gt;&lt;/a&gt;以太坊共识算法分为两类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Ethash算法&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Clique算法&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://jiaotingyu.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Golang" scheme="http://jiaotingyu.me/tags/Golang/"/>
    
      <category term="以太坊" scheme="http://jiaotingyu.me/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>以太坊学习笔记（十五）</title>
    <link href="http://jiaotingyu.me/2018/09/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/"/>
    <id>http://jiaotingyu.me/2018/09/24/以太坊学习笔记（十五）/</id>
    <published>2018-09-23T16:00:00.000Z</published>
    <updated>2020-05-18T15:28:23.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="以太坊数据存储"><a href="#以太坊数据存储" class="headerlink" title="以太坊数据存储"></a>以太坊数据存储</h2><h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><p>区块block主要由header和body两部分组成</p>
<a id="more"></a>
<p>block源码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</div><div class="line">    header       *Header            <span class="comment">//区块头</span></div><div class="line">    uncles       []*Header          <span class="comment">//叔节点</span></div><div class="line">    transactions Transactions       <span class="comment">//交易数组</span></div><div class="line">    hash atomic.Value</div><div class="line">    size atomic.Value</div><div class="line">    td *big.Int                      <span class="comment">//所有区块Difficulty之和</span></div><div class="line">    ReceivedAt   time.Time</div><div class="line">    ReceivedFrom <span class="keyword">interface</span>&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</div><div class="line">    ParentHash  common.Hash    <span class="comment">//指向父区块的指针</span></div><div class="line">    UncleHash   common.Hash    <span class="comment">//block中叔块数组的RLP哈希值</span></div><div class="line">    Coinbase    common.Address <span class="comment">//挖出该区块的人的地址</span></div><div class="line">    Root        common.Hash    <span class="comment">//StateDB中的stat trie的根节点的RLP哈希值</span></div><div class="line">    TxHash      common.Hash    <span class="comment">//tx trie的根节点的哈希值</span></div><div class="line">    ReceiptHash common.Hash    <span class="comment">//receipt trie的根节点的哈希值</span></div><div class="line">    Bloom       Bloom          <span class="comment">//布隆过滤器，用来判断Log对象是否存在</span></div><div class="line">    Difficulty  *big.Int       <span class="comment">//难度系数</span></div><div class="line">    Number      *big.Int       <span class="comment">//区块序号</span></div><div class="line">    GasLimit    <span class="keyword">uint64</span>         <span class="comment">//区块内所有Gas消耗的理论上限</span></div><div class="line">    GasUsed     <span class="keyword">uint64</span>         <span class="comment">//区块内消耗的总Gas</span></div><div class="line">    Time        *big.Int       <span class="comment">//区块应该被创建的时间</span></div><div class="line">    Nonce       BlockNonce     <span class="comment">//挖矿必须的值</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Body <span class="keyword">struct</span> &#123;</div><div class="line">    Transactions []*Transaction <span class="comment">//交易的数组</span></div><div class="line">    Uncles       []*Header</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="MPT树"><a href="#MPT树" class="headerlink" title="MPT树"></a>MPT树</h3><p>MPT是以太坊自定义的树形数据结构</p>
<p>Trie树</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</div><div class="line">    root         node   <span class="comment">//根节点</span></div><div class="line">    db           Database   <span class="comment">//数据库相关</span></div><div class="line">    originalRoot common.Hash    <span class="comment">//初次创建trie时候需要用到</span></div><div class="line">    cachegen, cachelimit <span class="keyword">uint16</span> <span class="comment">//cache次数的计数器，每次Trie的变动提交后自增</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Trie结构体中，root作为整个MPT的根节点，root接口有四种实现类</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> (</div><div class="line">    fullNode <span class="keyword">struct</span> &#123;</div><div class="line">        Children [<span class="number">17</span>]node</div><div class="line">        flags    nodeFlag</div><div class="line">    &#125;</div><div class="line">    shortNode <span class="keyword">struct</span> &#123;</div><div class="line">        Key   []<span class="keyword">byte</span></div><div class="line">        Val   node</div><div class="line">        flags nodeFlag</div><div class="line">    &#125;</div><div class="line">    hashNode  []<span class="keyword">byte</span></div><div class="line">    valueNode []<span class="keyword">byte</span></div><div class="line">)</div></pre></td></tr></table></figure>
<ul>
<li><p>fullNode：有一个容量为17的node数组成员变量Children，数组中前16个空位分别对应16进制(hex)下的0-9a-f，根据子节点的key值16进制形式下的第一位的值，分别对应到16个空位上，Children的第17位留给fullNode的数据部分</p>
</li>
<li><p>shortNode：仅有一个子节点，成员Val对应的该子节点，key是任意长度的字符串。MPT会通过合并只有一个子节点的父节点和其子节点来缩短trie的深度，所以有些节点会有长度更长的key</p>
</li>
<li><p>valueNode：是MPT的叶子节点，valueNode就是所携带数据部分的RLP哈希值，长度32byte，数据的RLP编码值作为valueNode的匹配项存储在数据库里</p>
</li>
<li><p>hashNode：存放32byte的哈希值，也没有子节点，是fullNode或者shortNode对象的RLP哈希值</p>
</li>
</ul>
<p><strong>每个父节点的哈希值来源于所有子节点哈希值的组合，一个顶点的哈希值能够代表一整个树形结构</strong></p>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>以太坊中使用levelDB数据库</p>
<ul>
<li><p>header和block存储规则</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">    headerPrefix        = []<span class="keyword">byte</span>(<span class="string">"h"</span>) <span class="comment">// headerPrefix + num (uint64 big endian) + hash -&gt; header</span></div><div class="line">    tdSuffix            = []<span class="keyword">byte</span>(<span class="string">"t"</span>) <span class="comment">// headerPrefix + num (uint64 big endian) + hash + tdSuffix -&gt; td</span></div><div class="line">    numSuffix           = []<span class="keyword">byte</span>(<span class="string">"n"</span>) <span class="comment">// headerPrefix + num (uint64 big endian) + numSuffix -&gt; hash</span></div><div class="line">    blockHashPrefix     = []<span class="keyword">byte</span>(<span class="string">"H"</span>) <span class="comment">// blockHashPrefix + hash -&gt; num (uint64 big endian)</span></div><div class="line">    bodyPrefix          = []<span class="keyword">byte</span>(<span class="string">"b"</span>) <span class="comment">// bodyPrefix + num (uint64 big endian) + hash -&gt; block body</span></div><div class="line">    blockReceiptsPrefix = []<span class="keyword">byte</span>(<span class="string">"r"</span>) <span class="comment">// blockReceiptsPrefix + num (uint64 big endian) + hash -&gt; block receipts</span></div><div class="line">    lookupPrefix        = []<span class="keyword">byte</span>(<span class="string">"l"</span>) <span class="comment">// lookupPrefix + hash -&gt; transaction/receipt lookup metadata</span></div><div class="line">bloomBitsPrefix     = []<span class="keyword">byte</span>(<span class="string">"B"</span>) <span class="comment">// bloomBitsPrefix + bit (uint16 big endian) + section (uint64 big endian) + hash -&gt; bloom bits</span></div></pre></td></tr></table></figure>
<p>  其中num为区块号 hash为区块哈希值</p>
<p>  Header的父指针是不能修改的，当把Header写入数据库是必须把他的父节点和父节点的父节点等等写入数据库</p>
</li>
</ul>
<ul>
<li><p>交易存储</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteTxLookupEntries</span><span class="params">(db ethdb.Putter, block *types.Block)</span> <span class="title">error</span></span> &#123;</div><div class="line">    <span class="comment">// 遍历每个交易并且编码元数据</span></div><div class="line">    <span class="keyword">for</span> i, tx := <span class="keyword">range</span> block.Transactions() &#123;</div><div class="line">        entry := TxLookupEntry&#123;</div><div class="line">            BlockHash:  block.Hash(),</div><div class="line">            BlockIndex: block.NumberU64(),</div><div class="line">            Index:      <span class="keyword">uint64</span>(i),</div><div class="line">        &#125;</div><div class="line">        data, err := rlp.EncodeToBytes(entry)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> err</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> err := db.Put(<span class="built_in">append</span>(lookupPrefix, tx.Hash().Bytes()...), data); err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> err</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  将区块号、区块哈希值等数据编码进行存储</p>
</li>
<li><p>StateDB模块</p>
<p>  所有的账户由StateDB管理，StateDB中有一个trie结构和一个map结构，都用来存储stateObject，每个stateObject有20bytes的地址，可以作为key使用</p>
</li>
<li><p>存储账户(stateObject)</p>
<p>  一个stateObject对应一个账户，一个账户包含余额、合约发起次数等数据，stateObject还包含了一个trie，用来存储State数据</p>
</li>
</ul>
<h3 id="文章来源："><a href="#文章来源：" class="headerlink" title="文章来源："></a>文章来源：</h3><blockquote>
<p><a href="http://www.blockchainbrother.com/article/805" target="_blank" rel="external">http://www.blockchainbrother.com/article/805</a></p>
<p><a href="https://blog.csdn.net/ddffr/article/details/74517608" target="_blank" rel="external">https://blog.csdn.net/ddffr/article/details/74517608</a></p>
<p><a href="https://juejin.im/post/5a4f3aa9f265da3e5468e08e" target="_blank" rel="external">https://juejin.im/post/5a4f3aa9f265da3e5468e08e</a></p>
<p><a href="https://blog.csdn.net/teaspring/article/details/75390210" target="_blank" rel="external">https://blog.csdn.net/teaspring/article/details/75390210</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;以太坊数据存储&quot;&gt;&lt;a href=&quot;#以太坊数据存储&quot; class=&quot;headerlink&quot; title=&quot;以太坊数据存储&quot;&gt;&lt;/a&gt;以太坊数据存储&lt;/h2&gt;&lt;h3 id=&quot;区块&quot;&gt;&lt;a href=&quot;#区块&quot; class=&quot;headerlink&quot; title=&quot;区块&quot;&gt;&lt;/a&gt;区块&lt;/h3&gt;&lt;p&gt;区块block主要由header和body两部分组成&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://jiaotingyu.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Golang" scheme="http://jiaotingyu.me/tags/Golang/"/>
    
      <category term="以太坊" scheme="http://jiaotingyu.me/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>以太坊学习笔记（十四）</title>
    <link href="http://jiaotingyu.me/2018/09/22/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
    <id>http://jiaotingyu.me/2018/09/22/以太坊学习笔记（十四）/</id>
    <published>2018-09-21T16:00:00.000Z</published>
    <updated>2020-05-18T15:28:17.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="以太坊源码分析"><a href="#以太坊源码分析" class="headerlink" title="以太坊源码分析"></a>以太坊源码分析</h2><h3 id="RLPx加密通信协议"><a href="#RLPx加密通信协议" class="headerlink" title="RLPx加密通信协议"></a>RLPx加密通信协议</h3><p>PLPx属于会话层协议，主要功能是在节点之间建立并维持通信</p>
<p>RLPx协议每次建立连接都使用不同的密钥，即使现有的密钥泄露也不会导致之前的信息被破解</p>
<p>实现原理：连接双方各自生成一个私钥，然后将得到的公钥发送给对方，双方再利用自己的私钥和对方的公钥生成一个共享密钥，本次传输将使用这个共享密钥</p>
<a id="more"></a>
<p>主要成员：</p>
<ul>
<li><p>newRLPx()：返回一个transport对象</p>
</li>
<li><p>ReadMsg()：调用读写器的ReadMsg</p>
</li>
<li><p>WriteMsg()：调用读写器的WriteMsg写信息</p>
</li>
<li><p>close()：关闭连接并返回关闭原因</p>
</li>
<li><p>doEncHandshake()： 加密握手，成功后返回带有共享密钥的secrets对象</p>
</li>
<li><p>doProtoHandshake()：协议握手，输入输出均是protoHandshake对象</p>
</li>
<li><p>doEncHandshake()：加密握手，握手过程分为两个部分</p>
<ul>
<li><p>发起方使用自己的私钥和对方的公钥生成一个共享token，并使用一个随机数和一个随机生成的私钥对其签名，将这些信息发送给接收方</p>
</li>
<li><p>接收方也使用自己的私钥和对方的公钥生成一个token，并使用随机数和发送过来的随机数进行签名，将信息再次返回</p>
</li>
<li><p>双方通过各自得到的信息生成一组共享密钥</p>
</li>
</ul>
</li>
</ul>
<h3 id="Diffie-–-Hellman"><a href="#Diffie-–-Hellman" class="headerlink" title="Diffie – Hellman"></a>Diffie – Hellman</h3><p>RLPx协议的实现过程其实是一次Diffie–Hellman密钥交换</p>
<p>Diffie–Hellman是一种安全协议，让双方在完全没有对方任何预先信息的条件下通过不安全信道建立起一个密钥，这个密钥一般作为“对称加密”的密钥而被双方在后续数据传输中使用</p>
<h3 id="以太坊公钥私钥"><a href="#以太坊公钥私钥" class="headerlink" title="以太坊公钥私钥"></a>以太坊公钥私钥</h3><p>私钥本质上是一个包含64位的随机数</p>
<p>私钥只能由钱包自己来生成，加密存储在keyStore目录下</p>
<p>一个钱包地址只有一个私钥，谁拥有私钥，谁就拥有了这些数字货币的控制权</p>
<p>公钥由私钥通过椭圆曲线加密算法生成的，变换后是一个65个byte的数组</p>
<p>拥有私钥，就可以算出公钥，而公钥不能计算私钥</p>
<h3 id="文章来源"><a href="#文章来源" class="headerlink" title="文章来源:"></a>文章来源:</h3><blockquote>
<p><a href="http://www.8btc.com/blockchain-11-rlpx" target="_blank" rel="external">http://www.8btc.com/blockchain-11-rlpx</a></p>
<p><a href="https://blog.csdn.net/itcastcpp/article/details/80305636" target="_blank" rel="external">https://blog.csdn.net/itcastcpp/article/details/80305636</a></p>
<p><a href="https://blog.csdn.net/weixin_41814722/article/details/80680749" target="_blank" rel="external">https://blog.csdn.net/weixin_41814722/article/details/80680749</a></p>
<p><a href="https://www.cnblogs.com/hyddd/p/7689132.html" target="_blank" rel="external">https://www.cnblogs.com/hyddd/p/7689132.html</a></p>
<p><a href="https://blog.csdn.net/lee244868149/article/details/51790397" target="_blank" rel="external">https://blog.csdn.net/lee244868149/article/details/51790397</a></p>
<p><a href="https://www.jianshu.com/p/61493dbe7cc3" target="_blank" rel="external">https://www.jianshu.com/p/61493dbe7cc3</a></p>
<p><a href="https://bitshuo.com/topic/58c7a1ef0a3de8932e6f753b" target="_blank" rel="external">https://bitshuo.com/topic/58c7a1ef0a3de8932e6f753b</a></p>
<p><a href="https://blog.csdn.net/luoyhang003/article/details/79970254" target="_blank" rel="external">https://blog.csdn.net/luoyhang003/article/details/79970254</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;以太坊源码分析&quot;&gt;&lt;a href=&quot;#以太坊源码分析&quot; class=&quot;headerlink&quot; title=&quot;以太坊源码分析&quot;&gt;&lt;/a&gt;以太坊源码分析&lt;/h2&gt;&lt;h3 id=&quot;RLPx加密通信协议&quot;&gt;&lt;a href=&quot;#RLPx加密通信协议&quot; class=&quot;headerlink&quot; title=&quot;RLPx加密通信协议&quot;&gt;&lt;/a&gt;RLPx加密通信协议&lt;/h3&gt;&lt;p&gt;PLPx属于会话层协议，主要功能是在节点之间建立并维持通信&lt;/p&gt;
&lt;p&gt;RLPx协议每次建立连接都使用不同的密钥，即使现有的密钥泄露也不会导致之前的信息被破解&lt;/p&gt;
&lt;p&gt;实现原理：连接双方各自生成一个私钥，然后将得到的公钥发送给对方，双方再利用自己的私钥和对方的公钥生成一个共享密钥，本次传输将使用这个共享密钥&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://jiaotingyu.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Golang" scheme="http://jiaotingyu.me/tags/Golang/"/>
    
      <category term="以太坊" scheme="http://jiaotingyu.me/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>以太坊学习笔记（十三）</title>
    <link href="http://jiaotingyu.me/2018/09/21/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/"/>
    <id>http://jiaotingyu.me/2018/09/21/以太坊学习笔记（十三）/</id>
    <published>2018-09-20T16:00:00.000Z</published>
    <updated>2020-05-18T15:28:01.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="以太坊源代码分析"><a href="#以太坊源代码分析" class="headerlink" title="以太坊源代码分析"></a>以太坊源代码分析</h2><h3 id="P2P底层通信"><a href="#P2P底层通信" class="headerlink" title="P2P底层通信"></a>P2P底层通信</h3><p>P2P即对等网络，是一种在对等者（Peer）之间分配任务和工作负载的分布式应用架构</p>
<p>网络中所有的个体地位和功能上是平等的</p>
<p>另外网络中的个体不需要与其他所有个体保持通信，只需要与相邻个体保持通信</p>
<p>以太坊使用了kademlia网络，是一种分布式散列表(DHT)技术，以异或运算为距离度量基础</p>
<a id="more"></a>
<h3 id="ProtocolManager"><a href="#ProtocolManager" class="headerlink" title="ProtocolManager"></a>ProtocolManager</h3><p>以太坊中通过ProtocolManager来管理个体间的通信</p>
<p>主要成员包括：</p>
<ul>
<li><p>peerSet()：来缓存相邻个体列表</p>
</li>
<li><p>通过通道和订阅的方式进行信息更新</p>
</li>
<li><p>Fetcher：收集其他成员的消息，来安排获取请求</p>
</li>
<li><p>Downloader：负责所有向相邻个体主动发起的同步流程</p>
</li>
<li><p>Start()：启动p2p通信</p>
</li>
</ul>
<p>Start分别启动四个函数</p>
<p><img src="https://s1.ax1x.com/2018/07/15/PQSKT1.png" alt="PQSKT1.png"></p>
<p>四个函数的逻辑分别是：</p>
<ul>
<li><p>广播新出现的交易对象</p>
</li>
<li><p>广播新挖掘的区块</p>
</li>
<li><p>定时与相邻个体进行区块链的同步</p>
</li>
<li><p>将新出现的交易对象均匀的同步给相邻个体</p>
</li>
</ul>
<p>注意：本体向其他个体主动发起的通信中，按照数据类型可分两类：交易tx和区块block；而按照通信方式划分，亦可分为广播新的单个数据和同步一组同类型数据</p>
<ul>
<li>handle()：主动请求的回调函数</li>
</ul>
<p>在节点间通信时，除了主动互相通知外，还需要一种被请求调用的通信，使用handle函数来实现回调</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *ProtocolManager)</span> <span class="title">handle</span><span class="params">(p *peer)</span> <span class="title">error</span></span> &#123;</div><div class="line">    td, head, genesis := pm.blockchain.Status()</div><div class="line">    p.Handshake(pm.networkId, td, head, genesis)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> rw, ok := p.rw.(*meteredMsgReadWriter); ok &#123;</div><div class="line">        rm.Init(p.version)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    pm.peers.Register(p)</div><div class="line">    <span class="keyword">defer</span> pm.removePeer(p.id)</div><div class="line"></div><div class="line">    pm.downloader.RegisterPeer(p.id, p.version, p)</div><div class="line"></div><div class="line">    pm.syncTransactions(p)</div><div class="line">    ...</div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">        <span class="keyword">if</span> err := pm.handleMsg(p); err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> err</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>handle函数的逻辑为与对方确定状态，初始化读写通道，将要访问的节点存入相邻列表，在Downloader成员注册节点，向对方节点发送请求，监听返回的消息并进行处理</p>
<h3 id="建立新peer连接"><a href="#建立新peer连接" class="headerlink" title="建立新peer连接"></a>建立新peer连接</h3><p>Node.Start()中首先会创建p2p.Server{}，将Node中载入的所有<service>实现体中的Protocol都作为Server.Protocols列表，启动Server对象，并将Server对象作为参数去逐一启动每个<service>实现体,ProtocolManager.Protocols最终被导入了p2p.Server.Protocols</service></service></p>
<h3 id="文章来源"><a href="#文章来源" class="headerlink" title="文章来源:"></a>文章来源:</h3><blockquote>
<p><a href="https://blog.csdn.net/screscent/article/details/79416251" target="_blank" rel="external">https://blog.csdn.net/screscent/article/details/79416251</a></p>
<p><a href="https://blog.csdn.net/screscent/article/details/79416318" target="_blank" rel="external">https://blog.csdn.net/screscent/article/details/79416318</a></p>
<p><a href="http://baijiahao.baidu.com/s?id=1604499731426119688&amp;wfr=spider&amp;for=pc" target="_blank" rel="external">http://baijiahao.baidu.com/s?id=1604499731426119688&amp;wfr=spider&amp;for=pc</a></p>
<p><a href="https://blog.csdn.net/teaspring/article/details/78455046" target="_blank" rel="external">https://blog.csdn.net/teaspring/article/details/78455046</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;以太坊源代码分析&quot;&gt;&lt;a href=&quot;#以太坊源代码分析&quot; class=&quot;headerlink&quot; title=&quot;以太坊源代码分析&quot;&gt;&lt;/a&gt;以太坊源代码分析&lt;/h2&gt;&lt;h3 id=&quot;P2P底层通信&quot;&gt;&lt;a href=&quot;#P2P底层通信&quot; class=&quot;headerlink&quot; title=&quot;P2P底层通信&quot;&gt;&lt;/a&gt;P2P底层通信&lt;/h3&gt;&lt;p&gt;P2P即对等网络，是一种在对等者（Peer）之间分配任务和工作负载的分布式应用架构&lt;/p&gt;
&lt;p&gt;网络中所有的个体地位和功能上是平等的&lt;/p&gt;
&lt;p&gt;另外网络中的个体不需要与其他所有个体保持通信，只需要与相邻个体保持通信&lt;/p&gt;
&lt;p&gt;以太坊使用了kademlia网络，是一种分布式散列表(DHT)技术，以异或运算为距离度量基础&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://jiaotingyu.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Golang" scheme="http://jiaotingyu.me/tags/Golang/"/>
    
      <category term="以太坊" scheme="http://jiaotingyu.me/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>Golang学习笔记（六）</title>
    <link href="http://jiaotingyu.me/2018/09/20/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://jiaotingyu.me/2018/09/20/Golang学习笔记（六）/</id>
    <published>2018-09-19T16:00:00.000Z</published>
    <updated>2020-05-19T08:46:40.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Golang记录"><a href="#Golang记录" class="headerlink" title="Golang记录"></a>Golang记录</h2><p><strong>copy复制会比等号复制慢。但是copy复制为值复制，改变原切片的值不会影响新切片。而等号复制为指针复制，改变原切片或新切片都会对另一个产生影响</strong>。</p>
<a id="more"></a>
<h4 id="c-声明数组"><a href="#c-声明数组" class="headerlink" title="c++声明数组"></a>c++声明数组</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//静态 定义了数组array，并未对数组进行初始化 </span></div><div class="line"><span class="keyword">int</span> array[<span class="number">100</span>]; </div><div class="line"><span class="comment">//静态 定义并初始化了数组</span></div><div class="line">array <span class="keyword">int</span> array[<span class="number">100</span>] = &#123;<span class="number">1</span>，<span class="number">2</span>&#125;; </div><div class="line"><span class="comment">//动态 分配了长度为100的数组</span></div><div class="line">array <span class="keyword">int</span>* array = <span class="built_in">new</span> <span class="keyword">int</span>[<span class="number">100</span>];  </div><div class="line"><span class="built_in">delete</span> []array; </div><div class="line"><span class="comment">//动态 为长度为100的数组array初始化前两个元素 </span></div><div class="line"><span class="keyword">int</span>* array = <span class="built_in">new</span> <span class="keyword">int</span>[<span class="number">100</span>](<span class="number">1</span>，<span class="number">2</span>); </div><div class="line"><span class="built_in">delete</span> []array;</div></pre></td></tr></table></figure>
<h4 id="golang-声明数组"><a href="#golang-声明数组" class="headerlink" title="golang 声明数组"></a>golang 声明数组</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第一种 </span></div><div class="line"><span class="comment">//var &lt;数组名称&gt; [&lt;数组长度&gt;]&lt;数组元素&gt; </span></div><div class="line"><span class="keyword">var</span> arr [<span class="number">2</span>]<span class="keyword">int</span> </div><div class="line">arr[<span class="number">0</span>]=<span class="number">1</span> </div><div class="line">arr[<span class="number">1</span>]=<span class="number">2</span> </div><div class="line"></div><div class="line"><span class="comment">//第二种 </span></div><div class="line"><span class="comment">//var &lt;数组名称&gt; = [&lt;数组长度&gt;]&lt;数组元素&gt;&#123;元素1,元素2,...&#125; </span></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125; </div><div class="line"><span class="comment">//或者 </span></div><div class="line">arr := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125; </div><div class="line"></div><div class="line"><span class="comment">//第三种 </span></div><div class="line"><span class="comment">//var &lt;数组名称&gt; [&lt;数组长度&gt;]&lt;数组元素&gt; = [...]&lt;元素类型&gt;&#123;元素1,元素2,...&#125; </span></div><div class="line"><span class="keyword">var</span> arr = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125; </div><div class="line"><span class="comment">//或者 </span></div><div class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125; </div><div class="line"></div><div class="line"><span class="comment">//第四种 </span></div><div class="line"><span class="comment">//var &lt;数组名称&gt; [&lt;数组长度&gt;]&lt;数组元素&gt; = [...]&lt;元素类型&gt;&#123;索引1:元素1,索引2:元素2,...&#125;</span></div><div class="line"><span class="keyword">var</span> arr = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>:<span class="number">1</span>,<span class="number">0</span>:<span class="number">2</span>&#125; </div><div class="line"><span class="comment">//或者 </span></div><div class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>:<span class="number">1</span>,<span class="number">0</span>:<span class="number">2</span>&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Golang记录&quot;&gt;&lt;a href=&quot;#Golang记录&quot; class=&quot;headerlink&quot; title=&quot;Golang记录&quot;&gt;&lt;/a&gt;Golang记录&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;copy复制会比等号复制慢。但是copy复制为值复制，改变原切片的值不会影响新切片。而等号复制为指针复制，改变原切片或新切片都会对另一个产生影响&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://jiaotingyu.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Golang" scheme="http://jiaotingyu.me/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>以太坊学习笔记（十二）</title>
    <link href="http://jiaotingyu.me/2018/09/20/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
    <id>http://jiaotingyu.me/2018/09/20/以太坊学习笔记（十二）/</id>
    <published>2018-09-19T16:00:00.000Z</published>
    <updated>2020-05-18T15:27:48.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="以太坊源代码"><a href="#以太坊源代码" class="headerlink" title="以太坊源代码"></a>以太坊源代码</h2><h3 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h3><p>共识算法使用Engine接口，分为两种实现方式：</p>
<ol>
<li><p>基于运算能力的Ethash算法</p>
</li>
<li><p>基于“同行”认证的Clique算法</p>
<a id="more"></a>
</li>
</ol>
<p>Engine接口的函数包括以下：</p>
<ul>
<li><p>VerifyHeader()，VerifyHeaders()，VerifyUncles()：验证区块的成员是否合理</p>
</li>
<li><p>Prepare()：在Header创建时调用，对Difficulty等属性赋值</p>
</li>
<li><p>Finalize()：在区块的数据成员都赋值完毕是，生成Root，TxHash，UncleHash，ReceiptHash等成员</p>
</li>
<li><p>Seal()：对执行过Finalize函数的区块进行授权，成功返回区块的所有成员，该区块就是完成区块，可以被广播也可以插入到区块链</p>
</li>
<li><p>VerifySeal()：用来确定区块是否已经Seal操作</p>
</li>
</ul>
<h3 id="Ethash共识算法"><a href="#Ethash共识算法" class="headerlink" title="Ethash共识算法"></a>Ethash共识算法</h3><p>Ethash称为PoW(Proof-of-Work)</p>
<p>基本原理公式为：</p>
<p>$$<br>$$ RAND(h, n)  &lt;=  M / d $$<br>$$<br>M表示一个极大的数，d表示Header成员Difficulty</p>
<p>RAND()用来产生随机数，h是Header的哈希值，n表示Header成员Nonce</p>
<p>该公式表示在最大不超过M的范围内，找到一个随机数数，如果这个数符合条件(&lt;=M/d)，那么就认为Seal()成功</p>
<h3 id="mine-函数"><a href="#mine-函数" class="headerlink" title="mine()函数"></a>mine()函数</h3><p>在实现Seal()函数过程中，会以多线程的方式并行调用mine()函数，线程个数等于Ethash.threads</p>
<p>主要代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span> <span class="title">mine</span><span class="params">(block *Block, id <span class="keyword">int</span>, seed <span class="keyword">uint64</span>, abort <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, found <span class="keyword">chan</span> *Block)</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> (</div><div class="line">        header = block.Header()</div><div class="line">        hash   = header.HashNoNonce().Bytes()</div><div class="line">        target = <span class="built_in">new</span>(big.Int).Div(maxUint256, header.Difficulty)</div><div class="line">        number = header.Number.Uint64()</div><div class="line">        dataset = ethash.dataset(number)</div><div class="line">        nonce  = seed</div><div class="line">    )</div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">        <span class="keyword">select</span> &#123;</div><div class="line">        <span class="keyword">case</span> &lt;-abort:</div><div class="line">            ...; <span class="keyword">return</span></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            digest, result := hashimotoFull(dataset, hash, nonce) <span class="comment">// compute the PoW value of this nonce</span></div><div class="line">            <span class="keyword">if</span> <span class="built_in">new</span>(big.Int).SetBytes(result).Cmp(target) &lt;= <span class="number">0</span> &#123; <span class="comment">// x.Cmp(y) &lt;= 0 means x &lt;= y</span></div><div class="line">                header = types.CopyHeader(header)</div><div class="line">                header.Nonce = types.EncodeNonce(nonce)</div><div class="line">                header.MixDigest = common.BytesToHash(digest)</div><div class="line">                found&lt;- block.WithSeal(header)</div><div class="line">                <span class="keyword">return</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        nonce++</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数定义了一组局部变量，然后是一个for循环，调用hashimotoFull()，当函数的返回值符合条件时，复制Header对象，Nonce、MixDigest赋值，返回授权过的区块</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashimotoFull</span><span class="params">(dataset []<span class="keyword">uint32</span>, hash []<span class="keyword">byte</span>, nonce <span class="keyword">uint64</span>)</span> <span class="params">([]<span class="keyword">byte</span>, []<span class="keyword">byte</span>)</span></span> &#123;</div><div class="line">    lookup := <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">uint32</span>)</span> []<span class="title">uint32</span></span> &#123;</div><div class="line">        offset := index * hashWords</div><div class="line">        <span class="keyword">return</span> dataset[offset : offset+hashWords]</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> hashimoto(hash, nonce, <span class="keyword">uint64</span>(<span class="built_in">len</span>(dataset))*<span class="number">4</span>, lookup)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashimotoLight</span>（<span class="title">size</span> <span class="title">uint64</span>, <span class="title">cache</span> []<span class="title">uint32</span>, <span class="title">hash</span> []<span class="title">byte</span>, <span class="title">nonce</span> <span class="title">uint64</span>） <span class="params">([]<span class="keyword">byte</span>, []<span class="keyword">byte</span>)</span></span> &#123;</div><div class="line">    lookup := <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">uint32</span>)</span> []<span class="title">uint32</span></span> &#123;</div><div class="line">        rawData := generateDatasetItem(cache, index, keccak512)</div><div class="line">        data := <span class="built_in">make</span>([]<span class="keyword">uint32</span>, <span class="built_in">len</span>(rawData)/<span class="number">4</span>)</div><div class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(data); i++ &#123;</div><div class="line">            data[i] = binary.LittleEndian.Uint32(rawData[i*<span class="number">4</span>:])</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> data</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> hashimoto(hash, nonce, size, lookup)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上两个函数类似，都返回hashimoto()，相比于Light函数，Full函数调用的@size参数更大，lookup也更大。Full函数是Seal()调用的，Light()是VerifySeal()准备的</p>
<h3 id="hashimoto-函数"><a href="#hashimoto-函数" class="headerlink" title="hashimoto()函数"></a>hashimoto()函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// consensus/ethash/algorithm.go</span></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">hashimoto</span><span class="params">(hash []<span class="keyword">byte</span>, nonce <span class="keyword">uint64</span>, size <span class="keyword">uint64</span>, lookup(index <span class="keyword">uint32</span>)</span> []<span class="title">uint32</span>) <span class="params">(digest []<span class="keyword">byte</span>, result []<span class="keyword">byte</span>)</span></span></div></pre></td></tr></table></figure>
<p>传入的参数包括：</p>
<ul>
<li>hash 区块哈希值</li>
<li>nonce 区块nonce</li>
<li>lookup() 非线性表查找的哈希函数</li>
<li>size 查找的非线性表格的容量</li>
<li>digest 32bytes的字节串</li>
<li>result 32bytes的字节串</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/07/14/PMdGWR.png" alt="PMdGWR.png"></p>
<p>经过一系列多次、多种的哈希运算，hashimoto()返回两个长度均为32的byte数组 digest[]和result[]</p>
<h3 id="Clique共识算法"><a href="#Clique共识算法" class="headerlink" title="Clique共识算法"></a>Clique共识算法</h3><p>Clique算法又称Proof-of-Authortiy(PoA)</p>
<p>Clique算法实现公式：</p>
<p>$$ n = F(pr, h) $$</p>
<p>F()是椭圆曲线数字签名算法(ECDSA)，n是生成的数字签名，pr是公钥，h是被加密的内容</p>
<p>Clique.Seal()函数的基本逻辑就是：有一个Address类型地址用作数字签名的公钥，如果它是已认证的，则执行指定的数字签名算法</p>
<p>Clique的认证机制包含以下规则</p>
<ul>
<li>所有的地址分为已认证和未认证的</li>
<li>已认证和未认证可以互相转换，必须通过投票机制完成</li>
<li>一张投票包括：投票方地址，被投票地址，和被投票地址的新认证状态</li>
<li>任意地址A只能给地址B投一张票</li>
</ul>
<p>Clique算法中的投票系统的巧妙之处在于，每张投票并不是某个投票方主动“投”出来的，而是随机组合出来的</p>
<p><img src="https://s1.ax1x.com/2018/07/14/PMw1nf.png" alt="PMw1nf.png"></p>
<p>新区块的Coinbase是一个随机的被投票地址</p>
<p>首先从proposals中筛选出有效的不记名投票，获取有效的被投票地址列表，随机选取一个地址作为Coinbase。新区块的Coinbase会在后面的认证环节当作被投票地址</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>Ethash算法(PoW)基于运算能力来筛选出挖掘区块的获胜者，运算过程中使用了大量、多次、多种的哈希函数，通过极高的计算资源消耗，来限制某些节点通过超常规的计算能力轻易形成“中心化”倾向</p>
</li>
<li><p>Clique算法(PoA)利用数字签名算法完成Seal操作，签名所用公钥必须是已认证的。所有认证地址基于特殊的投票地址进行动态管理，记名投票由不记名投票和投票方地址随机组合而成，杜绝重复的不记名投票，严格限制外部代码恶意操纵投票数据</p>
</li>
<li><p>以太坊还在区块结构中增加了叔区块(uncles)成员以加大计算资源的消耗，并通过在交易执行环节对叔区块作者(挖掘者)的奖励，以收益机制来调动网络中各节点运算资源分布更加均匀。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;以太坊源代码&quot;&gt;&lt;a href=&quot;#以太坊源代码&quot; class=&quot;headerlink&quot; title=&quot;以太坊源代码&quot;&gt;&lt;/a&gt;以太坊源代码&lt;/h2&gt;&lt;h3 id=&quot;共识算法&quot;&gt;&lt;a href=&quot;#共识算法&quot; class=&quot;headerlink&quot; title=&quot;共识算法&quot;&gt;&lt;/a&gt;共识算法&lt;/h3&gt;&lt;p&gt;共识算法使用Engine接口，分为两种实现方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;基于运算能力的Ethash算法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基于“同行”认证的Clique算法&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://jiaotingyu.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Golang" scheme="http://jiaotingyu.me/tags/Golang/"/>
    
      <category term="以太坊" scheme="http://jiaotingyu.me/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>Golang学习笔记（五）</title>
    <link href="http://jiaotingyu.me/2018/09/19/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://jiaotingyu.me/2018/09/19/Golang学习笔记（五）/</id>
    <published>2018-09-18T16:00:00.000Z</published>
    <updated>2020-05-19T08:42:25.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言特性"><a href="#Go语言特性" class="headerlink" title="Go语言特性"></a>Go语言特性</h2><a id="more"></a>
<ul>
<li>可直接编译成机器码，直接生成可执行二进制文件</li>
<li>静态类型语言，可以在编译的时候检查出来隐藏的大多数问题<ul>
<li>动态类型语言：是指在运行期间才去做数据类型检查的语言，说的是<strong>数据类型</strong></li>
<li>动态语言：说的是运行是改变结构，说的是<strong>代码结构</strong></li>
<li>静态类型语言：静态语言的数据类型是在编译期间（或运行之前）确定的，编写代码的时候要明确确定变量的数据类型</li>
<li>静态语言：与动态语言相对应的，运行时结构不可变的语言就是静态语言</li>
</ul>
</li>
<li>大量的第三方包可以使用</li>
<li>语言层面支持并发 go hello（）</li>
<li>支持垃圾回收</li>
<li>语言简洁，关键字只有25个，支持继承、重载、对象</li>
<li>跨平台，引用plan9的代码，不依赖系统信息<ul>
<li>Plan9是一个分布式操作系统，它能把网络上一切的资源当作文件来进行使用。Plan9中最本质的思想是“一切皆是文件”</li>
</ul>
</li>
</ul>
<h2 id="Go语言的优劣"><a href="#Go语言的优劣" class="headerlink" title="Go语言的优劣"></a>Go语言的优劣</h2><ul>
<li>Go语言适合做服务端程序，例如各种web程序，服务器软件，命令行工具</li>
<li>Go语言不适合开发有图形界面的应用程序，官方没有提供相关的图形库</li>
<li>不支持多态<ul>
<li>多态：多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说：允许将子类类型的指针赋值给父类类型的指针（一个接口，多种方法）。<br>C++ 支持两种多态性：编译时多态性，运行时多态性。<br>a、编译时多态性（静态多态）：通过重载函数实现<br>b、运行时多态性（动态多态）：通过虚函数实现。</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Go语言特性&quot;&gt;&lt;a href=&quot;#Go语言特性&quot; class=&quot;headerlink&quot; title=&quot;Go语言特性&quot;&gt;&lt;/a&gt;Go语言特性&lt;/h2&gt;
    
    </summary>
    
      <category term="技术" scheme="http://jiaotingyu.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Golang" scheme="http://jiaotingyu.me/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>以太坊学习笔记（十一）</title>
    <link href="http://jiaotingyu.me/2018/09/17/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/"/>
    <id>http://jiaotingyu.me/2018/09/17/以太坊学习笔记（十一）/</id>
    <published>2018-09-16T16:00:00.000Z</published>
    <updated>2020-05-18T15:28:30.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="以太坊源代码"><a href="#以太坊源代码" class="headerlink" title="以太坊源代码"></a>以太坊源代码</h2><h3 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h3><p>在以太坊中miner包负责提供新挖的区块</p>
<p>公共类Miner用于实现挖矿功能，里面包含一个worker类型的成员变量，woker里面有一组Agent接口类型对象</p>
<p>Work结构体用于携带数据</p>
<p>数据传输过程：worder把work对象发送给每个Agent，其中的Agent完成挖矿是，将一个经过授权的Block加上Work返回给worder</p>
<p>一个新区块被挖掘代码实现分为两步：</p>
<ol>
<li><p>组装一个新区块，这个区块各个数据基本完整，并且所有交易执行完毕，所有收据都记录完毕</p>
</li>
<li><p>补全区块其它的成员属性，完成授权</p>
<a id="more"></a>
</li>
</ol>
<h3 id="miner包解析"><a href="#miner包解析" class="headerlink" title="miner包解析"></a>miner包解析</h3><p>Miner类</p>
<ul>
<li><p>New()：在对miner的成员变量初始化完成后，创建worker对象，创建完成后运行miner.Update()函数</p>
</li>
<li><p>Update()：Update监听有关Downloader的事件，当收到Downloader的StartEvent时，说明正在下载新区块，此时停止挖掘工作，继续监听；当收到DoneEvent或FailEvent时，说明下载完成或下载失败，则继续挖掘新区块，停止监听</p>
</li>
</ul>
<p>Worker类</p>
<ul>
<li><p>Update()：监听ChainHeadEvent，ChainSideEvent，TxPreEvent几个事件</p>
<ul>
<li>ChainHeadEvent事件是区块链中加入了一个新的区块作为链头，worker会立刻开始准备挖掘</li>
<li>ChainSideEvent事件是区块链中加入一个新区块作为链头的旁支，worker会把区块加入possibleUncles[]，作为新区块可能的Uncle</li>
<li>TxPreEvent事件是一个新的交易tx加入TxPool，worker把tx加入Work.txs数组</li>
</ul>
</li>
<li><p>wait()：该函数会一直等待Agent发送回来新的Block和Work对象</p>
</li>
<li><p>commitNewWork()：完成待挖掘区块的组装</p>
</li>
</ul>
<p>CpuAgent类</p>
<ul>
<li><p>update()：一直监听相关channel，如果收到Work对象，启动mine()函数；如果收到停止消息，退出一切相关操作</p>
</li>
<li><p>mine()：调用Engine.Seal()函数，对区块进行授权，如果成功，将Block和Work一起发送给worker</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;以太坊源代码&quot;&gt;&lt;a href=&quot;#以太坊源代码&quot; class=&quot;headerlink&quot; title=&quot;以太坊源代码&quot;&gt;&lt;/a&gt;以太坊源代码&lt;/h2&gt;&lt;h3 id=&quot;挖矿&quot;&gt;&lt;a href=&quot;#挖矿&quot; class=&quot;headerlink&quot; title=&quot;挖矿&quot;&gt;&lt;/a&gt;挖矿&lt;/h3&gt;&lt;p&gt;在以太坊中miner包负责提供新挖的区块&lt;/p&gt;
&lt;p&gt;公共类Miner用于实现挖矿功能，里面包含一个worker类型的成员变量，woker里面有一组Agent接口类型对象&lt;/p&gt;
&lt;p&gt;Work结构体用于携带数据&lt;/p&gt;
&lt;p&gt;数据传输过程：worder把work对象发送给每个Agent，其中的Agent完成挖矿是，将一个经过授权的Block加上Work返回给worder&lt;/p&gt;
&lt;p&gt;一个新区块被挖掘代码实现分为两步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;组装一个新区块，这个区块各个数据基本完整，并且所有交易执行完毕，所有收据都记录完毕&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;补全区块其它的成员属性，完成授权&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://jiaotingyu.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Golang" scheme="http://jiaotingyu.me/tags/Golang/"/>
    
      <category term="以太坊" scheme="http://jiaotingyu.me/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>以太坊学习笔记（十）</title>
    <link href="http://jiaotingyu.me/2018/09/15/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89/"/>
    <id>http://jiaotingyu.me/2018/09/15/以太坊学习笔记（十）/</id>
    <published>2018-09-14T16:00:00.000Z</published>
    <updated>2020-05-18T15:27:42.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="以太坊源代码"><a href="#以太坊源代码" class="headerlink" title="以太坊源代码"></a>以太坊源代码</h2><p>以太坊中所有的数据都是以键值对的形式存在，使用的底层数据库LevelDB</p>
<p>交易操作的记录以及相关的数据构成了区块</p>
<p>交易的结果以账户的状态存在</p>
<a id="more"></a>
<p>各个数据单元层次如下图：</p>
<p><a href="https://imgchr.com/i/PKkL26" target="_blank" rel="external"><img src="https://s1.ax1x.com/2018/07/12/PKkL26.png" alt="PKkL26.png"></a></p>
<p>各个数据单元使用Merkle-PatriciaTrie(MPT)数据结构组织管理数据</p>
<h3 id="区块Block"><a href="#区块Block" class="headerlink" title="区块Block"></a>区块Block</h3><p>账户的活动都是在区块中存储，每个区块都有一个交易对象的列表</p>
<p>交易的结果由一个Receipt对象和一组Log对象记录</p>
<p>不同的区块通过ParentHash指针串联成单向链表</p>
<p>区块的结构分为Header和Body</p>
<ul>
<li><p>Header的成员变量：</p>
<ul>
<li>ParentHash：指向父区块的指针，每个区块有且只有一个父区块</li>
<li>Coinbase：区块的矿工地址</li>
<li>UncleHash：区块结构体成员uncles的RLP（Recursive Length Prefix，递归长度前缀编码）哈希值</li>
<li>Root：StateDB中的状态树的根节点的RLP哈希值</li>
<li>TxHash：Tx树的根节点的RLP哈希值</li>
<li>ReceiptHash：接收树的根节点的RLP哈希值</li>
<li>Bloom：过滤器，用来判断log对象是否存在</li>
<li>Difficulty：区块难度</li>
<li>Number：区块序号</li>
<li>Time：区块创建时间</li>
<li>GasLimit：区块所有Gas消耗上限</li>
<li>GasUsed：区块的操作执行实际消耗的Gas总和</li>
<li>Nonce：64位哈希数</li>
</ul>
</li>
<li><p>Body的成员变量：</p>
<ul>
<li>td（totalDifficulty）整个区块链表所有的区块Difficulty的总和</li>
<li>Uncles 为了防止以太坊网络波动过大</li>
</ul>
</li>
</ul>
<p>block的唯一标识符就是Header成员的RLP哈希值</p>
<h3 id="区块链操作"><a href="#区块链操作" class="headerlink" title="区块链操作"></a>区块链操作</h3><ul>
<li><p>查找 区块链中存在成员currentBlock，指向当前最新的区块</p>
</li>
<li><p>插入和删除 区块链的header中存在ParentHash的向前指针，这个值不能随意修改，当需要插入时，从新的header开始回溯，保证所有的parent都写入数据库，一般插入和删除时同时出现的</p>
</li>
</ul>
<h3 id="Merkle-Patricia-Trie-MPT"><a href="#Merkle-Patricia-Trie-MPT" class="headerlink" title="Merkle-Patricia Trie(MPT)"></a>Merkle-Patricia Trie(MPT)</h3><p>MPT是以太坊自定义的树形数据结构</p>
<p>MPT 的节点分为四种：</p>
<ul>
<li>fullNode：可以携带多个子节点的父节点</li>
<li>shortNode：仅有一个子节点的父节点</li>
<li>valueNode：MPT中的子节点</li>
<li>hashNode：fullNode或者shortNode的RLP哈希值</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;以太坊源代码&quot;&gt;&lt;a href=&quot;#以太坊源代码&quot; class=&quot;headerlink&quot; title=&quot;以太坊源代码&quot;&gt;&lt;/a&gt;以太坊源代码&lt;/h2&gt;&lt;p&gt;以太坊中所有的数据都是以键值对的形式存在，使用的底层数据库LevelDB&lt;/p&gt;
&lt;p&gt;交易操作的记录以及相关的数据构成了区块&lt;/p&gt;
&lt;p&gt;交易的结果以账户的状态存在&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://jiaotingyu.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Golang" scheme="http://jiaotingyu.me/tags/Golang/"/>
    
      <category term="以太坊" scheme="http://jiaotingyu.me/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>以太坊学习笔记（九）</title>
    <link href="http://jiaotingyu.me/2018/09/14/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
    <id>http://jiaotingyu.me/2018/09/14/以太坊学习笔记（九）/</id>
    <published>2018-09-13T16:00:00.000Z</published>
    <updated>2020-05-18T15:27:06.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="以太坊源码分析"><a href="#以太坊源码分析" class="headerlink" title="以太坊源码分析"></a>以太坊源码分析</h2><a id="more"></a>
<h3 id="main函数分析"><a href="#main函数分析" class="headerlink" title="main函数分析"></a>main函数分析</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleAction</span><span class="params">(action <span class="keyword">interface</span>&#123;&#125;, context *Context)</span> <span class="params">(err error)</span></span> &#123;</div><div class="line">        <span class="keyword">if</span> a, ok := action.(ActionFunc); ok &#123;</div><div class="line">            <span class="keyword">return</span> a(context)</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> a, ok := action.(<span class="function"><span class="keyword">func</span><span class="params">(*Context)</span> <span class="title">error</span>); <span class="title">ok</span></span> &#123;</div><div class="line">            <span class="keyword">return</span> a(context)</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> a, ok := action.(<span class="function"><span class="keyword">func</span><span class="params">(*Context)</span>); <span class="title">ok</span></span> &#123; <span class="comment">// deprecated function signature</span></div><div class="line">            a(context)</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> errInvalidActionType</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中action类型为第二个分支，执行a(context)，这时会调用App.init()初始化的consoleCommand</p>
<h3 id="分析consoleCommand函数"><a href="#分析consoleCommand函数" class="headerlink" title="分析consoleCommand函数"></a>分析consoleCommand函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">consoleCommand = cli.Command&#123;</div><div class="line">        Action:   utils.MigrateFlags(localConsole),</div><div class="line">        Name:     <span class="string">"console"</span>,</div><div class="line">        Usage:    <span class="string">"Start an interactive JavaScript environment"</span>,</div><div class="line">        Flags:    <span class="built_in">append</span>(<span class="built_in">append</span>(<span class="built_in">append</span>(nodeFlags, rpcFlags...), consoleFlags...), whisperFlags...),</div><div class="line">        Category: <span class="string">"CONSOLE COMMANDS"</span>,</div><div class="line">        Description: <span class="string">`</span></div><div class="line">The Geth console is an interactive shell for the JavaScript runtime environment</div><div class="line">which exposes a node admin interface as well as the Ðapp JavaScript API.</div><div class="line">See https://github.com/ethereum/go-ethereum/wiki/Javascipt-Console.`,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>consoleCommand中包含的Action会执行localConsole函数</p>
<h3 id="分析localConsole函数"><a href="#分析localConsole函数" class="headerlink" title="分析localConsole函数"></a>分析localConsole函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">localConsole</span><span class="params">(ctx *cli.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">    <span class="comment">// Create and start the node based on the CLI flags</span></div><div class="line">    node := makeFullNode(ctx)</div><div class="line">    startNode(ctx, node)</div><div class="line">    <span class="keyword">defer</span> node.Stop()</div><div class="line"></div><div class="line">    <span class="comment">// Attach to the newly started node and start the JavaScript console</span></div><div class="line">    client, err := node.Attach()</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        utils.Fatalf(<span class="string">"Failed to attach to the inproc geth: %v"</span>, err)</div><div class="line">    &#125;</div><div class="line">    config := console.Config&#123;</div><div class="line">        DataDir: utils.MakeDataDir(ctx),</div><div class="line">        DocRoot: ctx.GlobalString(utils.JSpathFlag.Name),</div><div class="line">        Client:  client,</div><div class="line">        Preload: utils.MakeConsolePreloads(ctx),</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    console, err := console.New(config)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        utils.Fatalf(<span class="string">"Failed to start the JavaScript console: %v"</span>, err)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">defer</span> console.Stop(<span class="literal">false</span>)</div><div class="line"></div><div class="line">    <span class="comment">// If only a short execution was requested, evaluate and return</span></div><div class="line">    <span class="keyword">if</span> script := ctx.GlobalString(utils.ExecFlag.Name); script != <span class="string">""</span> &#123;</div><div class="line">        console.Evaluate(script)</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Otherwise print the welcome screen and enter interactive mode</span></div><div class="line">    console.Welcome()</div><div class="line">    console.Interactive()</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>localConsole函数分为3块功能：</strong></p>
<ol>
<li><p>创建并启动一个节点，在结束时停止节点</p>
</li>
<li><p>启动一个js控制台并且与连接刚创建的节点</p>
</li>
<li><p>输出欢迎信息</p>
</li>
</ol>
<h3 id="分析makeFullNode函数"><a href="#分析makeFullNode函数" class="headerlink" title="分析makeFullNode函数"></a>分析makeFullNode函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeFullNode</span><span class="params">(ctx *cli.Context)</span> *<span class="title">node</span>.<span class="title">Node</span></span> &#123;</div><div class="line">    stack, cfg := makeConfigNode(ctx)</div><div class="line"></div><div class="line">    utils.RegisterEthService(stack, &amp;cfg.Eth)</div><div class="line"></div><div class="line">    <span class="comment">// Whisper must be explicitly enabled by specifying at least 1 whisper flag or in dev mode</span></div><div class="line">    shhEnabled := enableWhisper(ctx)</div><div class="line">    shhAutoEnabled := !ctx.GlobalIsSet(utils.WhisperEnabledFlag.Name) &amp;&amp; ctx.GlobalIsSet(utils.DevModeFlag.Name)</div><div class="line">    <span class="keyword">if</span> shhEnabled || shhAutoEnabled &#123;</div><div class="line">        <span class="keyword">if</span> ctx.GlobalIsSet(utils.WhisperMaxMessageSizeFlag.Name) &#123;</div><div class="line">            cfg.Shh.MaxMessageSize = <span class="keyword">uint32</span>(ctx.Int(utils.WhisperMaxMessageSizeFlag.Name))</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> ctx.GlobalIsSet(utils.WhisperMinPOWFlag.Name) &#123;</div><div class="line">            cfg.Shh.MinimumAcceptedPOW = ctx.Float64(utils.WhisperMinPOWFlag.Name)</div><div class="line">        &#125;</div><div class="line">        utils.RegisterShhService(stack, &amp;cfg.Shh)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Add the Ethereum Stats daemon if requested.</span></div><div class="line">    <span class="keyword">if</span> cfg.Ethstats.URL != <span class="string">""</span> &#123;</div><div class="line">        utils.RegisterEthStatsService(stack, cfg.Ethstats.URL)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Add the release oracle service so it boots along with node.</span></div><div class="line">    <span class="keyword">if</span> err := stack.Register(<span class="function"><span class="keyword">func</span><span class="params">(ctx *node.ServiceContext)</span> <span class="params">(node.Service, error)</span></span> &#123;</div><div class="line">        config := release.Config&#123;</div><div class="line">            Oracle: relOracle,</div><div class="line">            Major:  <span class="keyword">uint32</span>(params.VersionMajor),</div><div class="line">            Minor:  <span class="keyword">uint32</span>(params.VersionMinor),</div><div class="line">            Patch:  <span class="keyword">uint32</span>(params.VersionPatch),</div><div class="line">        &#125;</div><div class="line">        commit, _ := hex.DecodeString(gitCommit)</div><div class="line">        <span class="built_in">copy</span>(config.Commit[:], commit)</div><div class="line">        <span class="keyword">return</span> release.NewReleaseService(ctx, config)</div><div class="line">    &#125;); err != <span class="literal">nil</span> &#123;</div><div class="line">        utils.Fatalf(<span class="string">"Failed to register the Geth release oracle service: %v"</span>, err)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> stack</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先使用makeConfigNode函数创建node，然后添加一个和节点同时启动的服务</p>
<h3 id="分析makeConfigNode函数"><a href="#分析makeConfigNode函数" class="headerlink" title="分析makeConfigNode函数"></a>分析makeConfigNode函数</h3><pre><code>func makeConfigNode(ctx *cli.Context) (*node.Node, gethConfig) {
    // Load defaults.
    cfg := gethConfig{
        Eth:  eth.DefaultConfig,
        Shh:  whisper.DefaultConfig,
        Node: defaultNodeConfig(),
    }

    // Load config file.
    if file := ctx.GlobalString(configFileFlag.Name); file != &quot;&quot; {
        if err := loadConfig(file, &amp;cfg); err != nil {
            utils.Fatalf(&quot;%v&quot;, err)
        }
    }

    // Apply flags.
    utils.SetNodeConfig(ctx, &amp;cfg.Node)
    stack, err := node.New(&amp;cfg.Node)
    if err != nil {
        utils.Fatalf(&quot;Failed to create the protocol stack: %v&quot;, err)
    }
    utils.SetEthConfig(ctx, stack, &amp;cfg.Eth)
    if ctx.GlobalIsSet(utils.EthStatsURLFlag.Name) {
        cfg.Ethstats.URL = ctx.GlobalString(utils.EthStatsURLFlag.Name)
    }

    utils.SetShhConfig(ctx, stack, &amp;cfg.Shh)

    return stack, cfg
}
</code></pre><p>函数先初始化config并赋值，然后初始化一个node，node创建完成以后设置EhtConfig和ShhConfig</p>
<h3 id="分析node-New函数"><a href="#分析node-New函数" class="headerlink" title="分析node.New函数"></a>分析node.New函数</h3><p>-</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(conf *Config)</span> <span class="params">(*Node, error)</span></span> &#123;</div><div class="line">    <span class="comment">// Copy config and resolve the datadir so future changes to the current</span></div><div class="line">    <span class="comment">// working directory don't affect the node.</span></div><div class="line">    confCopy := *conf</div><div class="line">    conf = &amp;confCopy</div><div class="line">    <span class="keyword">if</span> conf.DataDir != <span class="string">""</span> &#123;</div><div class="line">        absdatadir, err := filepath.Abs(conf.DataDir)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">        &#125;</div><div class="line">        conf.DataDir = absdatadir</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Ensure that the instance name doesn't cause weird conflicts with</span></div><div class="line">    <span class="comment">// other files in the data directory.</span></div><div class="line">    <span class="keyword">if</span> strings.ContainsAny(conf.Name, <span class="string">`/\`</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">`Config.Name must not contain '/' or '\'`</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> conf.Name == datadirDefaultKeyStore &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">`Config.Name cannot be "`</span> + datadirDefaultKeyStore + <span class="string">`"`</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> strings.HasSuffix(conf.Name, <span class="string">".ipc"</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">`Config.Name cannot end in ".ipc"`</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Ensure that the AccountManager method works before the node has started.</span></div><div class="line">    <span class="comment">// We rely on this in cmd/geth.</span></div><div class="line">    am, ephemeralKeystore, err := makeAccountManager(conf)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Note: any interaction with Config that would create/touch files</span></div><div class="line">    <span class="comment">// in the data directory or instance directory is delayed until Start.</span></div><div class="line">    <span class="keyword">return</span> &amp;Node&#123;</div><div class="line">        accman:            am,</div><div class="line">        ephemeralKeystore: ephemeralKeystore,</div><div class="line">        config:            conf,</div><div class="line">        serviceFuncs:      []ServiceConstructor&#123;&#125;,</div><div class="line">        ipcEndpoint:       conf.IPCEndpoint(),</div><div class="line">        httpEndpoint:      conf.HTTPEndpoint(),</div><div class="line">        wsEndpoint:        conf.WSEndpoint(),</div><div class="line">        eventmux:          <span class="built_in">new</span>(event.TypeMux),</div><div class="line">    &#125;, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先将保存路径转换为绝对路径并进行合法性验证，在节点开始前执行AccountManager，最后一步才是真正的创建节点</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;以太坊源码分析&quot;&gt;&lt;a href=&quot;#以太坊源码分析&quot; class=&quot;headerlink&quot; title=&quot;以太坊源码分析&quot;&gt;&lt;/a&gt;以太坊源码分析&lt;/h2&gt;
    
    </summary>
    
      <category term="技术" scheme="http://jiaotingyu.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Golang" scheme="http://jiaotingyu.me/tags/Golang/"/>
    
      <category term="以太坊" scheme="http://jiaotingyu.me/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>以太坊学习笔记（八）</title>
    <link href="http://jiaotingyu.me/2018/09/11/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89/"/>
    <id>http://jiaotingyu.me/2018/09/11/以太坊学习笔记（八）/</id>
    <published>2018-09-10T16:00:00.000Z</published>
    <updated>2020-05-18T15:26:56.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="以太坊源码分析"><a href="#以太坊源码分析" class="headerlink" title="以太坊源码分析"></a>以太坊源码分析</h2><h3 id="以太坊环境搭建"><a href="#以太坊环境搭建" class="headerlink" title="以太坊环境搭建"></a>以太坊环境搭建</h3><p>搭建go环境 编译源码</p>
<p>编译完成后会生成以下指令</p>
<ol>
<li><p>abigen 源代码生成器，将智能合约转换为Go package，编译Solidity源文件</p>
</li>
<li><p>bootnod 用作轻量级的节点引导工具</p>
</li>
<li><p>evm 可以运行字节码的以太坊虚拟机，可以对evm操作码进行封装</p>
</li>
<li><p>geth 以太坊主要的执行客户端，多用途命令行工具</p>
</li>
<li><p>rlpdump 开发实用工具，可将二进制RLP（递归长度前缀）（以太坊协议网络以及共识使用的数据编码）转储存至用户友好的分层表示</p>
</li>
<li><p>puppeth 命令行执行页面的向导程序，用于创建新的以太坊网络</p>
</li>
<li><p>swarm swarm的守护程序和工具（swarm 是一个分布式存储平台和内容分发服务）</p>
<a id="more"></a>
</li>
</ol>
<h3 id="geth"><a href="#geth" class="headerlink" title="geth"></a>geth</h3><p>geth子命令分为以下几种</p>
<ul>
<li><p>account：账户管理</p>
</li>
<li><p>attach：链接到js环境</p>
</li>
<li><p>bug：报告geth库的错误</p>
</li>
<li><p>console：开启一个js交互环境</p>
</li>
<li><p>copydb：将选中区块链的数据复制到本地</p>
</li>
<li><p>dump：删除指定区块</p>
</li>
<li><p>dumpconfig：显示配置值</p>
</li>
<li><p>export：导出区块链数据</p>
</li>
<li><p>import：导入区块链数据</p>
</li>
<li><p>init：初始化一个新的初始区块（创世区块）</p>
</li>
<li><p>js：执行指定的js文件</p>
</li>
<li><p>license：展示许可信息</p>
</li>
<li><p>makecache：生成用于测试的ethash校验缓存（ethash是工作量证明算法）</p>
</li>
<li><p>makedag：生成用于测试的ethash挖矿DAG（DAG是比特币扩容方案）</p>
</li>
<li><p>monitor：监视节点权值</p>
</li>
<li><p>removedb：移除区块链以及状态数据库</p>
</li>
<li><p>version：显示版本号</p>
</li>
<li><p>wallet：管理以太坊钱包</p>
</li>
</ul>
<h3 id="分析main函数"><a href="#分析main函数" class="headerlink" title="分析main函数"></a>分析main函数</h3><p>首先使用init初始化变量参数</p>
<p>mian方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> err := app.Run(os.Args); err != <span class="literal">nil</span> &#123;</div><div class="line">        fmt.Fprintln(os.Stderr, err)</div><div class="line">        os.Exit(<span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用了app.Run函数</p>
<p>Run方法解析了输入的参数，并且将命令保存到context中，然后调用HandleAction来处理命令</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleAction</span><span class="params">(action <span class="keyword">interface</span>&#123;&#125;, context *Context)</span> <span class="params">(err error)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> a, ok := action.(ActionFunc); ok &#123;</div><div class="line">        <span class="keyword">return</span> a(context)</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> a, ok := action.(<span class="function"><span class="keyword">func</span><span class="params">(*Context)</span> <span class="title">error</span>); <span class="title">ok</span></span> &#123;</div><div class="line">        <span class="keyword">return</span> a(context)</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> a, ok := action.(<span class="function"><span class="keyword">func</span><span class="params">(*Context)</span>); <span class="title">ok</span></span> &#123; <span class="comment">// deprecated function signature</span></div><div class="line">        a(context)</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> errInvalidActionType</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;以太坊源码分析&quot;&gt;&lt;a href=&quot;#以太坊源码分析&quot; class=&quot;headerlink&quot; title=&quot;以太坊源码分析&quot;&gt;&lt;/a&gt;以太坊源码分析&lt;/h2&gt;&lt;h3 id=&quot;以太坊环境搭建&quot;&gt;&lt;a href=&quot;#以太坊环境搭建&quot; class=&quot;headerlink&quot; title=&quot;以太坊环境搭建&quot;&gt;&lt;/a&gt;以太坊环境搭建&lt;/h3&gt;&lt;p&gt;搭建go环境 编译源码&lt;/p&gt;
&lt;p&gt;编译完成后会生成以下指令&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;abigen 源代码生成器，将智能合约转换为Go package，编译Solidity源文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;bootnod 用作轻量级的节点引导工具&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;evm 可以运行字节码的以太坊虚拟机，可以对evm操作码进行封装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;geth 以太坊主要的执行客户端，多用途命令行工具&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;rlpdump 开发实用工具，可将二进制RLP（递归长度前缀）（以太坊协议网络以及共识使用的数据编码）转储存至用户友好的分层表示&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;puppeth 命令行执行页面的向导程序，用于创建新的以太坊网络&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;swarm swarm的守护程序和工具（swarm 是一个分布式存储平台和内容分发服务）&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://jiaotingyu.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Golang" scheme="http://jiaotingyu.me/tags/Golang/"/>
    
      <category term="以太坊" scheme="http://jiaotingyu.me/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
</feed>
